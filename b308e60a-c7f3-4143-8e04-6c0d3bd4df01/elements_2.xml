<?xml version="1.0" encoding="UTF-8"?><elements><element id="8a54eb22-afbb-4741-b3e5-8088e75c9ebd" type="para">XSLT Iterator</element><element id="9b154448-31c9-495f-bc85-ecb297deece8" type="para">XSLT Streaming ist ziemlich tricky. Betrachten wir ein einfaches Problem. Es soll ein kommaseparierter Report aus folgender XML Quelle generiert werden.</element><element id="42d1fe01-af5f-404b-ad50-db590edac041d7e6" type="code">&lt;status-report&gt; &lt;status-change&gt; &lt;billing_id&gt;360788&lt;\/dentaltrac_encounter_id&gt; &lt;claim_ids&gt;967382,673647&lt;\/claim_ids&gt; &lt;status&gt;open&lt;\/status&gt; &lt;time_stamp&gt;2019-02-22T13:53:34.605Z&lt;\/status_time&gt; &lt;\/status-change&gt; &lt;status-change&gt; &lt;billing_id&gt;360788&lt;\/dentaltrac_encounter_id&gt; &lt;claim_ids&gt;967382,673647&lt;\/claim_ids&gt; &lt;status&gt;open&lt;\/status&gt; &lt;time_stamp&gt;2019-02-22T13:53:34.605Z&lt;\/status_time&gt; &lt;\/status-change&gt; [...]</element><element id="22848135-aec4-4770-9e80-b03304ac973cd6e10" type="para">Mit einer Loop und einem Named-Template würde das so gehen:</element><element id="8d008755-8c34-44ba-ad21-e1999591a6e5d7e10" type="code">&lt;xsl:template name=\"main\"&gt; &lt;xsl:for-each select=\"$input-file\/status-report\/status-change\"&gt; &lt;xsl:value-of select=\"concat(billing_id,',')\"\/&gt; &lt;xsl:value-of select=\"concat(claim_ids,',')\"\/&gt; &lt;xsl:value-of select=\"concat(status,',')\"\/&gt; &lt;xsl:value-of select=\"concat(format-dateTime(xs:dateTime(time_stamp), '[Y]-[M]-[D] [H]:[m]'),'&amp;#10;')\"\/&gt; &lt;\/xsl:for-each&gt; &lt;\/xsl:template&gt;</element><element id="73c07d96-20b6-4482-96ce-258d1673e1a7d6e15" type="para">Named-Templates, die direkt über den Saxon Aufruf aufgerufen werden, sind dann brauchbar, wenn keine eindeutige Eingabequelle vorhanden ist, bspw. weil aus mehreren Quellen eingelesen werden soll, wenn die Eingabe von einem Webservice kommt oder vom XSLT Skript selbst erzeugt wird.</element><element id="d769fa8b-5761-43cf-88ab-842d569d1e7dd6e17" type="para">Im vorliegenden Fall wird von einer Datei eingelesen - wir brauchen also kein Named-Template. Statt der Schleife können wir uns auch auf den rekursiven Abstieg des XSLT Prozessors verlassen, was den Code weiter vereinfacht:</element><element id="f00de01b-b264-4749-86ca-8649602ec8c1d7e17" type="code">&lt;xsl:template match=\"\/status-report\/status-change\"&gt; &lt;xsl:value-of select=\"concat(billing_id,',')\"\/&gt; &lt;xsl:value-of select=\"concat(claim_ids,',')\"\/&gt; &lt;xsl:value-of select=\"concat(status,',')\"\/&gt; &lt;xsl:value-of select=\"concat(format-dateTime(xs:dateTime(time_stamp), '[Y]-[M]-[D] [H]:[m]'),'&amp;#10;')\"\/&gt; &lt;\/xsl:template&gt;</element><element id="1babc673-5450-4c9f-94d7-02027e879a51d6e21" type="para">Wollen wir große Datenmengen schnell verarbeiten mit ein paar Hundert MB, so ist es sinnvoll auf die neue XSLT3.0 Streaming Option umzuschalten, weil dadurch kein Eingabebaunm in-Memory aufgebaut wird. Wie schon im Kapitel XSLT Akkumulator angesprochen, gibt es dazu mehrere Möglichkeiten.</element><element id="24530e61-5662-4972-844c-140ea8d8dc0dd6e23" type="para">Wir betrachten hier das  (Doku) Konstrukt und stossen dabei auf einige Fallstricke. Zunächst einmal unsere Settings:</element><element id="d51bf51d-3d8e-4665-9991-84f7d01f7aefd6e27" type="para">Wir benutzen in Verbindung mit dem Attribut, um dem Prozessor mitzuteilen, dass er im Streaming Modus arbeiten soll.</element><element id="edab82eb-21c5-45c3-b543-4c0ac06ad281d6e30" type="para">Wenn wir die Quelle über einen Parameter einlesen, dann müssen wir auch die Transformation über ein Named-Template starten.</element><element id="0d5b49f3-2dfb-475c-b317-d76e9aac06a0d6e33" type="para">Ohne zu wissen, wie XSLT Streaming genau funktioniert, setzen wir eine Reihe von statements in den Iterator:</element><element id="74c092e4-f27b-4978-9efa-7fb0d8410625d7e36" type="code">&lt;xsl:template name=\"main\"&gt; &lt;xsl:source-document href=\"{$input-file}\" streamable='yes'&gt; &lt;xsl:iterate select=\"status-report\/status-change\"&gt; &lt;xsl:value-of select=\"concat(billing_id,',')\"\/&gt; &lt;xsl:value-of select=\"concat(claim_ids,',')\"\/&gt; &lt;xsl:value-of select=\"concat(status,',')\"\/&gt; &lt;xsl:value-of select=\"concat(format-dateTime(xs:dateTime(time_stamp), '[Y]-[M]-[D] [H]:[m]'),'&amp;#10;')\"\/&gt; &lt;\/xsl:iterate&gt; &lt;\/xsl:source-document&gt; &lt;\/xsl:template&gt;</element><element id="63c6b0e7-5dbc-499b-87d1-a8f566085023d6e37" type="para">und werden dafür prompt mit einer Fehlermeldung belohnt:</element><element id="353267c4-7177-4109-8eec-93efe0aa0fb9d7e40" type="code">Static error on line 16 column 64 of report.xsl: XTSE3430: The body of the xsl:stream instruction is not streamable * There is more than one consuming operand: {xsl:value-of} on line 18, and {xsl:value-of} on line 19</element><element id="ed797bc5-78cf-4d81-8f07-25d049bb3e78d6e41" type="para">In diesem Iterator ist also nur eine \"konsumierende\" Operation erlaubt. Um nur einmal zu selektieren, müssen wir - auf Kosten der Lesbarkeit - ziemlich umbauen. Eine Lösung könnte z.B. so aussehen:</element><element id="80af19cf-055c-47d1-bbac-b4e7a5b7490dd7e44" type="code">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;xsl:stylesheet xmlns:xsl=\"http:\/\/www.w3.org\/1999\/XSL\/Transform\" xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\" exclude-result-prefixes=\"xs\" xpath-default-namespace=\"https:\/\/tekturcms.de\/schema\/status-report\/1.0\" version=\"3.0\"&gt; &lt;xsl:param name=\"input-file\" required=\"yes\"\/&gt; &lt;xsl:output method=\"text\"\/&gt; &lt;!-- https:\/\/www.saxonica.com\/html\/documentation\/xsl-elements\/iterate.html --&gt; &lt;xsl:template name=\"main\"&gt; &lt;xsl:source-document href=\"{$input-file}\" streamable='yes'&gt; &lt;xsl:iterate select=\"status-report\/status-change\/*\"&gt; &lt;xsl:choose&gt; &lt;xsl:when test=\"name()='time_stamp'\"&gt; &lt;xsl:value-of select=\"concat(format-dateTime(xs:dateTime(time_stamp), '[Y]-[M]-[D] [H]:[m]'),'&amp;#10;')\"\/&gt; &lt;\/xsl:when&gt; &lt;xsl:otherwise&gt; &lt;xsl:value-of select=\"concat(.,',')\"\/&gt; &lt;\/xsl:otherwise&gt; &lt;\/xsl:choose&gt; &lt;\/xsl:iterate&gt; &lt;\/xsl:source-document&gt; &lt;\/xsl:template&gt; &lt;\/xsl:stylesheet&gt;</element><element id="469ff8e1-b60e-47fa-906b-f0ba5ffcbe0ed6e48" type="para">Hier wird davon ausgegangen, dass das Element mit Namen 'time_stamp' als letztes in der Sequenz vorkommt und beim Auftreten ( ) wird ein Zeilenumbruch gesetzt. Der deklarative Ansatz aus dem ersten Beispiel geht dabei verloren.</element><element id="b7628b73-64d2-4adb-9e79-b0c0e27ea202d6e51" type="para">Logisch wird beim XSLT Streaming auf einer niedrigeren Abstraktionsebene programmiert, um den Anforderungen des Prozessors gerecht zu werden.</element><element id="25b7064f-3652-4cf9-96d9-de474327f073d6e53" type="para">Für eine 1.6 GB Datei benötigt das obige Skript auf meinem Rechner gute drei Minuten . Der traditionelle temlate-match Ansatz bricht mit einer Out-of-Memory Exception ab, selbst wenn man den Java Heap Size auf 4GB einstellt.</element></elements>