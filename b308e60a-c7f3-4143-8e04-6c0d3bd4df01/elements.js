[{"id":"8a54eb22-afbb-4741-b3e5-8088e75c9ebd","type":"para","text":"XSLT Iterator","title":" XSLT Iterator "},{"id":"9b154448-31c9-495f-bc85-ecb297deece8","type":"para","text":"XSLT Streaming ist ziemlich tricky. Betrachten wir ein einfaches Problem. Es soll ein kommaseparierter Report aus folgender XML Quelle generiert werden.","title":" XSLT Iterator "},{"id":"42d1fe01-af5f-404b-ad50-db590edac041d7e6","type":"code","text":"<status-report> <status-change> <billing_id>360788<\/dentaltrac_encounter_id> <claim_ids>967382,673647<\/claim_ids> <status>open<\/status> <time_stamp>2019-02-22T13:53:34.605Z<\/status_time> <\/status-change> <status-change> <billing_id>360788<\/dentaltrac_encounter_id> <claim_ids>967382,673647<\/claim_ids> <status>open<\/status> <time_stamp>2019-02-22T13:53:34.605Z<\/status_time> <\/status-change> [...]","title":" XSLT Iterator "},{"id":"22848135-aec4-4770-9e80-b03304ac973cd6e10","type":"para","text":"Mit einer Loop und einem Named-Template würde das so gehen:","title":" XSLT Iterator "},{"id":"8d008755-8c34-44ba-ad21-e1999591a6e5d7e10","type":"code","text":"<xsl:template name=\"main\"> <xsl:for-each select=\"$input-file\/status-report\/status-change\"> <xsl:value-of select=\"concat(billing_id,',')\"\/> <xsl:value-of select=\"concat(claim_ids,',')\"\/> <xsl:value-of select=\"concat(status,',')\"\/> <xsl:value-of select=\"concat(format-dateTime(xs:dateTime(time_stamp), '[Y]-[M]-[D] [H]:[m]'),'&#10;')\"\/> <\/xsl:for-each> <\/xsl:template>","title":" XSLT Iterator "},{"id":"73c07d96-20b6-4482-96ce-258d1673e1a7d6e15","type":"para","text":"Named-Templates, die direkt über den Saxon Aufruf aufgerufen werden, sind dann brauchbar, wenn keine eindeutige Eingabequelle vorhanden ist, bspw. weil aus mehreren Quellen eingelesen werden soll, wenn die Eingabe von einem Webservice kommt oder vom XSLT Skript selbst erzeugt wird.","title":" XSLT Iterator "},{"id":"d769fa8b-5761-43cf-88ab-842d569d1e7dd6e17","type":"para","text":"Im vorliegenden Fall wird von einer Datei eingelesen - wir brauchen also kein Named-Template. Statt der Schleife können wir uns auch auf den rekursiven Abstieg des XSLT Prozessors verlassen, was den Code weiter vereinfacht:","title":" XSLT Iterator "},{"id":"f00de01b-b264-4749-86ca-8649602ec8c1d7e17","type":"code","text":"<xsl:template match=\"\/status-report\/status-change\"> <xsl:value-of select=\"concat(billing_id,',')\"\/> <xsl:value-of select=\"concat(claim_ids,',')\"\/> <xsl:value-of select=\"concat(status,',')\"\/> <xsl:value-of select=\"concat(format-dateTime(xs:dateTime(time_stamp), '[Y]-[M]-[D] [H]:[m]'),'&#10;')\"\/> <\/xsl:template>","title":" XSLT Iterator "},{"id":"1babc673-5450-4c9f-94d7-02027e879a51d6e21","type":"para","text":"Wollen wir große Datenmengen schnell verarbeiten mit ein paar Hundert MB, so ist es sinnvoll auf die neue XSLT3.0 Streaming Option umzuschalten, weil dadurch kein Eingabebaunm in-Memory aufgebaut wird. Wie schon im Kapitel XSLT Akkumulator angesprochen, gibt es dazu mehrere Möglichkeiten.","title":" XSLT Iterator "},{"id":"24530e61-5662-4972-844c-140ea8d8dc0dd6e23","type":"para","text":"Wir betrachten hier das (Doku) Konstrukt und stossen dabei auf einige Fallstricke. Zunächst einmal unsere Settings:","title":" XSLT Iterator "},{"id":"d51bf51d-3d8e-4665-9991-84f7d01f7aefd6e27","type":"para","text":"Wir benutzen in Verbindung mit dem Attribut, um dem Prozessor mitzuteilen, dass er im Streaming Modus arbeiten soll.","title":" XSLT Iterator "},{"id":"edab82eb-21c5-45c3-b543-4c0ac06ad281d6e30","type":"para","text":"Wenn wir die Quelle über einen Parameter einlesen, dann müssen wir auch die Transformation über ein Named-Template starten.","title":" XSLT Iterator "},{"id":"0d5b49f3-2dfb-475c-b317-d76e9aac06a0d6e33","type":"para","text":"Ohne zu wissen, wie XSLT Streaming genau funktioniert, setzen wir eine Reihe von statements in den Iterator:","title":" XSLT Iterator "},{"id":"74c092e4-f27b-4978-9efa-7fb0d8410625d7e36","type":"code","text":"<xsl:template name=\"main\"> <xsl:source-document href=\"{$input-file}\" streamable='yes'> <xsl:iterate select=\"status-report\/status-change\"> <xsl:value-of select=\"concat(billing_id,',')\"\/> <xsl:value-of select=\"concat(claim_ids,',')\"\/> <xsl:value-of select=\"concat(status,',')\"\/> <xsl:value-of select=\"concat(format-dateTime(xs:dateTime(time_stamp), '[Y]-[M]-[D] [H]:[m]'),'&#10;')\"\/> <\/xsl:iterate> <\/xsl:source-document> <\/xsl:template>","title":" XSLT Iterator "},{"id":"63c6b0e7-5dbc-499b-87d1-a8f566085023d6e37","type":"para","text":"und werden dafür prompt mit einer Fehlermeldung belohnt:","title":" XSLT Iterator "},{"id":"353267c4-7177-4109-8eec-93efe0aa0fb9d7e40","type":"code","text":"Static error on line 16 column 64 of report.xsl: XTSE3430: The body of the xsl:stream instruction is not streamable * There is more than one consuming operand: {xsl:value-of} on line 18, and {xsl:value-of} on line 19","title":" XSLT Iterator "},{"id":"ed797bc5-78cf-4d81-8f07-25d049bb3e78d6e41","type":"para","text":"In diesem Iterator ist also nur eine \"konsumierende\" Operation erlaubt. Um nur einmal zu selektieren, müssen wir - auf Kosten der Lesbarkeit - ziemlich umbauen. Eine Lösung könnte z.B. so aussehen:","title":" XSLT Iterator "},{"id":"80af19cf-055c-47d1-bbac-b4e7a5b7490dd7e44","type":"code","text":"<?xml version=\"1.0\" encoding=\"UTF-8\"?> <xsl:stylesheet xmlns:xsl=\"http:\/\/www.w3.org\/1999\/XSL\/Transform\" xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\" exclude-result-prefixes=\"xs\" xpath-default-namespace=\"https:\/\/tekturcms.de\/schema\/status-report\/1.0\" version=\"3.0\"> <xsl:param name=\"input-file\" required=\"yes\"\/> <xsl:output method=\"text\"\/> <!-- https:\/\/www.saxonica.com\/html\/documentation\/xsl-elements\/iterate.html --> <xsl:template name=\"main\"> <xsl:source-document href=\"{$input-file}\" streamable='yes'> <xsl:iterate select=\"status-report\/status-change\/*\"> <xsl:choose> <xsl:when test=\"name()='time_stamp'\"> <xsl:value-of select=\"concat(format-dateTime(xs:dateTime(time_stamp), '[Y]-[M]-[D] [H]:[m]'),'&#10;')\"\/> <\/xsl:when> <xsl:otherwise> <xsl:value-of select=\"concat(.,',')\"\/> <\/xsl:otherwise> <\/xsl:choose> <\/xsl:iterate> <\/xsl:source-document> <\/xsl:template> <\/xsl:stylesheet>","title":" XSLT Iterator "},{"id":"469ff8e1-b60e-47fa-906b-f0ba5ffcbe0ed6e48","type":"para","text":"Hier wird davon ausgegangen, dass das Element mit Namen 'time_stamp' als letztes in der Sequenz vorkommt und beim Auftreten ( ) wird ein Zeilenumbruch gesetzt. Der deklarative Ansatz aus dem ersten Beispiel geht dabei verloren.","title":" XSLT Iterator "},{"id":"b7628b73-64d2-4adb-9e79-b0c0e27ea202d6e51","type":"para","text":"Logisch wird beim XSLT Streaming auf einer niedrigeren Abstraktionsebene programmiert, um den Anforderungen des Prozessors gerecht zu werden.","title":" XSLT Iterator "},{"id":"25b7064f-3652-4cf9-96d9-de474327f073d6e53","type":"para","text":"Für eine 1.6 GB Datei benötigt das obige Skript auf meinem Rechner gute drei Minuten . Der traditionelle temlate-match Ansatz bricht mit einer Out-of-Memory Exception ab, selbst wenn man den Java Heap Size auf 4GB einstellt.","title":" XSLT Iterator "}]