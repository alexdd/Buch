<div class="topic show_menu tags" data-element="topic" data-deletable="false" data-attribute-id="e7a9c8c6-7155-402a-9c95-89d45fc022de" data-tektur-editor-id="90252b03-6c4e-41f0-b64a-8ecb09735f78"><div class="gui-optional-elements-button" contenteditable="false"><div class="menu-icon" style="display:none">+</div></div><div class="title pmarker tags" contenteditable="true" data-element="title" data-attribute-id="8a54eb22-afbb-4741-b3e5-8088e75c9ebd" data-tektur-editor-id="2efdd1d9-4c99-4afb-9208-e39d3ae5acf1">XSLT Iterator</div><div class="abstract optional show_menu tags" style="display:none" data-element="abstract" data-excluding="shortdesc" data-tektur-editor-id="657cb683-da36-45aa-b694-77f7df8dc931"><div class="gui-optional-elements-button" contenteditable="false"><div class="menu-icon" style="display:none">+</div></div><div class="placeholder text pmarker tags" contenteditable="true" data-element="p" data-tektur-editor-id="2632b536-5856-447f-b1d2-05eca048acf2"></div></div><div class="body show_menu tags" data-element="body" data-deletable="false" data-attribute-id="a4eb5204-67d2-446b-97f6-89871c6a031d" data-tektur-editor-id="5e64b8fc-9f27-4485-b614-83c6a4a5a3bc"><div class="gui-optional-elements-button" contenteditable="false"><div class="menu-icon" style="display:none">+</div></div><div class="section tektur-wrapper tags" data-element="section" data-tektur-editor-id="2dc93309-5ceb-4cd9-b0f4-38fc726c19e2"><div class="p pmarker tags" contenteditable="true" xmlns:xlink="http://www.w3.org/1999/xlink" data-element="p" data-attribute-id="9b154448-31c9-495f-bc85-ecb297deece8" xmlns:xr="http://www.tekturcms.de/2012/xr/common" data-tektur-editor-id="3511a6df-9efd-4a41-a61e-b4e1d7159d36">XSLT Streaming[[xe1:XSLT Streaming]] ist ziemlich tricky. Betrachten wir ein einfaches Problem.</div><div class="p pmarker tags" contenteditable="true" xmlns:xlink="http://www.w3.org/1999/xlink" data-element="p" data-attribute-id="aa76d0b9-61b5-44c5-9ee7-d7af8676826fd6e6" xmlns:xr="http://www.tekturcms.de/2012/xr/common" data-tektur-editor-id="d8e95b08-b00d-4641-b821-65df183a5050">Es soll ein kommaseparierter Report aus folgender XML Quelle generiert werden:</div><div class="pre"><div class="pre-content pmarker tags" contenteditable="true" data-element="pre" data-attribute-id="b1cbb8ed-1050-45a1-a75e-f748524ff48fd6e8" data-attribute-xml_space="preserve" data-tektur-editor-id="41e82081-35f9-48c7-be8e-884d99327adc">&#x3C;status-report&#x3E;
  &#x3C;status-change&#x3E;
    &#x3C;billing_id&#x3E;360788&#x3C;/dentaltrac_encounter_id&#x3E;
    &#x3C;claim_ids&#x3E;967382,673647&#x3C;/claim_ids&#x3E;
    &#x3C;status&#x3E;open&#x3C;/status&#x3E;
    &#x3C;time_stamp&#x3E;2019-02-22T13:53:34.605Z&#x3C;/status_time&#x3E;
  &#x3C;/status-change&#x3E;
  &#x3C;status-change&#x3E;
    &#x3C;billing_id&#x3E;360788&#x3C;/dentaltrac_encounter_id&#x3E;
    &#x3C;claim_ids&#x3E;967382,673647&#x3C;/claim_ids&#x3E;
    &#x3C;status&#x3E;open&#x3C;/status&#x3E;
    &#x3C;time_stamp&#x3E;2019-02-22T13:53:34.605Z&#x3C;/status_time&#x3E;
  &#x3C;/status-change&#x3E;
  [...]</div></div><div class="p pmarker tags" contenteditable="true" xmlns:xlink="http://www.w3.org/1999/xlink" data-element="p" data-attribute-id="22848135-aec4-4770-9e80-b03304ac973cd6e10" xmlns:xr="http://www.tekturcms.de/2012/xr/common" data-tektur-editor-id="1721388e-4770-4b28-b717-ba85778ac9d3">Mit einer [[code:for-each]] Loop und einem Named-Template würde das so gehen:</div><div class="pre"><div class="pre-content pmarker tags" contenteditable="true" data-element="pre" data-attribute-id="6a4ec72b-a5fc-4170-abaf-86065a7a0bd1d6e12" data-attribute-xml_space="preserve" data-tektur-editor-id="27436cde-cf22-406f-bb45-0aa94d834ee2"><div>&#x3C;xsl:template name="main"&#x3E;
  &#x3C;xsl:for-each select="$input-file/status-report/status-change"&#x3E;
    &#x3C;xsl:value-of select="concat(billing_id,',')"/&#x3E;
    &#x3C;xsl:value-of select="concat(claim_ids,',')"/&#x3E;
    &#x3C;xsl:value-of select="concat(status,',')"/&#x3E;
    &#x3C;xsl:value-of select="concat(format-dateTime(xs:dateTime(time_stamp),</div><div>                                        '[Y]-[M]-[D] [H]:[m]'),'&#x26;#10;')"/&#x3E;
  &#x3C;/xsl:for-each&#x3E;
&#x3C;/xsl:template&#x3E;</div></div></div><div class="placeholder text pmarker tags" contenteditable="true" data-element="p" data-tektur-editor-id="2aa8eaa9-dc6a-4709-9e1c-4e0f68309932"></div><div class="show_menu tags" data-element="note" data-tektur-editor-id="fd8a3aef-75e3-4881-b8f8-1cd957e4ccf3"><div class="gui-optional-elements-button" contenteditable="false"><div class="menu-icon" style="display:none">+</div></div><div class="note"><div class="signal-word">NOTE</div><div class="hcontent"><div class="p pmarker tags" contenteditable="true" xmlns:xlink="http://www.w3.org/1999/xlink" data-element="p" data-attribute-id="73c07d96-20b6-4482-96ce-258d1673e1a7d6e15" xmlns:xr="http://www.tekturcms.de/2012/xr/common" data-tektur-editor-id="27d2f071-a736-43c6-8a0a-ee5e3804bb16">Named-Templates, die direkt über den Saxon Aufruf [[code:saxon -it:main]] aufgerufen werden, sind dann
brauchbar, wenn keine eindeutige Eingabequelle vorhanden ist, bspw. weil aus mehreren
Quellen eingelesen werden soll, wenn die Eingabe von einem Webservice kommt oder 
vom XSLT Skript selbst erzeugt wird.</div></div></div></div><div class="p pmarker tags" contenteditable="true" xmlns:xlink="http://www.w3.org/1999/xlink" data-element="p" data-attribute-id="d769fa8b-5761-43cf-88ab-842d569d1e7dd6e17" xmlns:xr="http://www.tekturcms.de/2012/xr/common" data-tektur-editor-id="1bdba9c7-bb6d-4289-b98a-77fd21a70657">Im vorliegenden Fall wird von einer Datei eingelesen - wir brauchen also kein Named-Template. Statt der [[:code]]for-each Schleife können wir uns auch auf den rekursiven Abstieg des XSLT Prozessors
verlassen, was den Code weiter vereinfacht:</div><div class="pre"><div class="pre-content pmarker tags" contenteditable="true" data-element="pre" data-attribute-id="e09e40c3-ab31-44cd-a416-593b5bbb1cffd6e19" data-attribute-xml_space="preserve" data-tektur-editor-id="503281ee-f4b4-4ee0-9e6b-76862a7cd0fb"><div>&#x3C;xsl:template match="/status-report/status-change"&#x3E;
  &#x3C;xsl:value-of select="concat(billing_id,',')"/&#x3E;
  &#x3C;xsl:value-of select="concat(claim_ids,',')"/&#x3E;
  &#x3C;xsl:value-of select="concat(status,',')"/&#x3E;
  &#x3C;xsl:value-of select="concat(format-dateTime(xs:dateTime(time_stamp),</div><div>                                      '[Y]-[M]-[D] [H]:[m]'),'&#x26;#10;')"/&#x3E;
&#x3C;/xsl:template&#x3E;</div></div></div><div class="p pmarker tags" contenteditable="true" xmlns:xlink="http://www.w3.org/1999/xlink" data-element="p" data-attribute-id="1babc673-5450-4c9f-94d7-02027e879a51d6e21" xmlns:xr="http://www.tekturcms.de/2012/xr/common" data-tektur-editor-id="743a4ce2-bf66-43e8-936b-040366ca9acc">Wollen wir große Datenmengen schnell verarbeiten mit ein paar Hundert MB, so ist es sinnvoll
auf die neue XSLT3.0 Streaming Option umzuschalten, weil dadurch kein Eingabebaunm in-Memory
aufgebaut wird. Wie schon im Kapitel <span class="link tags" href="51bec5b9-1207-45cc-9bf2-b6ce3e300547" data-type="topic" data-element="link" data-tektur-editor-id="e78aa311-072e-49b7-8248-47e00991e0c7">XSLT Streaming</span> angesprochen, gibt es dazu mehrere Möglichkeiten.</div><div class="p pmarker tags" contenteditable="true" xmlns:xlink="http://www.w3.org/1999/xlink" data-element="p" data-attribute-id="24530e61-5662-4972-844c-140ea8d8dc0dd6e23" xmlns:xr="http://www.tekturcms.de/2012/xr/common" data-tektur-editor-id="bf9e3c95-826a-4a6c-9786-f9a316259b6f">Wir betrachten hier das [[code:xsl:iterator]][[fn:https://www.saxonica.com/html/documentation/xsl-elements/iterate.html*Der Iterator ist ein Konzept um XSLT Streaming zu realisieren]]
 Konstrukt und stossen dabei auf einige Fallstricke. Zunächst einmal unsere Settings:</div><ul class="ul tags" data-element="ul" data-attribute-id="4a98621c-143a-4c7b-9943-ff38c9887bc5d6e25" data-tektur-editor-id="c292565b-3d9e-4a97-98d9-717bedac512f"><li class="li tags" data-element="li" data-attribute-id="fbfa58c7-8873-4589-8458-2cee8344e3b9d6e26" data-tektur-editor-id="8c6584f4-7d5d-4786-980e-a0727afc89f9"><div class="p pmarker tags" contenteditable="true" xmlns:xlink="http://www.w3.org/1999/xlink" data-element="p" data-attribute-id="d51bf51d-3d8e-4665-9991-84f7d01f7aefd6e27" xmlns:xr="http://www.tekturcms.de/2012/xr/common" data-tektur-editor-id="cde18c87-1151-4eaa-b36a-0f8cfe7d9cb0">Wir benutzen [[code:xsl:source-document]] in Verbindung mit dem [[code:streamable='yes']] Attribut,
um dem Prozessor mitzuteilen, dass er im Streaming Modus arbeiten soll.</div></li><li class="li tags" data-element="li" data-attribute-id="658c209b-2f3a-4dde-9fc2-6b996f8ae4b5d6e29" data-tektur-editor-id="eab81a98-e466-4fc6-844e-a2a5a8db85f8"><div class="p pmarker tags" contenteditable="true" xmlns:xlink="http://www.w3.org/1999/xlink" data-element="p" data-attribute-id="edab82eb-21c5-45c3-b543-4c0ac06ad281d6e30" xmlns:xr="http://www.tekturcms.de/2012/xr/common" data-tektur-editor-id="4e44cce0-ca94-4883-8b5c-83fee7652b25">Wenn wir die Quelle über einen Parameter einlesen, dann müssen wir auch die Transformation über ein Named-Template
starten.</div></li></ul><div class="p pmarker tags" contenteditable="true" xmlns:xlink="http://www.w3.org/1999/xlink" data-element="p" data-attribute-id="0d5b49f3-2dfb-475c-b317-d76e9aac06a0d6e33" xmlns:xr="http://www.tekturcms.de/2012/xr/common" data-tektur-editor-id="d7f7be28-1437-4dd7-9f96-6a757ff1eae9">Ohne zu wissen, wie XSLT Streaming genau funktioniert, setzen wir eine Reihe von [[code:value-of select]] statements in den Iterator:</div><div class="pre"><div class="pre-content pmarker tags" contenteditable="true" data-element="pre" data-attribute-id="75f09353-ffdd-4a93-aed0-f98e7ca2be14d6e38" data-attribute-xml_space="preserve" data-tektur-editor-id="a5a104c0-ca71-4d13-a118-4afad9b33ea1"><div>&#x3C;xsl:template name="main"&#x3E;
  &#x3C;xsl:source-document href="{$input-file}" streamable='yes'&#x3E;
    &#x3C;xsl:iterate select="status-report/status-change"&#x3E;
      &#x3C;xsl:value-of select="concat(billing_id,',')"/&#x3E;
      &#x3C;xsl:value-of select="concat(claim_ids,',')"/&#x3E;
      &#x3C;xsl:value-of select="concat(status,',')"/&#x3E;
      &#x3C;xsl:value-of select="concat(format-dateTime(xs:dateTime(time_stamp),</div><div>                                          '[Y]-[M]-[D] [H]:[m]'),'&#x26;#10;')"/&#x3E;
    &#x3C;/xsl:iterate&#x3E;
  &#x3C;/xsl:source-document&#x3E; 
&#x3C;/xsl:template&#x3E;</div></div></div><div class="p pmarker tags" contenteditable="true" xmlns:xlink="http://www.w3.org/1999/xlink" data-element="p" data-attribute-id="63c6b0e7-5dbc-499b-87d1-a8f566085023d6e37" xmlns:xr="http://www.tekturcms.de/2012/xr/common" data-tektur-editor-id="7106677c-3102-4341-95b0-b24a65eda7ab">und werden dafür prompt mit einer Fehlermeldung belohnt:</div><div class="pre"><div class="pre-content pmarker tags" contenteditable="true" data-element="pre" data-attribute-id="b17f1037-f239-48f6-82dd-797b52fd6a3cd6e42" data-attribute-xml_space="preserve" data-tektur-editor-id="d5a8a5f9-e5d5-4bb5-a8e6-9179a76efb22">Static error on line 16 column 64 of report.xsl:
  XTSE3430: The body of the xsl:stream instruction is not streamable
  *  There is more than one consuming operand: {xsl:value-of} on line 18, and
  {xsl:value-of} on line 19</div></div><div class="p pmarker tags" contenteditable="true" xmlns:xlink="http://www.w3.org/1999/xlink" data-element="p" data-attribute-id="ed797bc5-78cf-4d81-8f07-25d049bb3e78d6e41" xmlns:xr="http://www.tekturcms.de/2012/xr/common" data-tektur-editor-id="561d85c5-43da-4a7d-ba39-94a6f1956c49">In diesem Iterator ist also nur eine "konsumierende" [[code:value-of]] Operation erlaubt. Um nur einmal zu selektieren, müssen wir - auf Kosten der Lesbarkeit - ziemlich umbauen. Eine Lösung könnte z.B. so aussehen:</div><div class="pre"><div class="pre-content pmarker tags" contenteditable="true" data-element="pre" data-attribute-id="a1dbdf2a-5258-45a7-936c-148af4df6e05d6e46" data-attribute-xml_space="preserve" data-tektur-editor-id="66aa5be8-4849-4ec8-bcf2-1f4fd43750db">&#x3C;?xml version="1.0" encoding="UTF-8"?&#x3E;
&#x3C;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  exclude-result-prefixes="xs"
  xpath-default-namespace="https://tekturcms.de/schema/status-report/1.0"
  version="3.0"&#x3E;
   
  &#x3C;xsl:param name="input-file" required="yes"/&#x3E;
  
  &#x3C;xsl:output method="text"/&#x3E;
 
  &#x3C;!-- https://www.saxonica.com/html/documentation/xsl-elements/iterate.html --&#x3E;

  &#x3C;xsl:template name="main"&#x3E;
    &#x3C;xsl:source-document href="{$input-file}" streamable='yes'&#x3E;
      &#x3C;xsl:iterate select="status-report/status-change/*"&#x3E;
        &#x3C;xsl:choose&#x3E;
          &#x3C;xsl:when test="name()='time_stamp'"&#x3E;
            &#x3C;xsl:value-of select="concat(format-dateTime(xs:dateTime(time_stamp),
                                               '[Y]-[M]-[D] [H]:[m]'),'&#x26;#10;')"/&#x3E;
          &#x3C;/xsl:when&#x3E;
          &#x3C;xsl:otherwise&#x3E;
            &#x3C;xsl:value-of select="concat(.,',')"/&#x3E;
          &#x3C;/xsl:otherwise&#x3E;
        &#x3C;/xsl:choose&#x3E;
      &#x3C;/xsl:iterate&#x3E;
    &#x3C;/xsl:source-document&#x3E;
  &#x3C;/xsl:template&#x3E;  
&#x3C;/xsl:stylesheet&#x3E;
</div></div><div class="p pmarker tags" contenteditable="true" xmlns:xlink="http://www.w3.org/1999/xlink" data-element="p" data-attribute-id="469ff8e1-b60e-47fa-906b-f0ba5ffcbe0ed6e48" xmlns:xr="http://www.tekturcms.de/2012/xr/common" data-tektur-editor-id="dfd76d28-0b93-48ed-86ad-b4e692f49537">Hier wird davon ausgegangen, dass das Element mit Namen 'time_stamp' als letztes in der Sequenz vorkommt und beim Auftreten ([[code:&#x26;#10;]]) wird ein Zeilenumbruch gesetzt. Der deklarative Ansatz aus dem ersten Beispiel geht dabei verloren. </div><div class="show_menu tags" data-element="note" data-tektur-editor-id="ae25f154-edaf-4b5e-8c5c-02f6e18531b3"><div class="gui-optional-elements-button" contenteditable="false"><div class="menu-icon" style="display:none">+</div></div><div class="note"><div class="signal-word">NOTE</div><div class="hcontent"><div class="p pmarker tags" contenteditable="true" xmlns:xlink="http://www.w3.org/1999/xlink" data-element="p" data-attribute-id="b7628b73-64d2-4adb-9e79-b0c0e27ea202d6e51" xmlns:xr="http://www.tekturcms.de/2012/xr/common" data-tektur-editor-id="305a1cbc-7bfc-4923-8fea-df3509aa42d5">Logisch wird beim XSLT Streaming auf einer niedrigeren Abstraktionsebene programmiert, um den Anforderungen des Prozessors gerecht zu werden.</div></div></div></div><div class="p pmarker tags" contenteditable="true" xmlns:xlink="http://www.w3.org/1999/xlink" data-element="p" data-attribute-id="25b7064f-3652-4cf9-96d9-de474327f073d6e53" xmlns:xr="http://www.tekturcms.de/2012/xr/common" data-tektur-editor-id="e0d2e196-f20b-4ac5-b7ce-823b4423eb43">Für eine <span class="b tags" data-element="b" data-attribute-id="61cd3405-cf36-4bc0-a923-4074c1eb8973d6e55" data-tektur-editor-id="17c2eef0-db97-43c7-84e1-e9880de0f3d0">1.6 GB Datei</span> benötigt das obige Skript auf meinem Rechner gute<span class="b tags" data-element="b" data-attribute-id="90b6c3a0-5c88-4ee6-a51d-e9d6bd76df56d6e58" data-tektur-editor-id="3a13106b-f156-4cc7-a76e-142b8f1e1b81"> drei Minuten</span>. Der traditionelle temlate-match Ansatz bricht mit einer Out-of-Memory Exception ab, selbst wenn man den Java Heap Size auf 4GB einstellt.</div></div></div></div>