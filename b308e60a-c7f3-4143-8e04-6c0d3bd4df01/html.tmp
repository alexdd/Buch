<div data-attribute-id="e7a9c8c6-7155-402a-9c95-89d45fc022de" class="topic show_menu tags" data-element="topic" data-deletable="false" data-tektur-editor-id="3151b398-f950-4713-8342-2e6ab5c394c8"><div class="gui-optional-elements-button" contenteditable="false"><div class="menu-icon" style="display:none">+</div></div><div data-attribute-id="8a54eb22-afbb-4741-b3e5-8088e75c9ebd" class="title pmarker tags" data-element="title" data-tektur-editor-id="3c7e59db-93a6-4b74-998d-0d966e23ecf2" contenteditable="true">XSLT Iterator</div><div class="abstract optional show_menu tags" data-element="abstract" data-excluding="shortdesc" style="display:none" data-tektur-editor-id="1bea8af0-2a1d-4cac-99bc-27bb9c7d945f"><div class="gui-optional-elements-button" contenteditable="false"><div class="menu-icon" style="display:none">+</div></div><div class="placeholder text pmarker tags" data-element="p" data-tektur-editor-id="a980e12a-4909-4bcc-9458-59fec841a807" contenteditable="true"></div></div><div data-attribute-id="a4eb5204-67d2-446b-97f6-89871c6a031d" class="body show_menu tags" data-element="body" data-deletable="false" data-tektur-editor-id="ff8a9667-ae0e-4ce8-9c5d-bd9ef303a88d"><div class="gui-optional-elements-button" contenteditable="false"><div class="menu-icon" style="display:none">+</div></div><div class="section tektur-wrapper tags" data-element="section" data-tektur-editor-id="0274d026-aceb-48b6-967c-cc93b11649bf"><div xmlns:xr="http://www.tekturcms.de/2012/xr/common" xmlns:xlink="http://www.w3.org/1999/xlink" data-attribute-id="9b154448-31c9-495f-bc85-ecb297deece8" class="p pmarker tags" data-element="p" data-tektur-editor-id="d783fd80-6bdd-467b-b050-a930baed6f52" contenteditable="true">XSLT Streaming<span class="bracket-tags-marker" id="846b3abe-eecd-43bc-b5dc-49307ac8dd1d">[[<span class="bracket-tags">xe1:Verarbeitungsmethoden; xe2:XSLT Streaming</span>]]</span> ist ziemlich tricky. Betrachten wir ein einfaches Problem. Es soll ein kommaseparierter Report aus folgender XML Quelle generiert werden.</div><div class="pre"><div data-attribute-id="cd0c5f83-0252-4fd2-bc17-698d581c13b4d7e6" data-attribute-xml_space="preserve" class="pre-content pmarker tags" data-element="pre" data-tektur-editor-id="270626a5-7e5e-4280-bf04-6cafd73fc197" contenteditable="true">&#x3C;status-report&#x3E;
  &#x3C;status-change&#x3E;
    &#x3C;billing_id&#x3E;360788&#x3C;/dentaltrac_encounter_id&#x3E;
    &#x3C;claim_ids&#x3E;967382,673647&#x3C;/claim_ids&#x3E;
    &#x3C;status&#x3E;open&#x3C;/status&#x3E;
    &#x3C;time_stamp&#x3E;2019-02-22T13:53:34.605Z&#x3C;/status_time&#x3E;
  &#x3C;/status-change&#x3E;
  &#x3C;status-change&#x3E;
    &#x3C;billing_id&#x3E;360788&#x3C;/dentaltrac_encounter_id&#x3E;
    &#x3C;claim_ids&#x3E;967382,673647&#x3C;/claim_ids&#x3E;
    &#x3C;status&#x3E;open&#x3C;/status&#x3E;
    &#x3C;time_stamp&#x3E;2019-02-22T13:53:34.605Z&#x3C;/status_time&#x3E;
  &#x3C;/status-change&#x3E;
  [...]</div></div><div xmlns:xr="http://www.tekturcms.de/2012/xr/common" xmlns:xlink="http://www.w3.org/1999/xlink" data-attribute-id="22848135-aec4-4770-9e80-b03304ac973cd6e10" class="p pmarker tags" data-element="p" data-tektur-editor-id="1f45d1be-e04a-48ed-a60d-6a9b64e0e1c8" contenteditable="true">Mit einer <span class="bracket-tags-marker" id="452d1c10-99b9-4a75-9d93-a346340e17ab">[[<span class="bracket-tags">code:for-each</span>]]</span> Loop und einem Named-Template würde das so gehen:</div><div class="pre"><div data-attribute-id="4b8730a3-44f0-4723-8e66-409b8e89cae3d7e10" data-attribute-xml_space="preserve" class="pre-content pmarker tags" data-element="pre" data-tektur-editor-id="00672ccc-1ab2-41a2-b047-b86183aedd58" contenteditable="true">
&#x3C;xsl:template name="main"&#x3E;
  &#x3C;xsl:for-each select="$input-file/status-report/status-change"&#x3E;
    &#x3C;xsl:value-of select="concat(billing_id,',')"/&#x3E;
    &#x3C;xsl:value-of select="concat(claim_ids,',')"/&#x3E;
    &#x3C;xsl:value-of select="concat(status,',')"/&#x3E;
    &#x3C;xsl:value-of select="concat(format-dateTime(xs:dateTime(time_stamp),
                                        '[Y]-[M]-[D] [H]:[m]'),'&#x26;#10;')"/&#x3E;
  &#x3C;/xsl:for-each&#x3E;
&#x3C;/xsl:template&#x3E;</div></div><div class="placeholder text pmarker tags" data-element="p" data-tektur-editor-id="63d23d5b-06ae-44dd-b1b0-445ec9103fa1" contenteditable="true"></div><div data-element="note" class="show_menu tags" data-tektur-editor-id="939d1b80-5a48-45c7-acae-38374fd878c6"><div class="gui-optional-elements-button" contenteditable="false"><div class="menu-icon" style="display:none">+</div></div><div class="note"><div class="signal-word">NOTE</div><div class="hcontent"><div xmlns:xr="http://www.tekturcms.de/2012/xr/common" xmlns:xlink="http://www.w3.org/1999/xlink" data-attribute-id="73c07d96-20b6-4482-96ce-258d1673e1a7d6e15" class="p pmarker tags" data-element="p" data-tektur-editor-id="18073e17-48f5-4108-bc42-a1c682c1d56a" contenteditable="true">Named-Templates, die direkt über den Saxon Aufruf <span class="bracket-tags-marker" id="14a70426-6feb-4d9c-98b5-a263536e1aee">[[<span class="bracket-tags">code:saxon -it:main</span>]]</span> aufgerufen werden, sind dann
brauchbar, wenn keine eindeutige Eingabequelle vorhanden ist, bspw. weil aus mehreren
Quellen eingelesen werden soll, wenn die Eingabe von einem Webservice kommt oder 
vom XSLT Skript selbst erzeugt wird.</div></div></div></div><div xmlns:xr="http://www.tekturcms.de/2012/xr/common" xmlns:xlink="http://www.w3.org/1999/xlink" data-attribute-id="d769fa8b-5761-43cf-88ab-842d569d1e7dd6e17" class="p pmarker tags" data-element="p" data-tektur-editor-id="887beca3-95a5-427b-a090-06119da0665b" contenteditable="true">Im vorliegenden Fall wird von einer Datei eingelesen - wir brauchen also kein Named-Template. Statt der <span class="bracket-tags-marker" id="39a3e3aa-ddf2-4ee5-958b-eab22b227ea0">[[<span class="bracket-tags">code_for-each</span>]]</span> Schleife können wir uns auch auf den rekursiven Abstieg des XSLT Prozessors
verlassen, was den Code weiter vereinfacht:</div><div class="pre"><div data-attribute-id="55e14bef-45f4-43aa-896d-bce9fd31f689d7e17" data-attribute-xml_space="preserve" class="pre-content pmarker tags" data-element="pre" data-tektur-editor-id="901cba2c-2e0d-405b-82bb-fdea03f1e097" contenteditable="true">
&#x3C;xsl:template match="/status-report/status-change"&#x3E;
  &#x3C;xsl:value-of select="concat(billing_id,',')"/&#x3E;
  &#x3C;xsl:value-of select="concat(claim_ids,',')"/&#x3E;
  &#x3C;xsl:value-of select="concat(status,',')"/&#x3E;
  &#x3C;xsl:value-of select="concat(format-dateTime(xs:dateTime(time_stamp),
                                      '[Y]-[M]-[D] [H]:[m]'),'&#x26;#10;')"/&#x3E;
&#x3C;/xsl:template&#x3E;</div></div><div xmlns:xr="http://www.tekturcms.de/2012/xr/common" xmlns:xlink="http://www.w3.org/1999/xlink" data-attribute-id="1babc673-5450-4c9f-94d7-02027e879a51d6e21" class="p pmarker tags" data-element="p" data-tektur-editor-id="3543beb8-2963-4f0a-a5a4-6a1fc98bfa87" contenteditable="true">Wollen wir große Datenmengen schnell verarbeiten mit ein paar Hundert MB, so ist es sinnvoll
auf die neue XSLT3.0 Streaming Option umzuschalten, weil dadurch kein Eingabebaunm in-Memory
aufgebaut wird. Wie schon im Kapitel <span class="link tags" data-element="link" data-tektur-editor-id="9573967e-809c-4d86-8bf1-0381ac6e2b5d" href="51bec5b9-1207-45cc-9bf2-b6ce3e300547" data-type="topic">XSLT Akkumulator</span> angesprochen, gibt es dazu mehrere Möglichkeiten.</div><div xmlns:xr="http://www.tekturcms.de/2012/xr/common" xmlns:xlink="http://www.w3.org/1999/xlink" data-attribute-id="24530e61-5662-4972-844c-140ea8d8dc0dd6e23" class="p pmarker tags" data-element="p" data-tektur-editor-id="bb69ef1d-f5e3-4eae-ba08-f448d2b5cc6b" contenteditable="true">Wir betrachten hier das <span class="bracket-tags-marker" id="b504aa95-0cef-409d-87f7-b34811fc9299">[[<span class="bracket-tags">code:xsl:iterator</span>]]</span><span class="bracket-tags-marker" id="67294bf1-4912-4aaf-9d24-35669eca05ae">[[<span class="bracket-tags">link</span>]]</span>(Doku)<span class="bracket-tags-marker" id="3a2c355b-f1f0-4770-9a1b-c51012d69b71">[[<span class="bracket-tags">fn:https://www.saxonica.com/html/documentation/xsl-elements/iterate.html*Der Iterator ist ein Konzept um XSLT Streaming zu realisieren</span>]]</span>
 Konstrukt und stossen dabei auf einige Fallstricke. Zunächst einmal unsere Settings:</div><ul data-attribute-id="4a98621c-143a-4c7b-9943-ff38c9887bc5d6e25" class="ul tags" data-element="ul" data-tektur-editor-id="fc50c4c0-e7a1-42b7-980b-5c72e0dbedb7"><li data-attribute-id="fbfa58c7-8873-4589-8458-2cee8344e3b9d6e26" class="li tags" data-element="li" data-tektur-editor-id="dbf6dd98-71b9-4df4-90a4-6e3119caadf2"><div xmlns:xr="http://www.tekturcms.de/2012/xr/common" xmlns:xlink="http://www.w3.org/1999/xlink" data-attribute-id="d51bf51d-3d8e-4665-9991-84f7d01f7aefd6e27" class="p pmarker tags" data-element="p" data-tektur-editor-id="90107959-0c42-4aae-b84a-d264fa1e36d6" contenteditable="true">Wir benutzen <span class="bracket-tags-marker" id="19c0e84f-8698-4ae2-a4c9-f8a777ba1bcb">[[<span class="bracket-tags">code:xsl:source-document</span>]]</span> in Verbindung mit dem <span class="bracket-tags-marker" id="a4881ca3-ccc6-4ca4-b8b4-e7e728c3ac64">[[<span class="bracket-tags">code:streamable='yes'</span>]]</span> Attribut,
um dem Prozessor mitzuteilen, dass er im Streaming Modus arbeiten soll.</div></li><li data-attribute-id="658c209b-2f3a-4dde-9fc2-6b996f8ae4b5d6e29" class="li tags" data-element="li" data-tektur-editor-id="3e517306-8697-4d9c-907f-f861e5ca5a2d"><div xmlns:xr="http://www.tekturcms.de/2012/xr/common" xmlns:xlink="http://www.w3.org/1999/xlink" data-attribute-id="edab82eb-21c5-45c3-b543-4c0ac06ad281d6e30" class="p pmarker tags" data-element="p" data-tektur-editor-id="01a01eca-1477-4967-a81e-64df50bbd899" contenteditable="true">Wenn wir die Quelle über einen Parameter einlesen, dann müssen wir auch die Transformation über ein Named-Template
starten.</div></li></ul><div xmlns:xr="http://www.tekturcms.de/2012/xr/common" xmlns:xlink="http://www.w3.org/1999/xlink" data-attribute-id="0d5b49f3-2dfb-475c-b317-d76e9aac06a0d6e33" class="p pmarker tags" data-element="p" data-tektur-editor-id="e9b93afe-d146-424b-bdce-b8afad611179" contenteditable="true">Ohne zu wissen, wie XSLT Streaming genau funktioniert, setzen wir eine Reihe von <span class="bracket-tags-marker" id="41ae3d9f-696b-4969-bfe7-a0892b991fa5">[[<span class="bracket-tags">code:value-of select</span>]]</span> statements in den Iterator:</div><div class="pre"><div data-attribute-id="95b3d8f3-78b0-42d2-8df9-c6a6b47dd47dd7e36" data-attribute-xml_space="preserve" class="pre-content pmarker tags" data-element="pre" data-tektur-editor-id="658ad81a-1029-4f60-98bd-d6fad9011b3e" contenteditable="true">
&#x3C;xsl:template name="main"&#x3E;
  &#x3C;xsl:source-document href="{$input-file}" streamable='yes'&#x3E;
    &#x3C;xsl:iterate select="status-report/status-change"&#x3E;
      &#x3C;xsl:value-of select="concat(billing_id,',')"/&#x3E;
      &#x3C;xsl:value-of select="concat(claim_ids,',')"/&#x3E;
      &#x3C;xsl:value-of select="concat(status,',')"/&#x3E;
      &#x3C;xsl:value-of select="concat(format-dateTime(xs:dateTime(time_stamp),
                                          '[Y]-[M]-[D] [H]:[m]'),'&#x26;#10;')"/&#x3E;
    &#x3C;/xsl:iterate&#x3E;
  &#x3C;/xsl:source-document&#x3E; 
&#x3C;/xsl:template&#x3E;</div></div><div xmlns:xr="http://www.tekturcms.de/2012/xr/common" xmlns:xlink="http://www.w3.org/1999/xlink" data-attribute-id="63c6b0e7-5dbc-499b-87d1-a8f566085023d6e37" class="p pmarker tags" data-element="p" data-tektur-editor-id="a809c324-7e0d-435b-9607-eec0b022422d" contenteditable="true">und werden dafür prompt mit einer Fehlermeldung belohnt:</div><div class="pre"><div data-attribute-id="8141a050-1a33-455f-998b-de5745cbac39d7e40" data-attribute-xml_space="preserve" class="pre-content pmarker tags" data-element="pre" data-tektur-editor-id="94c5937b-e72f-42b2-a391-0b32bf384941" contenteditable="true">Static error on line 16 column 64 of report.xsl:
  XTSE3430: The body of the xsl:stream instruction is not streamable
  *  There is more than one consuming operand: {xsl:value-of} on line 18, and
  {xsl:value-of} on line 19</div></div><div xmlns:xr="http://www.tekturcms.de/2012/xr/common" xmlns:xlink="http://www.w3.org/1999/xlink" data-attribute-id="ed797bc5-78cf-4d81-8f07-25d049bb3e78d6e41" class="p pmarker tags" data-element="p" data-tektur-editor-id="130abfb4-79c9-4c8a-af03-f982399c33a7" contenteditable="true">In diesem Iterator ist also nur eine "konsumierende" <span class="bracket-tags-marker" id="604ed239-9bca-4b1b-9f9b-0f096147f62e">[[<span class="bracket-tags">code:value-of</span>]]</span> Operation erlaubt. Um nur einmal zu selektieren, müssen wir - auf Kosten der Lesbarkeit - ziemlich umbauen. Eine Lösung könnte z.B. so aussehen:</div><div class="pre"><div data-attribute-id="eb45a7e1-8b77-423e-96f8-5163d47f1e5ad7e44" data-attribute-xml_space="preserve" class="pre-content pmarker tags" data-element="pre" data-tektur-editor-id="ea26a6db-07e5-4a53-b205-0d014f9f6424" contenteditable="true">&#x3C;?xml version="1.0" encoding="UTF-8"?&#x3E;
&#x3C;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  exclude-result-prefixes="xs"
  xpath-default-namespace="https://tekturcms.de/schema/status-report/1.0"
  version="3.0"&#x3E;
   
  &#x3C;xsl:param name="input-file" required="yes"/&#x3E;
  
  &#x3C;xsl:output method="text"/&#x3E;
 
  &#x3C;!-- https://www.saxonica.com/html/documentation/xsl-elements/iterate.html --&#x3E;

  &#x3C;xsl:template name="main"&#x3E;
    &#x3C;xsl:source-document href="{$input-file}" streamable='yes'&#x3E;
      &#x3C;xsl:iterate select="status-report/status-change/*"&#x3E;
        &#x3C;xsl:choose&#x3E;
          &#x3C;xsl:when test="name()='time_stamp'"&#x3E;
            &#x3C;xsl:value-of select="concat(format-dateTime(xs:dateTime(time_stamp),
                                               '[Y]-[M]-[D] [H]:[m]'),'&#x26;#10;')"/&#x3E;
          &#x3C;/xsl:when&#x3E;
          &#x3C;xsl:otherwise&#x3E;
            &#x3C;xsl:value-of select="concat(.,',')"/&#x3E;
          &#x3C;/xsl:otherwise&#x3E;
        &#x3C;/xsl:choose&#x3E;
      &#x3C;/xsl:iterate&#x3E;
    &#x3C;/xsl:source-document&#x3E;
  &#x3C;/xsl:template&#x3E;  
&#x3C;/xsl:stylesheet&#x3E;
</div></div><div xmlns:xr="http://www.tekturcms.de/2012/xr/common" xmlns:xlink="http://www.w3.org/1999/xlink" data-attribute-id="469ff8e1-b60e-47fa-906b-f0ba5ffcbe0ed6e48" class="p pmarker tags" data-element="p" data-tektur-editor-id="00a48856-d266-44b0-bd38-e8550ed9c492" contenteditable="true">Hier wird davon ausgegangen, dass das Element mit Namen 'time_stamp' als letztes in der Sequenz vorkommt und beim Auftreten (<span class="bracket-tags-marker" id="5516a66d-39d8-4242-9fdc-18febb0d51f6">[[<span class="bracket-tags">code:&#x26;#10;</span>]]</span>) wird ein Zeilenumbruch gesetzt. Der deklarative Ansatz aus dem ersten Beispiel geht dabei verloren. </div><div data-element="note" class="show_menu tags" data-tektur-editor-id="752149bb-e144-4d7b-86df-87221301f183"><div class="gui-optional-elements-button" contenteditable="false"><div class="menu-icon" style="display:none">+</div></div><div class="note"><div class="signal-word">NOTE</div><div class="hcontent"><div xmlns:xr="http://www.tekturcms.de/2012/xr/common" xmlns:xlink="http://www.w3.org/1999/xlink" data-attribute-id="b7628b73-64d2-4adb-9e79-b0c0e27ea202d6e51" class="p pmarker tags" data-element="p" data-tektur-editor-id="452d9d3f-a8cd-49d2-859f-3045189c777e" contenteditable="true">Logisch wird beim XSLT Streaming auf einer niedrigeren Abstraktionsebene programmiert, um den Anforderungen des Prozessors gerecht zu werden.</div></div></div></div><div xmlns:xr="http://www.tekturcms.de/2012/xr/common" xmlns:xlink="http://www.w3.org/1999/xlink" data-attribute-id="25b7064f-3652-4cf9-96d9-de474327f073d6e53" class="p pmarker tags" data-element="p" data-tektur-editor-id="3abfa3ac-4505-4196-929f-cfb187fb9971" contenteditable="true">Für eine <span data-attribute-id="61cd3405-cf36-4bc0-a923-4074c1eb8973d6e55" class="b tags" data-element="b" data-tektur-editor-id="480787b9-1ba5-41b0-a8b4-aa94ed501839">1.6 GB Datei</span> benötigt das obige Skript auf meinem Rechner gute<span data-attribute-id="90b6c3a0-5c88-4ee6-a51d-e9d6bd76df56d6e58" class="b tags" data-element="b" data-tektur-editor-id="494b12d2-7e64-4846-ab0a-9c8fc2b7a015"> drei Minuten</span>. Der traditionelle temlate-match Ansatz bricht mit einer Out-of-Memory Exception ab, selbst wenn man den Java Heap Size auf 4GB einstellt.</div></div></div></div>