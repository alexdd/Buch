<?xml version="1.0" encoding="UTF-8"?><elements><element id="8a54eb22-afbb-4741-b3e5-8088e75c9ebd">XSLT Iterator </element><element id="9b154448-31c9-495f-bc85-ecb297deece8">XSLT Streaming ist ziemlich tricky. Betrachten wir ein einfaches Problem. Es soll ein kommaseparierter Report aus folgender XML Quelle generiert werden.</element><element id="22848135-aec4-4770-9e80-b03304ac973cd6e10">Mit einer  Loop und einem Named-Template würde das so gehen:</element><element id="73c07d96-20b6-4482-96ce-258d1673e1a7d6e15">Named-Templates, die direkt über den Saxon Aufruf  aufgerufen werden, sind dann\nbrauchbar, wenn keine eindeutige Eingabequelle vorhanden ist, bspw. weil aus mehreren\nQuellen eingelesen werden soll, wenn die Eingabe von einem Webservice kommt oder \nvom XSLT Skript selbst erzeugt wird.</element><element id="d769fa8b-5761-43cf-88ab-842d569d1e7dd6e17">Im vorliegenden Fall wird von einer Datei eingelesen - wir brauchen also kein Named-Template. Statt der  Schleife können wir uns auch auf den rekursiven Abstieg des XSLT Prozessors\nverlassen, was den Code weiter vereinfacht:</element><element id="1babc673-5450-4c9f-94d7-02027e879a51d6e21">Wollen wir große Datenmengen schnell verarbeiten mit ein paar Hundert MB, so ist es sinnvoll\nauf die neue XSLT3.0 Streaming Option umzuschalten, weil dadurch kein Eingabebaunm in-Memory\naufgebaut wird. Wie schon im Kapitel XSLT Akkumulator (imported) angesprochen, gibt es dazu mehrere Möglichkeiten.</element><element id="24530e61-5662-4972-844c-140ea8d8dc0dd6e23">Wir betrachten hier das (Doku)\n Konstrukt und stossen dabei auf einige Fallstricke. Zunächst einmal unsere Settings:</element><element id="d51bf51d-3d8e-4665-9991-84f7d01f7aefd6e27">Wir benutzen  in Verbindung mit dem  Attribut,\num dem Prozessor mitzuteilen, dass er im Streaming Modus arbeiten soll.</element><element id="edab82eb-21c5-45c3-b543-4c0ac06ad281d6e30">Wenn wir die Quelle über einen Parameter einlesen, dann müssen wir auch die Transformation über ein Named-Template\nstarten.</element><element id="0d5b49f3-2dfb-475c-b317-d76e9aac06a0d6e33">Ohne zu wissen, wie XSLT Streaming genau funktioniert, setzen wir eine Reihe von  statements in den Iterator:</element><element id="63c6b0e7-5dbc-499b-87d1-a8f566085023d6e37">und werden dafür prompt mit einer Fehlermeldung belohnt:</element><element id="ed797bc5-78cf-4d81-8f07-25d049bb3e78d6e41">In diesem Iterator ist also nur eine \"konsumierende\"  Operation erlaubt. Um nur einmal zu selektieren, müssen wir - auf Kosten der Lesbarkeit - ziemlich umbauen. Eine Lösung könnte z.B. so aussehen:</element><element id="469ff8e1-b60e-47fa-906b-f0ba5ffcbe0ed6e48">Hier wird davon ausgegangen, dass das Element mit Namen 'time_stamp' als letztes in der Sequenz vorkommt und beim Auftreten () wird ein Zeilenumbruch gesetzt. Der deklarative Ansatz aus dem ersten Beispiel geht dabei verloren. </element><element id="b7628b73-64d2-4adb-9e79-b0c0e27ea202d6e51">Logisch wird beim XSLT Streaming auf einer niedrigeren Abstraktionsebene programmiert, um den Anforderungen des Prozessors gerecht zu werden.</element><element id="25b7064f-3652-4cf9-96d9-de474327f073d6e53">Für eine 1.6 GB Datei benötigt das obige Skript auf meinem Rechner gute drei Minuten. Der traditionelle temlate-match Ansatz bricht mit einer Out-of-Memory Exception ab, selbst wenn man den Java Heap Size auf 4GB einstellt.</element></elements>