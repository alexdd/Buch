<?xml version="1.0" encoding="UTF-8"?><elements><element id="743f34bc-c83e-49d3-9a2e-2c38d1c384c9">Namespaces </element><element id="6f3e2556-a8a9-4c91-bf51-cc4b05ba29c9">Wenn man XML Instanzen aus unterschiedlichen Quellen mit XSLT verarbeiten will, wird man sich wohl\noder übel mit dem Thema Namespaces auseinander setzen müssen, um Konflikte in den \nElementselektoren zu vermeiden.</element><element id="408f70f7-e541-4c17-bc75-16db61b71e87d6e6">Gerade bei hintereinandergeschalteten Transformationen kann es auch passieren, \ndass unerwartet ein Namespace in die Ausgabe generiert wird,\nden der folgende Prozesschritt nicht versteht, weil er dort nicht deklariert wurde.</element><element id="7b6e758e-d962-425a-86cf-30fc852bda81d6e8">Es gibt meherere Möglichkeiten einen Namespace im Stylesheet zu deklarieren. Gehen wir davon aus,\ndass in einem Transformationsschritt genau eine Quelle und max. eine Konfigurationsdatei verarbeitet \nwird, dann kann das Stylsheet-Element bspw. so aussehen:</element><element id="3bc26fb9-3d57-4990-9cb6-bdeea4a490d5d6e14">Der Namespace ist klar</element><element id="9f37a0f6-0e32-4d52-a2df-26c8b92c584bd6e20">Der Namespace ist notwendig, wenn man typisiert arbeiten will. Er erlaubt das Einbinden von Datentypen\nnach der XML Schema Spezifikation und somit die \nbessere Validierung des Stylesheets zur Compile-Zeit.</element><element id="effc0d73-d115-4f50-99c0-bd16960d52f6d6e26">Die Deklaration eines eigenen geprefixten Namespaces erlaubt das Einbinden von eigenen XSLT Funktionen, \nwie z.B. auch das Einbinden der FunctX Bibliothek</element><element id="985f02e1-ff86-49cd-9f9c-d285261fb6bed6e29">Der Nicht-geprefixte Namespace ist der Default-Namespace und kann einen Namespace aus der Eingabe behandeln</element><element id="6f7d075e-efb2-4407-adb3-6b0d46163a1ed6e32">Das Attribut xpath-default-namespace gibt einen weiteren Namespace an, der in XPath Funktionen verwendet werden kann.\nIn diesem Feld würde ich den Namespace einer Konfigurations- oder separaten Datendatei angeben.</element><element id="facda359-d33a-4d29-86cd-1c8ed0c0c37bd6e37">Mehr als einen Namespace in der Eingabe sollte man aus meiner Sicht bei der XML Verarbeitung mit XSLT vermeiden wenn es geht.\nGgf. empfiehlt es sich, die Eingabe vor der Verarbeitung zu normalisieren und Elemente ggf. umzubenennen. Ansonsten kann man auch eigene Namespace-Prefixes deklarieren, wie z.B.:</element><element id="11bfa628-dd5a-46ee-9dfa-99ea9733ed73d6e41">und diese in XPath Selektionen und Match-Regeln verwenden.</element><element id="b714b258-69e2-40ef-9d70-582d27bbfc6cd6e45">Namespaces in der Eingabe werden also meistens über die Kopfdeklaration in der Stylesheetdatei gehandelt, welcher Namespace\nschliesslich in die Ausgabe geschrieben wird, hängt vom aktuell verarbeiteten Kontextknoten ab:</element><element id="93df2752-2e39-44f2-8306-bc4014ec566ad6e49">Elemente, die man erzeugt, erhalten automatisch den Default-Namespace, wenn man nicht explizit einen Namespace angibt.</element><element id="dd1681a1-b730-4864-9fc6-3b85c7d428c2d6e52">Elemente, die man kopiert, transportieren den Namespace, den sie in der Eingabe hatten, wenn man dies nicht explizit verhindert.</element><element id="b7e9f54a-5c0b-48de-abf2-80f917c915acd6e54">Um diese beiden Default Einstellungen zu steuern (bzw. zu überschreiben) gibt es mehrere Möglichkeiten:</element><element id="e38c1750-4914-402d-a6c8-1189f6f96106d6e59">Hier wird ein Element mit dem un-geprefixten Namespace des Kontextknotens deklariert.\nWenn der Kontextknoten keinen anderen Namespace hat, so wird hierdurch sichergestellt,\ndass der Default-Namespace auch tatsächlich in die Ausgabe kommt.</element><element id="ff135156-7c5f-461a-aa39-03acbbfc2164d6e63">Hier wird ein Element mit eigener Namespace Angabe in die Ausgabe geschrieben. Einfacher geschrieben:</element><element id="5803933b-c6bf-431b-9f72-f8649ce4f19fd6e71">Es gibt auch ein Attribut am xsl:copy Element,\ndas den Vorgang des Namespace-Kopierens steuern kann:</element><element id="1f87506c-b5f5-4f11-9ff3-4932938dea95d6e67">Hier wird der Namespace am  Element nicht in die Ausgabe geschrieben. Ggf. funktioniert diese\nFunktion aber mit unerwarteten Ergebnissen, deshalb sollte man sich ohne genauen Test nicht darauf verlassen.</element><element id="526b542d-9aaa-4181-bb81-9990f3f9940bd6e69">Ebenso kann eine Default-Kopierregel verwendet werden, die es verbietet einen Namespace\nweiterzuvererben:</element><element id="ad139a27-9649-4c97-8f05-a62edd570cb7d6e74">Namespaces in XQuery</element><element id="6a862358-2454-4cb0-a7c5-854c9d4cf899d6e75">Während XSLT dazu dienen sollte, XML Daten in andere (XML-) Formate zu transformieren, dient XQuery \nz.B. dazu auf einer NoSQL Datenbank Daten aus unterschiedlichen Quellen\nzu selektieren, zu harmonisieren und an verarbeitende Prozesse weiterzugeben.</element><element id="56fd4141-0088-4fdb-bf10-930e2d5d028ed6e77">Deshalb ist es für mich nicht so erstaunlich, dass das Namespace Konzept in XQuery irgendwie besser\nfunktioniert.</element><element id="baa93854-b02c-41f2-a553-bb6701a8925ed6e79">Damit man überhaupt Daten auf einem mit Namespaces versehenen XML Dokument selektieren\nkann, müssen alle Namspaces am Anfang des XQuery Ausdrucks angegeben werden, das sieht so aus:</element><element id="d6bb0949-b9fa-4770-ba36-3acf2056e934d6e83">Hier werden zuerst Funktionen aus anderen Modulen eingebunden, nämlich die in einer Datei  der eigenen Entwicklung, sowie die Bibliothek  aus der MarkLogic\nUmgebung. Danach wird ein Namespace deklariert, den man verwenden wird, wenn im weiteren Verlauf\neigene XQuery Funktionen verwendet werden sollen, sowie der Namespace , der in den Eingabedaten\nvorhanden ist. Der Namespace ist analog zum XSLT Beispiel gesetzt.</element></elements>