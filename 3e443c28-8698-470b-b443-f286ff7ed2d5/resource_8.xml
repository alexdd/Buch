<?xml version="1.0" encoding="UTF-8"?><topic id="309017d9-9fd7-4a34-b13a-4bf8ecea4556"><title id="743f34bc-c83e-49d3-9a2e-2c38d1c384c9">Namespaces</title><body id="2e9a9f57-c540-4349-b553-b3ff06af8175"><p id="6f3e2556-a8a9-4c91-bf51-cc4b05ba29c9">Wenn man <b id="992886bf-1144-4ee1-9d0e-4a97b3837cc1d7e6">XML</b> Instanzen aus unterschiedlichen Quellen mit <b id="5c353d26-db9b-4397-954f-6033593a011cd7e9">XSLT</b> verarbeiten will, wird man sich wohl
oder übel mit dem Thema <b id="3140305f-b1d7-4a42-8329-46d6b3560260d7e12">Namespaces</b>[[xe1:XML Konstrukte;xe2: Namespaces]] auseinander setzen müssen, um Konflikte in den 
Elementselektoren zu vermeiden.</p><p id="408f70f7-e541-4c17-bc75-16db61b71e87d6e6">Gerade bei hintereinandergeschalteten Transformationen kann es auch passieren, 
dass unerwartet ein <b id="3a2fc9ec-9ab5-41d1-a155-7a78aa7a9f2fd7e17">Namespace</b> in die Ausgabe generiert wird,
den der folgende Prozesschritt nicht versteht, weil er dort nicht deklariert wurde.</p><p id="7b6e758e-d962-425a-86cf-30fc852bda81d6e8">Es gibt meherere Möglichkeiten einen<b id="db61f369-e602-4d5f-9395-a488f34ff5ced7e22"> Namespace</b> im Stylesheet zu deklarieren. Gehen wir davon aus,
dass in einem Transformationsschritt genau eine Quelle und max. eine Konfigurationsdatei verarbeitet 
wird, dann kann das Stylsheet-Element bspw. so aussehen:</p><pre id="e9c9b0c3-36e5-4959-bd44-0ed0e9837258d7e25" xml:space="preserve">&lt;xsl:stylesheet version="2.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xs="http://www.w3.org/2001/XMLSchema" 
  xmlns:tektur="https://namespace-eigener-xslt-funktionen"
  xmlns="http://namespace-in-der-xml-eingabe.com/"
  xpath-default-namespace="https://namespace-der-konfigdatei.com/"
  exclude-result-prefixes="#all"&gt;</pre><ul id="f50cf486-fec3-4aca-a510-4347a0fffe51d6e12"><li id="a71c0a9a-d856-483b-a102-bace566e0c04d6e13"><p id="3bc26fb9-3d57-4990-9cb6-bdeea4a490d5d6e14">Der [[code:xsl]]<b id="acd77c8a-f7f4-497e-a7f9-3fe817a32548d7e31">Namespace</b> ist klar</p></li><li id="b2fa04fc-e0d0-4a22-868d-6de15f9536f0d6e19"><p id="9f37a0f6-0e32-4d52-a2df-26c8b92c584bd6e20">Der [[code:xs]]<b id="6a3e5850-743e-41d8-8c15-87e79ec00c23d7e37">Namespace</b> ist notwendig, wenn man typisiert arbeiten will. Er erlaubt das Einbinden von Datentypen
nach der [[link]]XML Schema Spezifikation[[fn:https://de.wikipedia.org/wiki/XML_Schema*XML Schema ist der Nachfolger der DTD, ist XML basiert und erlaubt auch die die Content-Validierung in einem bestimmten Umfang]] und somit die 
bessere Validierung des Stylesheets zur Compile-Zeit.</p></li><li id="40b70b85-31dd-4109-882f-aa19e8e2b1b8d6e25"><p id="effc0d73-d115-4f50-99c0-bd16960d52f6d6e26">Die Deklaration eines eigenen geprefixten<b id="f556a826-2507-495a-918d-997819f640a5d7e43"> Namespaces</b> erlaubt das Einbinden von eigenen <b id="3e356ffe-646e-4889-a4e2-b9306cfbe0fcd7e46">XSLT </b>Funktionen, 
wie z.B. auch das Einbinden der [[link]]FunctX Bibliothek[[fn:http://www.xsltfunctions.com/*Sehr gut gegliederte Funktionsbibliothek von Priscilla Walmsley]]</p></li><li id="0a804e4e-1e9c-4033-b79e-78fddeb0f809d6e28"><p id="985f02e1-ff86-49cd-9f9c-d285261fb6bed6e29">Der Nicht-geprefixte <b id="92dc70fe-0e18-4172-8451-5ac0895e6f71d7e52">Namespace</b> ist der <b id="6826fb26-31e6-46aa-b6a4-d5d1eb9704f2d7e55">Default-Namespace</b> und kann einen <b id="54de7a52-0361-49ee-9e40-5d470a1fa9bcd7e58">Namespace</b> aus der Eingabe behandeln</p></li><li id="77756675-79a9-49ee-a322-2fe357eb505ad6e31"><p id="6f7d075e-efb2-4407-adb3-6b0d46163a1ed6e32">Das Attribut <b id="4eb02d99-4049-43c5-a105-76f286898d2cd6e34">xpath-default-namespace</b> gibt einen weiteren <b id="27504e73-5b44-482b-95d7-0dd366bed74bd7e67">Namespace</b> an, der in <b id="135ae46b-322a-465e-8e4e-0492d76438cad7e70">XPath</b> Funktionen verwendet werden kann.
In diesem Feld würde ich den <b id="030feec7-dc39-46cc-9cce-fd8c7c53a76cd7e73">Namespace</b> einer Konfigurations- oder separaten Datendatei angeben.</p></li></ul><p id="facda359-d33a-4d29-86cd-1c8ed0c0c37bd6e37">Mehr als einen <b id="02c3ddab-f9c5-4cf8-a4fe-ed15a7d392dbd7e78">Namespace</b> in der Eingabe sollte man aus meiner Sicht bei der <b id="629ea243-7d24-4c69-92d5-18688af20346d7e81">XML</b> Verarbeitung mit <b id="a058bdee-b6bf-421c-8bbb-24187386e96ed7e84">XSLT </b>vermeiden wenn es geht.
Ggf. empfiehlt es sich, die Eingabe vor der Verarbeitung zu normalisieren und Elemente ggf. umzubenennen. Ansonsten kann man auch eigene <b id="f8b303da-fce6-40b8-af8c-6a839b0deb31d7e87">Namespace-Prefixes</b> deklarieren, wie z.B.:</p><pre id="98ba2d9c-f0ba-4251-b70d-fb02d0eec3b9d7e90" xml:space="preserve">xmlns:ext="https://www.tekturcms.de/external-tools"</pre><p id="11bfa628-dd5a-46ee-9dfa-99ea9733ed73d6e41">und diese in <b id="e7608375-41c3-4a36-9687-fcb25dae4986d7e94">XPath</b> Selektionen und Match-Regeln verwenden.</p><hazardstatement id="d4c6a587-757b-4b00-883c-9e5273834a12d6e39" type="danger" status="changed"><messagepanel id="0c74cf84-ebc2-46e8-a9c7-d554381f22ebd7e98"><typeofhazard id="6a0d517a-4a6c-48b2-b637-699ec79f42a7d6e41">Befinden sich in den Eingabedaten <b id="822c5934-770f-4b4e-a8d6-797791f100f3d7e101">Namespaces</b>, die man in den<b id="14e0e4cc-72fc-4b42-92e3-7681c67b3005d7e104"> XSLT Stylesheets</b> nicht handelt - der <b id="0438a340-581f-43a5-b428-61243949d7e5d7e107">Namespace</b> kann auch nur
an einem ganz bestimmten Element hängen - so kann es bei der Transformation - ohne Fehlermeldung - zu unerwarteten Ergebnissen kommen.</typeofhazard><howtoavoid id="4d47e81a-7a6a-4f2e-9621-45a6535edbb2d6e43">Deshalb sollte man die Daten im Vorfeld bzgl. <b id="e7f7d69e-e8ac-49a0-9c75-5ac3a21f22c1d7e112">Namespaces</b> sehr genau analysieren.</howtoavoid></messagepanel></hazardstatement><p id="b714b258-69e2-40ef-9d70-582d27bbfc6cd6e45"><b id="e06f2c3d-bdbd-4179-a2ef-3f76b15076c1d7e116">Namespaces</b> in der Eingabe werden also meistens über die Kopfdeklaration in der Stylesheetdatei gehandelt, welcher <b id="b6af897d-1e81-4192-b449-d09a212b6684d7e119">Namespace</b>
schliesslich in die Ausgabe geschrieben wird, hängt vom aktuell verarbeiteten Kontextknoten ab:</p><ul id="4fd51183-cb5c-454e-88a2-af0392a44343d6e47"><li id="83a93052-ddd0-4ca8-a440-e11cae99f4e2d6e48"><p id="93df2752-2e39-44f2-8306-bc4014ec566ad6e49">Elemente, die man erzeugt, erhalten automatisch den <b id="f8916657-3ceb-4a57-82ed-61a2cb286b91d7e126">Default-Namespace</b>, wenn man nicht explizit einen <b id="236ad352-5eb2-4a04-bb6b-be5dbb0414ead7e129">Namespace</b> angibt.</p></li><li id="35a0b8ce-4224-4958-8bb7-9e65ce516d68d6e51"><p id="dd1681a1-b730-4864-9fc6-3b85c7d428c2d6e52">Elemente, die man kopiert, transportieren den <b id="fbcfc0a4-6c07-4ab7-8bdc-5fdbf29818e4d7e135">Namespace</b>, den sie in der Eingabe hatten, wenn man dies nicht explizit verhindert.</p></li></ul><p id="b7e9f54a-5c0b-48de-abf2-80f917c915acd6e54">Um diese beiden Default Einstellungen zu steuern (bzw. zu überschreiben) gibt es mehrere Möglichkeiten:</p><pre id="a86a50c8-e59a-452f-9b16-857e50aedbbcd7e141" xml:space="preserve">&lt;xsl:element name="{local-name()}" namespace="{namespace-uri()}"&gt;</pre><p id="e38c1750-4914-402d-a6c8-1189f6f96106d6e59">Hier wird ein Element mit dem un-geprefixten <b id="c578b901-0c6a-4a9b-9a6d-1938845ed192d7e145">Namespace</b> des Kontextknotens deklariert.
Wenn der Kontextknoten keinen anderen <b id="c77648ff-7c4c-4d72-8035-e0a2d0d2efddd7e148">Namespace</b> hat, so wird hierdurch sichergestellt,
dass der <b id="debc3e14-95db-4fe7-8ad9-936fd4db6014d7e151">Default-Namespace </b>auch tatsächlich in die Ausgabe kommt.</p><pre id="110cf3b2-5ef0-48de-8538-2f8ff358005ad7e154" xml:space="preserve">&lt;xsl:element name="meinelement" namespace="mein-namespace"&gt;</pre><p id="ff135156-7c5f-461a-aa39-03acbbfc2164d6e63">Hier wird ein Element mit eigener<b id="ac548523-f50c-4b7e-ac31-055fb93135a4d7e158"> Namespace</b> Angabe in die Ausgabe geschrieben. Einfacher geschrieben:</p><pre id="10c941d5-b3fb-4dee-b05f-bcb540c4f441d7e161" xml:space="preserve">&lt;mein-element xmlns="mein-namespace"&gt;</pre><p id="5803933b-c6bf-431b-9f72-f8649ce4f19fd6e71">Es gibt auch ein Attribut am xsl:copy Element,
das den Vorgang des <b id="228c9b8f-06fa-4929-bd39-8ca6f72f174fd7e165">Namespace</b>-Kopierens steuern kann:</p><pre id="51f3a876-6ceb-4213-a6c4-e93eed319227d7e168" xml:space="preserve">&lt;xsl:template match="p"&gt;
  &lt;xsl:copy copy-namespaces="no"&gt;
     &lt;xsl:apply-templates/&gt;
   &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;</pre><p id="1f87506c-b5f5-4f11-9ff3-4932938dea95d6e67">Hier wird der <b id="b6351d79-ced0-40d4-9ea0-5e39221243cdd7e172">Namespace</b> am [[code:p]] Element nicht in die Ausgabe geschrieben. Ggf. funktioniert diese
Funktion aber mit unerwarteten Ergebnissen, deshalb sollte man sich ohne genauen Test nicht darauf verlassen.</p><p id="526b542d-9aaa-4181-bb81-9990f3f9940bd6e69">Ebenso kann eine Default-Kopierregel verwendet werden, die es verbietet einen <b id="aa0bee27-ac18-48d4-9464-279c92dee06ed7e177">Namespace</b>
weiterzuvererben:</p><pre id="c570e640-e9bb-4317-a342-edf5740bd761d7e180" xml:space="preserve">&lt;xsl:template match="@* | node()"&gt;
   &lt;xsl:copy inherit-namespaces="no"&gt;
     &lt;xsl:apply-templates select="@* | node()"/&gt;
   &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;</pre><section id="9505cba2-6db8-43f3-b2a4-cfde3c294f4fd7e183"><title id="ad139a27-9649-4c97-8f05-a62edd570cb7d6e74">Namespaces in XQuery</title><p id="6a862358-2454-4cb0-a7c5-854c9d4cf899d6e75">Während <b id="f5fa3336-8ddc-49d4-bdbc-d3c3162922fad7e188">XSLT </b>dazu dienen sollte, <b id="ca173b67-42fc-4d72-a399-4368bcbd80d5d7e191">XML</b> Daten in andere (<b id="90a6e332-4033-4590-9fe4-41b1e57a782dd7e194">XML</b>-) Formate zu transformieren, dient <b id="38377353-3c2e-4ec1-b51f-b3ab7bdea637d7e197">XQuery</b> 
z.B. dazu auf einer <b id="444bc708-61da-4b72-a757-3e25f37f5729d7e200">NoSQL</b> Datenbank Daten aus unterschiedlichen Quellen
zu selektieren, zu harmonisieren und an verarbeitende Prozesse weiterzugeben.</p><p id="56fd4141-0088-4fdb-bf10-930e2d5d028ed6e77">Deshalb ist es für mich nicht so erstaunlich, dass das <b id="30989079-0af7-4b9f-8fdb-43e212ed0a1ed7e205">Namespace</b> Konzept in XQuery irgendwie besser
funktioniert.</p><p id="baa93854-b02c-41f2-a553-bb6701a8925ed6e79">Damit man überhaupt Daten auf einem mit <b id="56e42f18-bffb-4318-93e9-54e543bc7b63d7e210">Namespaces</b> versehenen <b id="e33d4b09-3d83-4495-a4c3-fb1d0b44a82cd7e213">XML</b> Dokument selektieren
kann, müssen alle <b id="8d6cf8fc-9dd1-4509-a315-0b8ee9a5ca9fd7e216">Namspaces</b> am Anfang des <b id="4a31bf02-b430-46e9-b4a3-05f591dc6c71d7e219">XQuery</b> Ausdrucks angegeben werden, das sieht so aus:</p><pre id="245927e1-d755-40ad-8efa-dfd695d3b0a9d7e222" xml:space="preserve">xquery version "1.0-ml";

import module namespace tektur = "http://www.teturcms.de/xquery/common" 
                                  at "common.xqy";
import module namespace mem = "http://xqdev.com/in-mem-update" 
                                  at '/MarkLogic/appservices/utils/in-mem-update.xqy';
declare namespace local = "https://lambdawerk.com/code/alex-sandbox/1.0";
declare namespace weiredns = "https://weired-ns-in-input-data.com/weired/ns";
declare namespace xs = "http://www.w3.org/2001/XMLSchema"; </pre><p id="d6bb0949-b9fa-4770-ba36-3acf2056e934d6e83">Hier werden zuerst Funktionen aus anderen Modulen eingebunden, nämlich die in einer Datei [[code:common.xqy]] der eigenen Entwicklung, sowie die Bibliothek [[code:mem]] aus der<b id="fc59fe90-8635-452b-bc60-30a7025d884ad7e226"> MarkLogic</b>
Umgebung. Danach wird ein <b id="db0dfe66-3c50-43d9-ae0b-d3aa157c0df6d7e229">Namespace</b>[[code:local]] deklariert, den man verwenden wird, wenn im weiteren Verlauf
eigene <b id="bcfd8fe7-374d-44f0-80f8-8ea89c310774d7e232">XQuery</b> Funktionen verwendet werden sollen, sowie der Namespace [[code:weiredns]], der in den Eingabedaten
vorhanden ist. Der<b id="77b012fd-e88a-4b13-a447-bb7d7071290cd7e235"> Namespace</b>[[code:xs]] ist analog zum <b id="826070ff-6cd0-4f25-a8ab-ae99ef0c78fbd7e238">XSLT</b> Beispiel gesetzt.</p></section></body></topic>