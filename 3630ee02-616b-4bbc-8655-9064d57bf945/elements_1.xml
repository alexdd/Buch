<?xml version="1.0" encoding="UTF-8"?><elements><element id="9c13d213-40d3-4e74-b343-23cc42779c6d" type="para">Funktionen und Module</element><element id="2b09a4f1-af09-482e-b220-bbaa5e4f0897d6e5" type="para">Funktionen</element><element id="5de561e1-87c3-4f46-b36e-c5db56d9ae27d6e7" type="para">Um bestimmte Abschnitte des XQuery Programm wiederverwendbar zu machen, stehen Funktionsdeklarationenzur verfügung. Eine einfache Funktion wäre z.B. diese hier:</element><element id="f1bf0952-8175-4310-9aae-6c5d763910a8d7e9" type="code">declare function local:wrap-header($json) { xdmp:add-response-header(\"Pragma\",\"no-cache\"), xdmp:add-response-header(\"Cache-Control\",\"no-cache\"), xdmp:add-response-header(\"Expires\",\"0\"), xdmp:set-response-content-type('text\/json; charset=utf-8'), $json };</element><element id="285caf33-98eb-4945-acad-961bc509ce0cd6e11" type="para">Sie wickelt um einen JSON String eine passende Header Information.</element><element id="df24cc6b-17ff-486d-827c-9cec00d4a33bd6e13" type="para">Damit die Funktion eingebunden werden kann, muss ein passender Namespacedeklariert werden:</element><element id="d29b2e24-bd48-4d0c-9336-752835e39856d7e15" type="code">declare namespace local = 'local:';</element><element id="bc7c92a6-2eae-47e2-973b-904415f3fc0ed6e17" type="para">Nicht nur bzgl. Wiederverwendbarkeit sind Funktionen praktisch, sondern auch um ganz elementare Konstrukte, wieSchleifen, zu realisieren.</element><element id="6ec7b350-f2e7-4922-9e96-9c12fd07957ad6e19" type="para">Dazu nutzt man, wie in der funktionalen Programmierung üblich, die Rekursion:</element><element id="38f7a47c-c1f5-4138-bab3-fa1ffc895cfbd7e21" type="code">declare function local:ist-letzter-wert-in-kette($glied) { let $wert := local:komplizierte-berechnung($glied), $naechstes-glied := local:komplizierte-berechnung-der-position($glied), return if ($naechstes-glied and not($wert = 'foobar')) then local:durchlaufe-kette($naechstes-glied) else $wert = 'foobar' };</element><element id="844b5256-5000-436c-bca3-c8f1c31f3ffed6e23" type="para">In diesem kleinen Schnippsel sind schon einige Besonderheiten von XQuery zu sehen. Variablenzuweisungen geschehen mit einem Doppelpunkt, Vergleiche dagegen nur mit einem einfachen\"=\". Statements werden mit einem Komma getrennt.</element><element id="dab65cd2-0eb9-4487-99e0-07422d3c3759d6e26" type="para">Module</element><element id="2cc3effd-16fe-42c0-9fbd-bfa92cb6d10bd6e28" type="para">Um eine XQuery Anwendung zu modularisieren, können einzelne Skripte in Module ausgelagert werden. Ein Modul, z.B. common.xqy, wird dabei über einen eigenen Namespace deklariert:</element><element id="b92f58fa-51f9-4d24-b674-81490a351421d7e30" type="code">module namespace common =\"https:\/\/www.tekturcms.de\/common\";</element><element id="86f1276d-3550-4da6-887d-58012231ea7cd6e32" type="para">Dieses Modul kann dann in anderen Skripten eingebunden werden:</element><element id="c2e62284-2755-49ec-902b-b00177491b63d7e34" type="code">import module namespace common =\"https:\/\/www.tekturcms.de\/common\"at\"common.xqy\";</element><element id="d3d6ab20-364a-45c0-b0fa-e2e4578331bcd6e36" type="para">Funktionen und Variablen werden dann mir dem Namespacegeprefixt aufgerufen:</element><element id="725f02a0-c775-44c5-919f-04adc078f51bd7e38" type="code">Funktionsaufruf: common:wrap-response-header(...) Variablenauswertung: $common:collection-books</element></elements>