<?xml version="1.0" encoding="UTF-8"?><elements><element id="fbbe8267-ed7b-4b78-b547-d00fe41f0b5c" type="para">Webservice Calls mit und </element><element id="cfd5bdf8-a043-405f-a3f7-1feb395fbd3d" type="para">Eine verbreitete Paxis ist es, mit der Funktion oder kurz entfernte Ressourcen in die Transformation einzubinden. Bei einer Schematron-Validierung, würde bspw. eine Regel, wie:</element><element id="bc38c9e1-5f74-4113-a8c6-cbd55adca1c8d7e6" type="code">&lt;sch:not-assert id=\"personal-check\" role=\"error\" test=\"doc(concat('https:\/\/tekturcms.de\/personal.xqy?personal-id=',personal-id))\/kuendigung\"&gt; Angestellter mit ID \"&lt;sch:value-of select=\"personal-id\"\/&gt;\" hat gekündigt! &lt;\/sch:not-assert&gt;</element><element id="9fc3fa46-8e19-4c2b-90cf-0f2a76ef18eed6e8" type="para">einen entferneten Webservice aufrufen und prüfen, ob für den Angestellten mit eine Kündigung vorliegt. Ist dies der Fall, so ist die negative Zusicherung nicht erfüllt und die Schematron Regel feuert - was sich wohl im einfachsten Fall in einem Logfile Eintrag äussern sollte.</element><element id="e3b1a6ca-7163-4c64-a69d-a1f4277847d5d6e10" type="para">Was vermutlich viele noch nicht kennen - ich nehme jetzt einfach mal an, dass mein bisheriger Kenntnisstand dem der Mehrheit der XML-Entwickler entspricht - ist der Umstand, dass auch die Funktion eine URL als Parameter nimmt:</element><element id="1900cede-f29a-43fc-a6c9-ed69ce6b966ad7e12" type="code">&lt;xsl:template match=\"angestellter\" &lt;xsl:copy&gt; &lt;xsl:apply-templates select=\"node()|@*\"\/&gt; &lt;hat-gekuendigt&gt; &lt;xsl:sequence select=\"json-to-xml( unparsed-text( concat('https:\/\/tekturcms.de\/personal.xqy?personal-id=', personal-id))))\/descendant::*[@key='gekuendigt']\/text()\"\/&gt; &lt;\/hat-gekuendigt&gt; &lt;\/xsl:copy&gt; &lt;\/xsl:template&gt;</element><element id="9992ff44-8622-4832-a290-5b53de8787fbd6e14" type="para">Während mit oder ein zurückgeliefertes XML Fragment prozessiert wird, erwartet z.B. einen JSON-String , der dann mittels der Funktion nach XML konvertiert werden kann.</element><element id="3b7e4ebd-cc5a-448c-8ae5-85e90302d51dd6e16" type="para">Beispielsweise könnte die Gegenseite zum Template mittels XQuery folgendermassen realisiert sein:</element><element id="d45c6d1f-9338-4a49-ac64-055131a2f83cd7e21" type="code">xquery version \"1.0-ml\"; declare variable $personal-id := xdmp:get-request-field('personal-id'); let $gekuendigt := if (collection('\/personal')\/*[personal-id = $personal-id and fn:exists(kuendingung)] then 'ja' else 'nein' return common:render-response(concat('{\"gekuendigt\":\"',$gekuendigt,'\", \"personal-id\":\"',$personal-id,'\"}'))</element><element id="83a12eb2-9d2c-4bea-9d00-463280925e65d6e20" type="para">( Mehr zu XQuery und den hier verwendeten Konstrukten , wie ))</element><element id="dc9f1757-17d5-4982-9f9b-b624dcc9f86cd6e22" type="para">Das zurückgeklieferte JSON Dokument sieht dann so aus:</element><element id="cad40840-781d-4997-bc84-52a1cbf68137d7e30" type="code">{\"gekuendig\":\"ja\",\"personal-id\":\"q5687500\"}</element><element id="c16d857e-bf25-4013-a637-fb1f1f42b212d6e27" type="para">Konvertiert nach XML erhält man eine Map Struktur:</element><element id="3e3f2091-b150-43cb-b547-8b073476833ad7e35" type="code">&lt;map xmlns=\"http:\/\/www.w3.org\/2005\/xpath-functions\"&gt; &lt;string key=\"gekuedigt\"&gt;ja&lt;\/string&gt; &lt;string key=\"personal-id\"&gt;q5687500&lt;\/string&gt; &lt;\/map&gt;</element><element id="5aa1c1a3-6eaa-470b-bbb0-9cecf34158c3d6e31" type="para">was den Selektorausdruck im obigen XPATH erklärt:</element><element id="41f73d6b-a42a-4af4-bb73-a0fc6341c04ad7e39" type="code">json-to-xml( unparsed-text( concat('https:\/\/tekturcms.de\/personal.xqy?personal-id=', personal-id))))\/descendant::*[@key='gekuendigt']\/text()</element><element id="423a28a9-42c2-4e62-b73c-c2a48f68c079d6e35" type="para">Resultat der Konvertierung wäre also dann - wie erwartet - ein um das Flag erweitertes Element:</element><element id="ad057294-c06d-4e41-83b2-b43466c65e40d7e43" type="code">&lt;angestellter&gt; &lt;perosnal-id&gt;q5687500&lt;\/perosnal-id&gt; &lt;name&gt;Alex&lt;\/name&gt; [...] &lt;gekuendigt&gt;nein&lt;\/gekuendigt&gt; &lt;\/angestellter&gt;</element><element id="d6ebc0e3-4946-40df-99b9-89d396165f96d6e39" type="para">Sicherlich wird der XML Entwicler eine XML Datenbank , wie MarkLogic, vorziehen und sich gleich XML Fragmente ausliefern laasen. ist aber bspw. mit MongoDB realisiert, die auf JSON arbeitet... Nicht zuletzt deshalb finde ich JSON Verarbeitung mit XSLT recht spannend.</element></elements>