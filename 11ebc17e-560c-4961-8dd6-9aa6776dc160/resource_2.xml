<?xml version="1.0" encoding="UTF-8"?><topic id="7f03cc5e-675a-4371-b3e9-5d79b981ff95"><title id="fbbe8267-ed7b-4b78-b547-d00fe41f0b5c">Webservice Calls mit [[code:doc()]] und [[code:unparsed-text()]]</title><body id="813af5cb-f856-4d8c-996c-dd02e81732fd"><p id="cfd5bdf8-a043-405f-a3f7-1feb395fbd3d">Eine verbreitete Paxis ist es, mit der Funktion [[code:document()]] oder kurz [[code:doc()]] 
entfernte Ressourcen in die Transformation einzubinden. 
Bei einer Schematron-Validierung, würde bspw. eine Regel, wie:</p><pre id="2d899d0b-61b2-4120-bc28-3dce1771f04bd6e6" xml:space="preserve">&lt;sch:not-assert id="personal-check"
    role="error"
    test="doc(concat('https://tekturcms.de/personal.xqy?personal-id=',personal-id))/kuendigung"&gt;
        Angestellter mit ID "&lt;sch:value-of select="personal-id"/&gt;" hat gekündigt!
&lt;/sch:not-assert&gt;</pre><p id="9fc3fa46-8e19-4c2b-90cf-0f2a76ef18eed6e8">einen entferneten Webservice aufrufen und prüfen, ob für den Angestellten mit [[code:personal-id]]
eine Kündigung vorliegt. Ist dies der Fall, so ist die negative Zusicherung [[code:not-assert]] nicht
erfüllt und die Schematron Regel feuert - was sich wohl im einfachsten Fall in einem 
Logfile Eintrag äussern sollte.</p><p id="e3b1a6ca-7163-4c64-a69d-a1f4277847d5d6e10">Was vermutlich viele noch nicht kennen - ich nehme jetzt einfach mal an, dass mein 
bisheriger Kenntnisstand dem der Mehrheit der XML-Entwickler entspricht - ist der Umstand,
dass auch die Funktion [[code:unparsed-text()] eine URL als Parameter nimmt:</p><pre id="e6db375a-5101-4f72-b171-84beb1242de0d6e12" xml:space="preserve">&lt;xsl:template match="angestellter"
    &lt;xsl:copy&gt;
        &lt;xsl:apply-templates select="node()|@*"/&gt;
        &lt;hat-gekuendigt&gt;
            &lt;xsl:sequence select="json-to-xml(
                                  unparsed-text(
                                  concat('https://tekturcms.de/personal.xqy?personal-id=',
                                  personal-id))))/descendant::*[@key='gekuendigt']/text()"/&gt;
        &lt;/hat-gekuendigt&gt;
    &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;</pre><p id="9992ff44-8622-4832-a290-5b53de8787fbd6e14">Während mit [code:doc()]] oder [[code:document()]] ein zurückgeliefertes XML Fragment 
prozessiert wird, erwartet [[code:unparsed-text()]] z.B. einen JSON-String, der dann mittels
der Funktion [[code:json-to-xml]] nach XML konvertiert werden kann.</p><p id="3b7e4ebd-cc5a-448c-8ae5-85e90302d51dd6e16">Beispielsweise könnte die Gegenseite zum [[code:angestellter]] Template mittels XQuery
folgendermassen realisiert sein:</p><pre id="99486236-e65e-454e-b1cd-e73c07b59a01d6e18" xml:space="preserve">xquery version "1.0-ml";

declare variable $personal-id := xdmp:get-request-field('personal-id');

let $gekuendigt := if (collection('/personal')/*[personal-id = $personal-id and 
                                                 fn:exists(kuendingung)] then 
                                                 'ja' else 'nein'
return 
    common:render-response(concat('{"gekuendigt":"',$gekuendigt,'",
                                    "personal-id":"',$personal-id,'"}'))</pre><p id="83a12eb2-9d2c-4bea-9d00-463280925e65d6e20">(Mehr zu XQuery und den hier verwendeten Konstrukten, wie [[code:render-response()]]))</p><p id="dc9f1757-17d5-4982-9f9b-b624dcc9f86cd6e22">Das zurückgeklieferte JSON Dokument sieht dann so aus:</p><pre id="7cc7e325-b116-4985-ad62-dc5ec25f84eed6e24" xml:space="preserve">{"gekuendig":"ja","personal-id":"q5687500"}</pre><p id="c16d857e-bf25-4013-a637-fb1f1f42b212d6e27">Konvertiert nach XML erhält man eine Map Struktur:</p><pre id="d6856d10-00e4-43f5-9115-cc1dbe710099d6e29" xml:space="preserve">&lt;map xmlns="http://www.w3.org/2005/xpath-functions"&gt;
    &lt;string key="gekuedigt"&gt;ja&lt;/string&gt;
    &lt;string key="personal-id"&gt;q5687500&lt;/string&gt;
&lt;/map&gt;</pre><p id="5aa1c1a3-6eaa-470b-bbb0-9cecf34158c3d6e31">was den Selektorausdruck im obigen XPATH erklärt:</p><pre id="f904faf6-9e9a-4e2d-82ac-bad3676dc171d6e33" xml:space="preserve">json-to-xml(
unparsed-text(
concat('https://tekturcms.de/personal.xqy?personal-id=',
personal-id))))/descendant::*[@key='gekuendigt']/text()</pre><p id="423a28a9-42c2-4e62-b73c-c2a48f68c079d6e35">Resultat der Konvertierung wäre also dann - wie erwartet - ein um 
das [[code:gekuendigt]] Flag erweitertes [[code:&lt;angestellter&gt;]]
Element:</p><pre id="f53ad28e-3f85-424c-a419-71d120b1a919d6e37" xml:space="preserve">&lt;angestellter&gt;
    &lt;perosnal-id&gt;q5687500&lt;/perosnal-id&gt;
    &lt;name&gt;Alex&lt;/name&gt;
    [...]
    &lt;gekuendigt&gt;nein&lt;/gekuendigt&gt;
&lt;/angestellter&gt;</pre><p id="d6ebc0e3-4946-40df-99b9-89d396165f96d6e39">Sicherlich wird der XML Entwicler eine XML Datenbank, wie MarkLogic, vorziehen
und sich gleich XML Fragmente ausliefern laasen. [[$productname]] ist aber bspw. mit
[[link]]MongoDB[[fn:https://www.mongodb.com/*Homepage der NoSQL Datenbank MongoDB]]
realisiert, die auf JSON arbeitet... Nicht zuletzt deshalb finde ich JSON Verarbeitung
mit XSLT recht spannend.</p></body></topic>