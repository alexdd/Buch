[{"id":"fbbe8267-ed7b-4b78-b547-d00fe41f0b5c","type":"para","text":"Webservice Calls mit und","title":" Webservice Calls mit [[ code:doc() ]] und [[ code:unparsed-text() ]]  "},{"id":"cfd5bdf8-a043-405f-a3f7-1feb395fbd3d","type":"para","text":"Eine verbreitete Paxis ist es, mit der Funktion oder kurz entfernte Ressourcen in die Transformation einzubinden. Bei einer Schematron-Validierung, würde bspw. eine Regel, wie:","title":" Webservice Calls mit [[ code:doc() ]] und [[ code:unparsed-text() ]]  "},{"id":"bc38c9e1-5f74-4113-a8c6-cbd55adca1c8d7e6","type":"code","text":"<sch:not-assert id=\"personal-check\" role=\"error\" test=\"doc(concat('https:\/\/tekturcms.de\/personal.xqy?personal-id=',personal-id))\/kuendigung\"> Angestellter mit ID \"<sch:value-of select=\"personal-id\"\/>\" hat gekündigt! <\/sch:not-assert>","title":" Webservice Calls mit [[ code:doc() ]] und [[ code:unparsed-text() ]]  "},{"id":"9fc3fa46-8e19-4c2b-90cf-0f2a76ef18eed6e8","type":"para","text":"einen entferneten Webservice aufrufen und prüfen, ob für den Angestellten mit eine Kündigung vorliegt. Ist dies der Fall, so ist die negative Zusicherung nicht erfüllt und die Schematron Regel feuert - was sich wohl im einfachsten Fall in einem Logfile Eintrag äussern sollte.","title":" Webservice Calls mit [[ code:doc() ]] und [[ code:unparsed-text() ]]  "},{"id":"e3b1a6ca-7163-4c64-a69d-a1f4277847d5d6e10","type":"para","text":"Was vermutlich viele noch nicht kennen - ich nehme jetzt einfach mal an, dass mein bisheriger Kenntnisstand dem der Mehrheit der XML-Entwickler entspricht - ist der Umstand, dass auch die Funktion eine URL als Parameter nimmt:","title":" Webservice Calls mit [[ code:doc() ]] und [[ code:unparsed-text() ]]  "},{"id":"1900cede-f29a-43fc-a6c9-ed69ce6b966ad7e12","type":"code","text":"<xsl:template match=\"angestellter\" <xsl:copy> <xsl:apply-templates select=\"node()|@*\"\/> <hat-gekuendigt> <xsl:sequence select=\"json-to-xml( unparsed-text( concat('https:\/\/tekturcms.de\/personal.xqy?personal-id=', personal-id))))\/descendant::*[@key='gekuendigt']\/text()\"\/> <\/hat-gekuendigt> <\/xsl:copy> <\/xsl:template>","title":" Webservice Calls mit [[ code:doc() ]] und [[ code:unparsed-text() ]]  "},{"id":"9992ff44-8622-4832-a290-5b53de8787fbd6e14","type":"para","text":"Während mit oder ein zurückgeliefertes XML Fragment prozessiert wird, erwartet z.B. einen JSON-String , der dann mittels der Funktion nach XML konvertiert werden kann.","title":" Webservice Calls mit [[ code:doc() ]] und [[ code:unparsed-text() ]]  "},{"id":"3b7e4ebd-cc5a-448c-8ae5-85e90302d51dd6e16","type":"para","text":"Beispielsweise könnte die Gegenseite zum Template mittels XQuery folgendermassen realisiert sein:","title":" Webservice Calls mit [[ code:doc() ]] und [[ code:unparsed-text() ]]  "},{"id":"d45c6d1f-9338-4a49-ac64-055131a2f83cd7e21","type":"code","text":"xquery version \"1.0-ml\"; declare variable $personal-id := xdmp:get-request-field('personal-id'); let $gekuendigt := if (collection('\/personal')\/*[personal-id = $personal-id and fn:exists(kuendingung)] then 'ja' else 'nein' return common:render-response(concat('{\"gekuendigt\":\"',$gekuendigt,'\", \"personal-id\":\"',$personal-id,'\"}'))","title":" Webservice Calls mit [[ code:doc() ]] und [[ code:unparsed-text() ]]  "},{"id":"83a12eb2-9d2c-4bea-9d00-463280925e65d6e20","type":"para","text":"( Mehr zu XQuery und den hier verwendeten Konstrukten , wie ))","title":" Webservice Calls mit [[ code:doc() ]] und [[ code:unparsed-text() ]]  "},{"id":"dc9f1757-17d5-4982-9f9b-b624dcc9f86cd6e22","type":"para","text":"Das zurückgeklieferte JSON Dokument sieht dann so aus:","title":" Webservice Calls mit [[ code:doc() ]] und [[ code:unparsed-text() ]]  "},{"id":"cad40840-781d-4997-bc84-52a1cbf68137d7e30","type":"code","text":"{\"gekuendig\":\"ja\",\"personal-id\":\"q5687500\"}","title":" Webservice Calls mit [[ code:doc() ]] und [[ code:unparsed-text() ]]  "},{"id":"c16d857e-bf25-4013-a637-fb1f1f42b212d6e27","type":"para","text":"Konvertiert nach XML erhält man eine Map Struktur:","title":" Webservice Calls mit [[ code:doc() ]] und [[ code:unparsed-text() ]]  "},{"id":"3e3f2091-b150-43cb-b547-8b073476833ad7e35","type":"code","text":"<map xmlns=\"http:\/\/www.w3.org\/2005\/xpath-functions\"> <string key=\"gekuedigt\">ja<\/string> <string key=\"personal-id\">q5687500<\/string> <\/map>","title":" Webservice Calls mit [[ code:doc() ]] und [[ code:unparsed-text() ]]  "},{"id":"5aa1c1a3-6eaa-470b-bbb0-9cecf34158c3d6e31","type":"para","text":"was den Selektorausdruck im obigen XPATH erklärt:","title":" Webservice Calls mit [[ code:doc() ]] und [[ code:unparsed-text() ]]  "},{"id":"41f73d6b-a42a-4af4-bb73-a0fc6341c04ad7e39","type":"code","text":"json-to-xml( unparsed-text( concat('https:\/\/tekturcms.de\/personal.xqy?personal-id=', personal-id))))\/descendant::*[@key='gekuendigt']\/text()","title":" Webservice Calls mit [[ code:doc() ]] und [[ code:unparsed-text() ]]  "},{"id":"423a28a9-42c2-4e62-b73c-c2a48f68c079d6e35","type":"para","text":"Resultat der Konvertierung wäre also dann - wie erwartet - ein um das Flag erweitertes Element:","title":" Webservice Calls mit [[ code:doc() ]] und [[ code:unparsed-text() ]]  "},{"id":"ad057294-c06d-4e41-83b2-b43466c65e40d7e43","type":"code","text":"<angestellter> <perosnal-id>q5687500<\/perosnal-id> <name>Alex<\/name> [...] <gekuendigt>nein<\/gekuendigt> <\/angestellter>","title":" Webservice Calls mit [[ code:doc() ]] und [[ code:unparsed-text() ]]  "},{"id":"d6ebc0e3-4946-40df-99b9-89d396165f96d6e39","type":"para","text":"Sicherlich wird der XML Entwicler eine XML Datenbank , wie MarkLogic, vorziehen und sich gleich XML Fragmente ausliefern laasen. ist aber bspw. mit MongoDB realisiert, die auf JSON arbeitet... Nicht zuletzt deshalb finde ich JSON Verarbeitung mit XSLT recht spannend.","title":" Webservice Calls mit [[ code:doc() ]] und [[ code:unparsed-text() ]]  "}]