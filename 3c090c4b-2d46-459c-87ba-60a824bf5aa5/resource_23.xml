<?xml version="1.0" encoding="UTF-8"?><topic id="e3e3be23-3387-4f2d-bc88-628272b743f3"><title id="f19c130f-edfe-408f-a9e2-31b53d92bb4c">Einige aktuelle und vergangene Szenarien</title><body id="9cc3bf17-5788-4134-a1d2-361e3105f53e"><p id="0d86999f-6918-45f8-aa05-ee775429e1db">Einige Beispiele - aktuell und aus vergangenen Tagen:</p><section id="6de19f8a-d057-4328-8fdd-1d2f7aa0162fd6e6"><title id="ab76273e-04a8-430a-9f91-9a1b68d9c981d6e7">XML Webseiten</title><p id="d23736ab-93da-4908-83d8-38ffd747db2dd6e9">Einen XSLT Prozessor hat jeder Browser eingebaut. Es gab mal eine Zeit, in der es sehr populär war, Webseiten vom Server als XML auszuliefern[[xe1:Anwendungsgebiete;xe2:XML Webseiten]]. XML erlaubt die semantische Auszeichung des Inhalts, und die strikte Trennung des Inhalts von Layout und Design. Wesentlich besser als dies mit HTML und CSS jemals möglich wäre. Ich denke, u.a. wegen des exzessiven Einsatzes von Javascript (auch inline), hat sich diese Idee nie vollständig durchgesetzt. Schliesslich wurde XHTML spezifiziert und jetzt gibt es HTML5.</p><p id="c5dabda9-b019-4598-8fed-e6a685efd53cd6e17">Betrachten wir das folgende einfache XML Beispiel:</p><pre id="3a44a266-9fe1-479a-a53a-5edff33e389ad6e13" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;document&gt;
&lt;title&gt;Das ultimative Zwei-Kapitel Dokument&lt;/title&gt;
  &lt;chapter&gt;
    &lt;title&gt;Kapitel 1&lt;/title&gt;
    &lt;intro&gt;In Kapitel 1 wird kurz gesagt was Sache ist.&lt;/intro&gt;
    &lt;content&gt;Um es kurz zu machen, wie der Hase läuft steht in Kapitel 2.&lt;/content&gt;
  &lt;/chapter&gt;
  &lt;chapter&gt;
    &lt;title&gt;Kapitel 2&lt;/title&gt;
    &lt;intro&gt;Hier wird erklärt, wie der Hase läuft.&lt;/intro&gt;
    &lt;content&gt;Im Prinzip ist es ganz einfach.&lt;/content&gt;
  &lt;/chapter&gt;
&lt;/document&gt;</pre><p id="1450640b-064e-42c2-9881-547df58b7020d6e21">Ohne XSLT Stylesheet Zuweisung wird der Browser eine Datei mit diesem Inhalt als eingerücktes XML anzeigen - oder die Tags einfach ignorieren und den Textinhalt in einer Zeile darstellen. Fügt man eine Processing Instruction[[fn:https://de.wikipedia.org/wiki/Verarbeitungsanweisung*Die Processing Instruction wertet der Parser als Kommando aus und nicht als Teil des XML Contents]][[xe1:XML Konstrukte;xe2:Processing Instruction]] am Anfang ein, wird ein XSLT Stylesheet vom Browser herangezogen und vor der Darstellung im Browser wird die so deklarierte XML Transformation ausgeführt:</p><pre id="8ae905cc-7600-46d4-b3cd-c6885a468c73d6e17" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?xml-stylesheet type="text/xsl" href="formatiermich.xsl" ?&gt;
&lt;document&gt;
  &lt;title&gt;Das ultimative Zwei-Kapitel Dokument&lt;/title&gt;
  &lt;chapter&gt;
[...]</pre><p id="134c0541-26a7-4213-9b7d-ed83c8f08cbcd6e25">Jetzt kann man das XML einfach im Browser öffnen und alles wird schön formatiert - je nachdem welche Regeln in [[code:formatiermich.xsl]] gesetzt sind - angezeigt:</p><pre id="f50cf604-9377-436b-a285-2c0190e3d9bbd6e21" xml:space="preserve">&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:template match="/"&gt;
    &lt;html&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="document"&gt;
  &lt;body&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/body&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="document/title"&gt;     
    &lt;h1&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/h1&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="chapter"&gt;
    &lt;div class="chapter"&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/div&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="chapter/title"&gt;
    &lt;h2&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/h2&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="chapter/intro"&gt;
    &lt;div class="intro"&gt;
      &lt;i&gt;&lt;xsl:apply-templates/&gt;&lt;/i&gt;      
    &lt;/div&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="chapter/content"&gt;
    &lt;p&gt;&lt;xsl:apply-templates/&gt;&lt;/p&gt;    
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</pre><p id="25706f42-0507-45a5-a2cc-66f12f9e87bdd6e30">Die Processing Instruction hat keinen Einfluss auf den XML Inhalt und wird in einer anderen Eingabeverarbeitung nicht herangezogen.</p></section><section id="9434d120-e2ed-464a-82c6-9372b56df404d6e25"><title id="d1a0e576-5434-4f78-a143-0aba397514ddd6e33">Serverseitige Konvertierung</title><p id="a476b87f-7491-444d-8668-72f5e5719ebed6e35">Auch eine serverseitige Konvertierung[[xe1:Anwendungsgebiete;xe2:Serverseitige Konvertierung]] ist gebräuchlich. Ein Beispiel aus vergangenen Tagen - WAP-Seiten[[fn:https://de.wikipedia.org/wiki/Wireless_Application_Protocol*Mittels dieser Technologie wurden Webinhalte auf Handys gespielt. Das war vor den Smartphones]] für unterschiedliche Handy-Modelle.</p><p id="b764a9c0-9b8f-411a-ab3a-6b9241047afed6e37">Damals hatten die Handys sehr unterschiedliche Displaygrößen. Handybrowser konnten noch nicht ausreichend Javascript und die Skalierung der WAP-Seite für das jeweilige Handy passierte nicht im Handy, sondern vor der Auslieferung auf der Serverseite. Dazu wurde eine XML Quelle mittels verschiedener XSLT Stylesheets in unterschiedliche WML WAP Repräsentationen transformiert.</p><p id="47042bcb-c720-41ec-819b-86527013fa52d6e39">So würde das Zwei-Kapitel Beispiel von oben im WML Format aussehen (recht einfach gehalten):</p><pre id="dbe7398a-5b06-421c-a26d-0e1ed09f0c06d6e34" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE wml PUBLIC "-//WAPFORUM//DTD WML 1.1//EN" "http://www.wap.org/DTD/wml_1.1.xml"&gt;
&lt;wml&gt;
  &lt;head&gt;
    &lt;meta name="title" content="Das ultimative Zwei-Kapitel Dokument"/&gt;   
  &lt;/head&gt; 
  &lt;card id="chapter1" title="Kapitel 1"&gt;
    &lt;p&gt;&lt;i&gt;In Kapitel 1 wird kurz gesagt was Sache ist.&lt;/i&gt;&lt;/p&gt;        
    &lt;p&gt;Um es kurz zu machen, wie der Hase läuft steht in Kapitel 2.&lt;/p&gt;  
  &lt;/card&gt;
  &lt;card id="chapter2" title="Kapitel 2"&gt;
    &lt;p&gt;&lt;i&gt;Hier wird erklärt, wie der Hase läuft.&lt;/i&gt;&lt;/p&gt;
    &lt;p&gt;Im Prinzip ist es ganz einfach.&lt;/p&gt;
  &lt;/card&gt;
&lt;/wml&gt;</pre><p id="5d603262-8282-4d8f-bb2f-145b7ff53e92d6e43">Eine XSLT Transformation, die die XML Daten von oben in diese WML Darstellung überführt, könnte z.B. so implementiert werden:</p><pre id="07c61de1-ed59-49f0-a958-4e0147e1241dd6e38" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;

  &lt;xsl:output
    doctype-public="-//WAPFORUM//DTD WML 1.2//EN" 
    doctype-system="http://www.wapforum.org/DTD/wml12.dtd"
    indent="yes"/&gt;
    
  &lt;xsl:template match="document"&gt;
    &lt;wml&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/wml&gt;
  &lt;/xsl:template&gt;
    
  &lt;xsl:template match="document/title"&gt;
    &lt;head&gt;
      &lt;meta name="title"&gt;
        &lt;xsl:attribute name="content"&gt;
          &lt;xsl:value-of select="."/&gt;               
        &lt;/xsl:attribute&gt;
      &lt;/meta&gt;      
    &lt;/head&gt;
  &lt;/xsl:template&gt;
    
  &lt;xsl:template match="chapter"&gt;
    &lt;card id="{concat('chapter',count(preceding-sibling::chapter)+1)}"&gt;
      &lt;xsl:attribute name="title"&gt;
        &lt;xsl:value-of select="title"/&gt;
      &lt;/xsl:attribute&gt;
      &lt;xsl:apply-templates select="*[not(self::title)]"/&gt;
    &lt;/card&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template match="node()|@*"&gt;
    &lt;xsl:copy&gt;
      &lt;xsl:apply-templates select="node()|@*"/&gt;
    &lt;/xsl:copy&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template match="processing-instruction()"/&gt;
  
  &lt;xsl:template match="intro"&gt;
    &lt;p&gt;&lt;i&gt;&lt;xsl:apply-templates/&gt;&lt;/i&gt;&lt;/p&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template match="content"&gt;
    &lt;p&gt;&lt;xsl:apply-templates/&gt;&lt;/p&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre></section><section id="e29cac40-a83c-4768-9165-debd6b5dc004d6e40"><title id="fa0123f8-d2ab-48fe-a8a4-69c5ea6e5b29d6e48">Ausgabeformate</title><p id="479bd9ce-f36a-4b96-a291-61f95e4e767dd6e50">Aus einer XML Quelle können auch leicht weitere Format erzeugt werden, bspw. ePub. EPUB[[fn:https://de.wikipedia.org/wiki/EPUB*EPUB ist ein Dokumentformat für Ebook-Reader.]] ist das Standardformat für eBooks und neben Tags zur Formatierung für den Content, gibt es bspw. auch Anweisungen zum Erzeugen des Inhaltsverzeichnisses oder anderer Navigationsstrukturen.</p><p id="e8969256-cea5-4fd0-b7bf-5f9eeb42b148d6e52">Weitere gängige Formate sind neben dem oben gezeigten veralteten WML Format, elektronische Ausgabe-Formate wie: CHM[[fn:https://de.wikipedia.org/wiki/CHM_(Dateiformat*Die alte Windows-Hilfe. Läuft immer noch im Bereich Maschinenbau auf gekoppelten Rechnern mit alter Windows Software)]], EclipseHelp[[fn:https://www.ibm.com/developerworks/library/os-echelp/index.html*Das Hilfe-Format der Eclipse Rich Client Plattform. Eclipse wird hauptsächlich von Programmierern als Editor benutzt]], JavaHelp[[fn:https://en.wikipedia.org/wiki/JavaHelp*Damit wird bspw. das Java API formatiert als Webseite ausgegeben]], ..., Print-Ausgabe Formate, wie PDF oder Adobe Framemaker[[fn:https://de.wikipedia.org/wiki/FrameMaker*Mit Framemaker kann man manuell gesetzte Publikationen erstellen. Über Templates lässt sich das Layout aber auch automatisieren]],  oder XML Standard Austauschformate, wie DITA, S1000D, PI-MOD[[fn:https://www.i4icm.de/forschungstransfer/pi-mod/*PI-Mod ist ein Informationsmodell, das am KIT (Uni Karlsruhe) entwickelt wird/wurde]], JATS[[fn:https://de.wikipedia.org/wiki/Journal_Article_Tag_Suite*JATS ist ein sehr verbreitetes Informationsmodell im Bereich wissenschaftlicher Artikel und Fachliteratur]][[xe1:Standards;xe2:JAT]] oder TEI[[fn:https://de.wikipedia.org/wiki/Text_Encoding_Initiative]][[xe1:Standards;xe2:TEI]].</p></section><section id="a14faa96-d86b-4432-8291-e619da8989a8d6e47"><title id="4135a624-a45f-433c-8d0b-18416fe3765fd6e55">Menschenlesbar machen</title><p id="dc869a54-1cb6-4282-b816-825027432083d6e57">Kryptische XML Log-, Daten- oder Konfigurationsfiles[[xe1:Anwendungsgebiete;xe2:Log- und Konfigurationsdaten]] können leicht mit XSLT menschenlesbar formatiert werden. &#8232;Ein Arbeitskollege im neuen Job kam kürzlich auf mich zu, ob ich um eine Möglichkeit wüsste, wie man sein kryptisches Datenfile für einen Übersetzungsdienst menschenlesbar formatieren könnte - XSLT to the Rescue:</p><pre id="60238786-05c0-4fdf-b47e-7b37fe34e655d6e52" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;?&lt;?xml-stylesheet type="text/xsl" href="de.xsl"?&gt;
&lt;jcr:root xmlns:sling="http://sling.apache.org/jcr/sling/1.0"
  xmlns:jcr="http://www.jcp.org/jcr/1.0" 
  xmlns:mix="http://www.jcp.org/jcr/mix/1.0"
  xmlns:nt="http://www.jcp.org/jcr/nt/1.0"
  jcr:language="de"
  jcr:mixinTypes="[mix:language]"
  jcr:primaryType="sling:Folder"&gt;
&lt;b_manual 
  jcr:primaryType="sling:MessageEntry"
  sling:message="Bedienungsanleitung"/&gt;
  &lt;b_warning
    jcr:primaryType="sling:MessageEntry"
    sling:message="Warnung"/&gt;
  &lt;b_danger
    jcr:primaryType="sling:MessageEntry"
    sling:message="Vorsicht"/&gt;
  &lt;b_note
    jcr:primaryType="sling:MessageEntry"
    sling:message="Notiz"/&gt;
  &lt;b_notice
    jcr:primaryType="sling:MessageEntry"
    sling:message="Hinweis"/&gt;
  [...]</pre><p id="aaaf6a3a-55b3-4599-8bbd-59db3819473fd6e61">Mit einem eingehängten XSLT Stylesheet de.xsl wird so ein XML Datenfile schön formatiert als Tabelle angezeigt:</p><pre id="1561c2d5-fe68-44e6-8e3c-aed269ddd604d6e56" xml:space="preserve">&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:jcr="http://www.jcp.org/jcr/1.0"
  xmlns:sling="http://sling.apache.org/jcr/sling/1.0"&gt;
  
  &lt;xsl:template match="jcr:root"&gt;
    &lt;html&gt;
      &lt;table border="1" cellpadding="5" cellspacing="5"&gt;
        &lt;xsl:apply-templates/&gt;
      &lt;/table&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template match="*"&gt;
    &lt;tr&gt;
      &lt;td&gt;
        &lt;xsl:value-of select="concat(count(preceding::*[@sling:message]) + 1,'.')"/&gt;
      &lt;/td&gt;
      &lt;td&gt;
        &lt;xsl:value-of select="name()"/&gt;
      &lt;/td&gt;
      &lt;td contenteditable="true"&gt;
        &lt;xsl:value-of select="@sling:message"/&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre><p id="8306957f-386e-4c63-9c69-ee876511fecbd6e65">Hängt man an dieses Beispiel noch ein bisschen Javascript Logik und macht die Felder für die Übersetzungen mittels des HTML5 contenteditable Attributs editierbar, dann bräuchte man nur noch eine Rücktransformation HTML nach XML und hätte schon einen kleinen webbasierten XML Editor gebaut. Genau nach diesem Prinzip funktionieren einige aktuelle XML Editoren.</p></section><section id="6c2ad096-d310-41a1-9648-cf267b4a601bd6e60"><title id="5ab04d47-2964-42e4-8002-ba2b7828111bd6e68">Diagramme</title><p id="6a649e53-dde4-4e49-8e01-1fb5ad83cf2ed6e70">Nachdem eine SVG[[xe1:Standards;xe2:SVG]] Grafik[[xe1:Anwendungsgebiete;xe2:Visualisierung]] im XML Format vorliegt kann diese auch direkt aus XML Daten mittels XSLT erzeugt werden.&#8232;Über das HTML5 &lt;svg&gt; Element kann so eine erzeugte Grafik inline in das ebenfalls durch das XSLT generierte HTML Dokument eingebunden werden.</p><p id="182ba4df-adcd-4102-af88-18c7570f7b71d6e72">Betrachten wir unser Beispiel von oben, erweitert um drei neue &lt;block&gt; Elemente:</p><pre id="8832df09-fd4e-4ff9-8d6c-c68412ae6860d6e67" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?xml-stylesheet type="text/xsl" href="chart.xsl" ?&gt;
&lt;document&gt;
  &lt;title&gt;Das ultimative Zwei-Kapitel Dokument&lt;/title&gt;
  &lt;chapter&gt;
    &lt;title&gt;Kapitel 1&lt;/title&gt;
    &lt;intro&gt;In Kapitel 1 wird kurz gesagt was Sache ist.&lt;/intro&gt;
    &lt;content&gt;Um es kurz zu machen, wie der Hase läuft steht in Kapitel 2.&lt;/content&gt;
  &lt;/chapter&gt;
  &lt;chapter&gt;
    &lt;title&gt;Kapitel 2&lt;/title&gt;
    &lt;intro&gt;Hier wird erklärt, wie der Hase läuft.&lt;/intro&gt;
    &lt;content&gt;Im Prinzip ist es ganz einfach. Betrachten wir doch drei gelbe Blöcke:
    &lt;/content&gt;
    &lt;block/&gt;
    &lt;block/&gt;
    &lt;block/&gt;
  &lt;/chapter&gt;
&lt;/document&gt;</pre><p id="f5656cd5-03c5-43a0-be15-a7187bbdab37d6e76">Wenn wir das XSLT Stylesheet von oben noch um eine Regel für das neue &lt;block&gt; Element ergänzen, so wie hier:</p><pre id="dfa645de-09c3-4790-ae32-6e4484a1a36ed6e71" xml:space="preserve">&lt;xsl:template match="block"&gt;
   &lt;svg style="background-color:yellow" width="30" height="30" 
     xmlns:xlink="http://www.w3.org/1999/xlink" 
     xmlns="http://www.w3.org/2000/svg"/&gt;
  &lt;br/&gt;
  &lt;br/&gt;
&lt;/xsl:template&gt;</pre><p id="1015bdf3-e31c-4085-b1cb-00c7cc2c5bd4d6e80">Dann erhalten wir drei schön formatierte gelbe SVG Blöcke.</p><p id="f1e12ddb-1bcb-49c0-b938-0a77393018d1d6e82"><b id="276fca58-f8f9-4599-a1e6-318f31e908c5d6e83">Weiterführende Links:</b></p><ul id="278be9f3-273e-42c2-99d0-cc6f4bc6598ad6e85"><li id="7b8f33e5-e850-48c1-a804-9fb6e06e8667d6e86"><p id="d206a44d-c978-4902-9d62-0d34675e805dd6e87">Client-side image generation with SVG and XSLT[[fn:http://surguy.net/articles/client-side-svg.xml]]</p></li><li id="923ca5a1-1353-47cc-80da-9def9d2ec2f0d6e89"><p id="5689021e-dff9-4b37-9f33-35a0bb84a3c6d6e90">Knotentyp Visualisierung im Apache Jack Rabbit Projekt[[fn:http://jackrabbit.apache.org/jcr/node-type-visualization.html]]</p></li></ul></section></body></topic>