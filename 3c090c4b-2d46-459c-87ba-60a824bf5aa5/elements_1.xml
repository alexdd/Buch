<?xml version="1.0" encoding="UTF-8"?><elements><element id="f19c130f-edfe-408f-a9e2-31b53d92bb4c" type="para">Aktuelle und vergangene Anwendungen</element><element id="0d86999f-6918-45f8-aa05-ee775429e1db" type="para">Wie auch bei anderen Programmiersprachen, hat es einige Zeit gedauert bis sich für XSLT der optimale Anwendungsbereich herauskristallisiert hat. Auch bei XSLT war ursprünglich das Internet und insbesondere Webseitenprogrammierung die treibende Kraft, weil meinte, mittels XSLT besonders gut Inhalt und Semantik trennen zu können.</element><element id="1cc2b53a-8cb6-4144-83d9-02b7d4475ce5d7e6" type="para">Relativ schnell hat sich aberCSSin Verbindung mitJavaScriptals Standardlösung für diese Zecke bewährt.XSLTist inzwischen Platzhirsch im BereichTechnische Dokumentationund hier auch wohl unschlagbar.</element><element id="ab76273e-04a8-430a-9f91-9a1b68d9c981d6e7" type="para">XML Webseiten</element><element id="d23736ab-93da-4908-83d8-38ffd747db2dd6e9" type="para">Einen XSLT Prozessor hat jeder Browser eingebaut. Es gab mal eine Zeit, in der es sehr populär war, Webseiten vom Server als XML auszuliefern. XML erlaubt die semantische Auszeichung des Inhalts, und die strikte Trennung des Inhalts von Layout und Design. Wesentlich besser als dies mit HTML und CSS jemals möglich wäre. U.a. wegen des exzessiven Einsatzes von JavaScript (auch inline), hat sich diese Idee nie vollständig durchgesetzt. Schliesslich wurdeXHTMLspezifiziert und jetzt gibt esHTML5.</element><element id="c5dabda9-b019-4598-8fed-e6a685efd53cd6e17" type="para">Betrachten wir das folgende XML Beispiel:</element><element id="9bb99ad0-13d0-4bd5-8328-3c792902c94dd7e33" type="code">&lt;?xml version=\"1.0\"encoding=\"UTF-8\"?&gt; &lt;document&gt; &lt;title&gt;Das ultimative Zwei-Kapitel Dokument&lt;\/title&gt; &lt;chapter&gt; &lt;title&gt;Kapitel 1&lt;\/title&gt; &lt;intro&gt;In Kapitel 1 wird kurz gesagt was Sache ist.&lt;\/intro&gt; &lt;content&gt;Um es kurz zu machen, wie der Hase läuft steht in Kapitel 2.&lt;\/content&gt; &lt;\/chapter&gt; &lt;chapter&gt; &lt;title&gt;Kapitel 2&lt;\/title&gt; &lt;intro&gt;Hier wird erklärt, wie der Hase läuft.&lt;\/intro&gt; &lt;content&gt;Im Prinzip ist es ganz einfach.&lt;\/content&gt; &lt;\/chapter&gt; &lt;\/document&gt;</element><element id="1450640b-064e-42c2-9881-547df58b7020d6e21" type="para">Ohne XSLT Stylesheet Zuweisung wird der Browser eine Datei mit diesem Inhalt als eingerücktes XML anzeigen - oder die Tags einfach ignorieren und den Textinhalt in einer Zeile darstellen. Fügt man eineProcessing Instructionam Anfang ein, wird ein XSLT Stylesheet vom Browser herangezogen und vor der Darstellung im Browser wird die so deklarierte XML Transformation ausgeführt:</element><element id="bc34cd7b-1e3b-44ec-b63e-68307a605849d7e37" type="code">&lt;?xml version=\"1.0\"encoding=\"UTF-8\"?&gt; &lt;?xml-stylesheet type=\"text\/xsl\"href=\"formatiermich.xsl\"?&gt; &lt;document&gt; &lt;title&gt;Das ultimative Zwei-Kapitel Dokument&lt;\/title&gt; &lt;chapter&gt; [...]</element><element id="134c0541-26a7-4213-9b7d-ed83c8f08cbcd6e25" type="para">Das XML kann nun im Browser geöffnet werden und alles wird schön formatiert angezeigt...</element><element id="b2bc33aa-9158-4894-894d-996ec69a7e2fd7e41" type="code">&lt;?xml version=\"1.0\"encoding=\"iso-8859-1\"?&gt; &lt;xsl:stylesheet version=\"1.0\"xmlns:xsl=\"http:\/\/www.w3.org\/1999\/XSL\/Transform\"&gt; &lt;xsl:template match=\"\/\"&gt; &lt;html&gt; &lt;xsl:apply-templates\/&gt; &lt;\/html&gt; &lt;\/xsl:template&gt; &lt;xsl:template match=\"document\"&gt; &lt;body&gt; &lt;xsl:apply-templates\/&gt; &lt;\/body&gt; &lt;\/xsl:template&gt; &lt;xsl:template match=\"document\/title\"&gt; &lt;h1&gt; &lt;xsl:apply-templates\/&gt; &lt;\/h1&gt; &lt;\/xsl:template&gt; &lt;xsl:template match=\"chapter\"&gt; &lt;div class=\"chapter\"&gt; &lt;xsl:apply-templates\/&gt; &lt;\/div&gt; &lt;\/xsl:template&gt; &lt;xsl:template match=\"chapter\/title\"&gt; &lt;h2&gt; &lt;xsl:apply-templates\/&gt; &lt;\/h2&gt; &lt;\/xsl:template&gt; &lt;xsl:template match=\"chapter\/intro\"&gt; &lt;div class=\"intro\"&gt; &lt;i&gt;&lt;xsl:apply-templates\/&gt;&lt;\/i&gt; &lt;\/div&gt; &lt;\/xsl:template&gt; &lt;xsl:template match=\"chapter\/content\"&gt; &lt;p&gt;&lt;xsl:apply-templates\/&gt;&lt;\/p&gt; &lt;\/xsl:template&gt; &lt;\/xsl:stylesheet&gt;</element><element id="25706f42-0507-45a5-a2cc-66f12f9e87bdd6e30" type="para">DieProcessing Instructionhat keinen Einfluss auf den XML Inhalt und wird in einer anderen Eingabeverarbeitung nicht herangezogen.</element><element id="d1a0e576-5434-4f78-a143-0aba397514ddd6e33" type="para">Serverseitige Konvertierung</element><element id="a476b87f-7491-444d-8668-72f5e5719ebed6e35" type="para">Auch eine serverseitige Konvertierungist gebräuchlich. Ein Beispiel aus vergangenen Tagen -WAP-Seitenfür unterschiedliche Handy-Modelle.</element><element id="b764a9c0-9b8f-411a-ab3a-6b9241047afed6e37" type="para">Früher hatten die Handys sehr unterschiedliche Displaygrößen. Handybrowser konnten nicht ausreichend JavaScript und die Skalierung der WAP-Seite für das jeweilige Handy passierte nicht im Handy, sondern vor der Auslieferung auf der Serverseite. Dazu wurde eine XML Quelle mittels verschiedener XSLT Stylesheets in unterschiedliche WML WAP Repräsentationen transformiert.</element><element id="47042bcb-c720-41ec-819b-86527013fa52d6e39" type="para">So würde das Zwei-Kapitel Beispiel von oben im WML Format aussehen (recht einfach gehalten):</element><element id="3433ee0e-ba7a-4013-a236-f1fc08adee44d7e57" type="code">&lt;?xml version=\"1.0\"encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE wml PUBLIC\"-\/\/WAPFORUM\/\/DTD WML 1.1\/\/EN\"\"http:\/\/www.wap.org\/DTD\/wml_1.1.xml\"&gt; &lt;wml&gt; &lt;head&gt; &lt;meta name=\"title\"content=\"Das ultimative Zwei-Kapitel Dokument\"\/&gt; &lt;\/head&gt; &lt;card id=\"chapter1\"title=\"Kapitel 1\"&gt; &lt;p&gt;&lt;i&gt;In Kapitel 1 wird kurz gesagt was Sache ist.&lt;\/i&gt;&lt;\/p&gt; &lt;p&gt;Um es kurz zu machen, wie der Hase läuft steht in Kapitel 2.&lt;\/p&gt; &lt;\/card&gt; &lt;card id=\"chapter2\"title=\"Kapitel 2\"&gt; &lt;p&gt;&lt;i&gt;Hier wird erklärt, wie der Hase läuft.&lt;\/i&gt;&lt;\/p&gt; &lt;p&gt;Im Prinzip ist es ganz einfach.&lt;\/p&gt; &lt;\/card&gt; &lt;\/wml&gt;</element><element id="5d603262-8282-4d8f-bb2f-145b7ff53e92d6e43" type="para">Eine XSLT Transformation, die die XML Daten von oben in dieseWMLDarstellung überführt, könnte z.B. so implementiert werden:</element><element id="fac9706c-570e-475b-843f-a86aa3b93afcd7e64" type="code">&lt;?xml version=\"1.0\"encoding=\"UTF-8\"?&gt; &lt;xsl:stylesheet xmlns:xsl=\"http:\/\/www.w3.org\/1999\/XSL\/Transform\"version=\"1.0\"&gt; &lt;xsl:output doctype-public=\"-\/\/WAPFORUM\/\/DTD WML 1.2\/\/EN\"doctype-system=\"http:\/\/www.wapforum.org\/DTD\/wml12.dtd\"indent=\"yes\"\/&gt; &lt;xsl:template match=\"document\"&gt; &lt;wml&gt; &lt;xsl:apply-templates\/&gt; &lt;\/wml&gt; &lt;\/xsl:template&gt; &lt;xsl:template match=\"document\/title\"&gt; &lt;head&gt; &lt;meta name=\"title\"&gt; &lt;xsl:attribute name=\"content\"&gt; &lt;xsl:value-of select=\".\"\/&gt; &lt;\/xsl:attribute&gt; &lt;\/meta&gt; &lt;\/head&gt; &lt;\/xsl:template&gt; &lt;xsl:template match=\"chapter\"&gt; &lt;card id=\"{concat('chapter',count(preceding-sibling::chapter)+1)}\"&gt; &lt;xsl:attribute name=\"title\"&gt; &lt;xsl:value-of select=\"title\"\/&gt; &lt;\/xsl:attribute&gt; &lt;xsl:apply-templates select=\"*[not(self::title)]\"\/&gt; &lt;\/card&gt; &lt;\/xsl:template&gt; &lt;xsl:template match=\"node()|@*\"&gt; &lt;xsl:copy&gt; &lt;xsl:apply-templates select=\"node()|@*\"\/&gt; &lt;\/xsl:copy&gt; &lt;\/xsl:template&gt; &lt;xsl:template match=\"processing-instruction()\"\/&gt; &lt;xsl:template match=\"intro\"&gt; &lt;p&gt;&lt;i&gt;&lt;xsl:apply-templates\/&gt;&lt;\/i&gt;&lt;\/p&gt; &lt;\/xsl:template&gt; &lt;xsl:template match=\"content\"&gt; &lt;p&gt;&lt;xsl:apply-templates\/&gt;&lt;\/p&gt; &lt;\/xsl:template&gt; &lt;\/xsl:stylesheet&gt;</element><element id="fa0123f8-d2ab-48fe-a8a4-69c5ea6e5b29d6e48" type="para">Multiple Ausgabeformate</element><element id="479bd9ce-f36a-4b96-a291-61f95e4e767dd6e50" type="para">Aus einer XML Quelle können auch leicht weitere Format erzeugt werden, bspw. .EPUBist das Standardformat für eBooks. Neben Tags zur Formatierung für den Content, gibt es bspw. auch Anweisungen zum Erzeugen des Inhaltsverzeichnisses oder anderer Navigationsstrukturen.</element><element id="e8969256-cea5-4fd0-b7bf-5f9eeb42b148d6e52" type="para">Weitere gängige Formate sind neben dem oben veralteten WML Format, elektronische Ausgabe-Formate wie:CHM,EclipseHelp,JavaHelp, ..., Print-Ausgabe Formate, wie PDF oderAdobe Framemaker, oder XML Standard Austauschformate, wieDITA,S1000D,PI-MOD,JATSoderTEI.</element><element id="4135a624-a45f-433c-8d0b-18416fe3765fd6e55" type="para">Menschenlesbare Ausgabe</element><element id="dc869a54-1cb6-4282-b816-825027432083d6e57" type="para">Kryptische XML Log-, Daten- oder Konfigurationsfileskönnen leicht mit XSLT menschenlesbar formatiert werden. Ein Arbeitskollege im neuen Job kam kürzlich auf mich zu, ob ich um eine Möglichkeit wüsste, wie man sein kryptisches Datenfile für einen Übersetzungsdienst formatieren könnte:</element><element id="8b6a780c-a0bd-42ff-9bec-26dbb7650af1d7e84" type="code">&lt;?xml version=\"1.0\"encoding=\"UTF-8\"?&gt;?&lt;?xml-stylesheet type=\"text\/xsl\"href=\"de.xsl\"?&gt; &lt;jcr:root xmlns:sling=\"http:\/\/sling.apache.org\/jcr\/sling\/1.0\"xmlns:jcr=\"http:\/\/www.jcp.org\/jcr\/1.0\"xmlns:mix=\"http:\/\/www.jcp.org\/jcr\/mix\/1.0\"xmlns:nt=\"http:\/\/www.jcp.org\/jcr\/nt\/1.0\"jcr:language=\"de\"jcr:mixinTypes=\"[mix:language]\"jcr:primaryType=\"sling:Folder\"&gt; &lt;b_manual jcr:primaryType=\"sling:MessageEntry\"sling:message=\"Bedienungsanleitung\"\/&gt; &lt;b_warning jcr:primaryType=\"sling:MessageEntry\"sling:message=\"Warnung\"\/&gt; &lt;b_danger jcr:primaryType=\"sling:MessageEntry\"sling:message=\"Vorsicht\"\/&gt; &lt;b_note jcr:primaryType=\"sling:MessageEntry\"sling:message=\"Notiz\"\/&gt; &lt;b_notice jcr:primaryType=\"sling:MessageEntry\"sling:message=\"Hinweis\"\/&gt; [...]</element><element id="aaaf6a3a-55b3-4599-8bbd-59db3819473fd6e61" type="para">Mit einem eingehängten XSLT Stylesheetwird so ein Datenfile als Tabelle formatiert:</element><element id="7c209b44-69e5-4b2f-adcc-b2df82fc1083d7e88" type="code">&lt;?xml version=\"1.0\"encoding=\"iso-8859-1\"?&gt; &lt;xsl:stylesheet version=\"1.0\"xmlns:xsl=\"http:\/\/www.w3.org\/1999\/XSL\/Transform\"xmlns:jcr=\"http:\/\/www.jcp.org\/jcr\/1.0\"xmlns:sling=\"http:\/\/sling.apache.org\/jcr\/sling\/1.0\"&gt; &lt;xsl:template match=\"jcr:root\"&gt; &lt;html&gt; &lt;table border=\"1\"cellpadding=\"5\"cellspacing=\"5\"&gt; &lt;xsl:apply-templates\/&gt; &lt;\/table&gt; &lt;\/html&gt; &lt;\/xsl:template&gt; &lt;xsl:template match=\"*\"&gt; &lt;tr&gt; &lt;td&gt; &lt;xsl:value-of select=\"concat(count(preceding::*[@sling:message]) + 1,'.')\"\/&gt; &lt;\/td&gt; &lt;td&gt; &lt;xsl:value-of select=\"name()\"\/&gt; &lt;\/td&gt; &lt;td contenteditable=\"true\"&gt; &lt;xsl:value-of select=\"@sling:message\"\/&gt; &lt;\/td&gt; &lt;\/tr&gt; &lt;\/xsl:template&gt; &lt;\/xsl:stylesheet&gt;</element><element id="8306957f-386e-4c63-9c69-ee876511fecbd6e65" type="para">Hängt man an dieses Beispiel noch ein bisschen JavaScript Logik und macht die Felder für die Übersetzungen mittels desHTML5Attributseditierbar, dann bräuchte man nur noch eine Rücktransformation HTML nach XML und hätte schon einen kleinen XML Editor gebaut. So funktioniert auch der Editor in.</element><element id="5ab04d47-2964-42e4-8002-ba2b7828111bd6e68" type="para">Diagramme darstellen</element><element id="6a649e53-dde4-4e49-8e01-1fb5ad83cf2ed6e70" type="para">Nachdem eineSVGGrafikimXMLFormat vorliegt kann diese auch direkt aus XML Daten mittels XSLT erzeugt werden. Über das HTML5Element kann so eine erzeugte Grafik inline in das ebenfalls durch das XSLT generierte HTML Dokument eingebunden werden.</element><element id="182ba4df-adcd-4102-af88-18c7570f7b71d6e72" type="para">Betrachten wir unser Beispiel von oben, erweitert um drei neueElemente:</element><element id="2fb8f6d0-bf49-4d29-9c33-e095412ad85bd7e108" type="code">&lt;?xml version=\"1.0\"encoding=\"UTF-8\"?&gt; &lt;?xml-stylesheet type=\"text\/xsl\"href=\"chart.xsl\"?&gt; &lt;document&gt; &lt;title&gt;Das ultimative Zwei-Kapitel Dokument&lt;\/title&gt; &lt;chapter&gt; &lt;title&gt;Kapitel 1&lt;\/title&gt; &lt;intro&gt;In Kapitel 1 wird kurz gesagt was Sache ist.&lt;\/intro&gt; &lt;content&gt;Um es kurz zu machen, wie der Hase läuft steht in Kapitel 2.&lt;\/content&gt; &lt;\/chapter&gt; &lt;chapter&gt; &lt;title&gt;Kapitel 2&lt;\/title&gt; &lt;intro&gt;Hier wird erklärt, wie der Hase läuft.&lt;\/intro&gt; &lt;content&gt;Im Prinzip ist es ganz einfach. Betrachten wir doch drei gelbe Blöcke: &lt;\/content&gt; &lt;block\/&gt; &lt;block\/&gt; &lt;block\/&gt; &lt;\/chapter&gt; &lt;\/document&gt;</element><element id="f5656cd5-03c5-43a0-be15-a7187bbdab37d6e76" type="para">Wenn wir das XSLT Stylesheet noch um eine Regel für das neueElement ergänzen, so wie hier:</element><element id="3bd1cf50-8a3b-48b9-94cd-4e7ad79c36cad7e112" type="code">&lt;xsl:template match=\"block\"&gt; &lt;svg style=\"background-color:yellow\"width=\"30\"height=\"30\"xmlns:xlink=\"http:\/\/www.w3.org\/1999\/xlink\"xmlns=\"http:\/\/www.w3.org\/2000\/svg\"\/&gt; &lt;br\/&gt; &lt;br\/&gt; &lt;\/xsl:template&gt;</element><element id="1015bdf3-e31c-4085-b1cb-00c7cc2c5bd4d6e80" type="para">Dann erhalten wir drei schön formatierte gelbe SVG Blöcke ...</element><element id="f1e12ddb-1bcb-49c0-b938-0a77393018d1d6e82" type="para">Weiterführende Links:</element><element id="d206a44d-c978-4902-9d62-0d34675e805dd6e87" type="para">Client-side image generation with SVG and XSLT</element><element id="5689021e-dff9-4b37-9f33-35a0bb84a3c6d6e90" type="para">Knotentyp Visualisierung im Apache Jack Rabbit Projekt</element></elements>