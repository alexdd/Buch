<div data-attribute-id="51877293-95b9-4486-b8f6-c006615a8109" class="topic show_menu tags" data-element="topic" data-deletable="false" data-tektur-editor-id="41a7f87a-ebad-48aa-a05c-32843093e592"><div class="gui-optional-elements-button" contenteditable="false"><div class="menu-icon" style="display:none">+</div></div><div data-attribute-id="40515442-a67d-49f4-9945-0f9d227bd97e" class="title pmarker tags" data-element="title" data-tektur-editor-id="ec2d4071-8fd1-4ea4-b33e-b13fbe5bd94c" contenteditable="true">XSLT Streaming Beispiel</div><div class="abstract optional show_menu tags" data-element="abstract" data-excluding="shortdesc" style="display:none" data-tektur-editor-id="367792e1-cd81-4c3d-b440-518bebfbba1c"><div class="gui-optional-elements-button" contenteditable="false"><div class="menu-icon" style="display:none">+</div></div><div class="placeholder text pmarker tags" data-element="p" data-tektur-editor-id="b17aad00-0a89-4959-8a8d-0cfcc39bdd61" contenteditable="true"></div></div><div data-attribute-id="c582561a-858c-4fd8-8aeb-2af18ceedd3d" class="body show_menu tags" data-element="body" data-deletable="false" data-tektur-editor-id="9cd08ce5-2d83-4309-ad30-c5c53ac387bc"><div class="gui-optional-elements-button" contenteditable="false"><div class="menu-icon" style="display:none">+</div></div><div class="section tektur-wrapper tags" data-element="section" data-tektur-editor-id="ea6a5768-2c72-4ae6-83e6-55c625dac1b5"><div xmlns:xr="http://www.tekturcms.de/2012/xr/common" xmlns:xlink="http://www.w3.org/1999/xlink" data-attribute-id="1b8326b9-86af-407d-b972-5b8d98339dec" class="p pmarker tags" data-element="p" data-tektur-editor-id="1cc630a2-5b7f-4acb-a10e-a0307bf11231" contenteditable="true">Bei grossen flach strukturierten Datenmengen gibt es zwei Möglichkeiten:</div><ol data-element="ol" style="" data-tektur-editor-id="ca504dcd-5300-498e-836c-29d653c71ddc" class="show_menu tags"><div class="gui-optional-elements-button" contenteditable="false"><div class="menu-icon" style="display:none">+</div></div><li class="li show_menu tags" data-element="li" data-tektur-editor-id="390e9525-d369-4f49-bc07-d5654014820d"><div class="p pmarker tags" data-element="p" contenteditable="true" data-tektur-editor-id="03fdaabc-5e86-4ae3-8f69-74bff6a91d5a">Für einfache Sammel- und Auswertungsaufgaben schreibt man sich am besten einen kleinen Parser, z.B. mit der Python sgmllib[[fn:https://docs.python.org/2/library/sgmllib.html]].</div></li><li class="li tags" data-element="li" data-tektur-editor-id="8d210104-196a-4f59-999f-020211156554"><div class="p  pmarker tags" data-element="p" contenteditable="true" data-tektur-editor-id="d72e6715-849e-406e-9c93-eb817ffcb590">Für komplexere Aufgaben, in denen man nicht an jeder Stelle über den ganzen XML Baum navigiert und sich die Werte zusammensuchen suchen muss, kann man die Streaming Funktion des Saxon XSLT Prozessors verwenden.</div></li></ol><div class="pmarker text tags" data-element="p" contenteditable="true" data-tektur-editor-id="3c77b87a-b5c6-4537-9133-4ea18d47cda7">XSLT Streaming ist in der XSLT Version 3.0 neu hinzugekommen[[fn:https://www.saxonica.com/html/documentation/sourcedocs/streaming/xslt-streaming.html]] und in der
kommerziellen Saxon-EE Löunsg implementiert[[fn:https://www.saxonica.com/html/documentation/sourcedocs/streaming/]].</div><div class="p tags pmarker" data-element="p" contenteditable="true" data-tektur-editor-id="924b6d69-5f4c-4b86-94c8-85e8229da6a1">Es gibt ein paar Regeln, die man bei der Verarbeitung großer Datenmengen über die Streaming Funktionen beachten sollte:</div><div class="p tags pmarker" data-element="p" contenteditable="true" data-tektur-editor-id="5d3d4a18-eb43-423c-8856-fdccef6a9721">Bei einer XPATH Auswertung sollte nur ein einfacher Ausdruck mit höchstens einer konsumierenden Selektion gegeben sein. Konsumieren heißt, dass vom Kontextknoten aus eine Knotenmenge abwärts selektiert wird.
Dagegen bleibt die Information bzgl. der Ancestor-Achse erhalten. Bei einer Selektion sollte man aber darauf achten nur atomarische Werte auszuwählen.
Knotenmengen, die über die Streaming Option eingelesen wurden, können nicht einer Funktion übergeben werden. Sie sind auch nicht einer Variablen zuweisbar.
“Crawler”-Ausdrücke, wie //section sind nicht nicht zu verwenden, ebenso ein rekursiver Abstieg, wie bspw. mit einem Apply-Templates Call.</div><div class="p tags pmarker" data-element="p" contenteditable="true" data-tektur-editor-id="5d0b81c4-df87-4a42-a02f-4d2932f453da">Zu Beginn der Streaming-Aktion kann man sich auf konventionelle Art und Weise Teilbäume, die nicht so performanzlastig aufgebaut werden, 
in einer Variablen abspeichern und im Verlauf der Streaming-Verarbeitung z.B. für einen Vergleich auswerten.</div><div class="p tags pmarker" data-element="p" contenteditable="true" data-tektur-editor-id="4637a9cf-e467-439f-8527-e5119b23ec5e">Ein einfaches Streaming Stylesheet könnte z.B. so aussehen:</div><div class="pre tags" data-tektur-editor-id="623dcff3-7b8e-4d24-aee2-a8baa1aa060d"><div class="pre-content pmarker show_menu tags" data-element="pre" contenteditable="true" data-tektur-editor-id="1894ddd8-f58e-467f-92af-f4632c87acc3">&#x3C;xsl:stylesheet version="3.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  exclude-result-prefixes="#all"&#x3E;
  
  &#x3C;xsl:output method="xml" indent="yes"/&#x3E;
  
  &#x3C;xsl:mode on-no-match="shallow-copy" use-accumulators="entry-count" streamable="true"/&#x3E;
  
  &#x3C;xsl:accumulator name="entry-count" as="xs:integer" initial-value="0" 
                   streamable="yes"&#x3E;
    &#x3C;xsl:accumulator-rule match="entry" select="$value + 1"/&#x3E;
  &#x3C;/xsl:accumulator&#x3E;
  
  &#x3C;xsl:template match="/"&#x3E;
    &#x3C;result&#x3E;
      &#x3C;xsl:apply-templates/&#x3E;
      &#x3C;count&#x3E;
        &#x3C;xsl:value-of select="accumulator-after('entry-count')"/&#x3E; 
      &#x3C;/count&#x3E;
    &#x3C;/result&#x3E;
  &#x3C;/xsl:template&#x3E;
  
&#x3C;/xsl:stylesheet&#x3E;</div></div><div class="text pmarker tags" data-element="p" contenteditable="true" data-tektur-editor-id="3764e97e-e287-44b1-889b-ebac0b338db8">Diese Stylesheet hat einige Besonderheiten:</div><div class="p tags pmarker" data-element="p" contenteditable="true" data-tektur-editor-id="5161be80-9054-4e27-bdb9-afe549d869d8">Zum einen wird darin ein Default-Modus deklariert, der jeden Knoten der Eingabeinstanz über
eine implizite Identity-Transformation (shallow-copy)[[fn:https://www.saxonica.com/html/documentation/xsl-elements/mode.html]]
in die Ausgabeinstanz kopiert.</div><div class="p tags pmarker" data-element="p" contenteditable="true" data-tektur-editor-id="a4eb7297-1b50-4a17-8a9b-273e83caf8a1">Auf herkömmlichem Weg würde man dafür ein Templates wie dieses verwenden:</div><div class="pre tags" data-tektur-editor-id="7f02db61-0b1a-41af-b695-5f8f03109988"><div class="pre-content pmarker show_menu tags placeholder" data-element="pre" contenteditable="true" data-tektur-editor-id="7882b627-67b9-4552-a5b0-d64b300ae126">&#x3C;xsl:template match="node()|@*"
  &#x3C;xsl:copy&#x3E;
    &#x3C;xsl:apply-templates select="node()|@*"/&#x3E;
  &#x3C;/xsl:copy&#x3E;
&#x3C;/xsl:template&#x3E;</div></div><div class="text pmarker tags" data-element="p" contenteditable="true" data-tektur-editor-id="0f34a508-bc49-418c-a746-61419eedc694">Zum anderen wird ein Akkumulator verwendet. Normalerweise gibt es in XSLT keine Variablen,
sondern nur Konstanten, so wie das auch bei funktionalen Programmiersprachen der Fall ist.</div><div class="p tags pmarker" data-element="p" contenteditable="true" data-tektur-editor-id="c28f2aee-9249-4232-bc70-078598c7e46d">Es gab zwar schon länger eine Saxon-Erweiterung, die die mehrmalige Zuweisung eines Wertes
an eine Variable erlaubte, im Normallfall braucht man diese Eigenschaft aber nicht.</div><div class="p tags pmarker" data-element="p" contenteditable="true" data-tektur-editor-id="d0f8166c-e563-4cc0-98e7-8c7b1e258f7b">Ber der Verarbeitung sehr großer Datemengen, ist es aber unumgänglich, denn sonst
würde der Laufzeitstapel schnell an seine Grenzen gelangen.</div><div class="p tags pmarker" data-element="p" contenteditable="true" data-tektur-editor-id="969d6726-963d-4f29-b60e-3c363fbf5389">Ein Akkumulator akkumuliert Werte, wie der Name schon sagt. Das können atomare Typen sein,
wie im obigen Beispiel, aber auch Datenstrukturen können aufgebaut werden, wie 
bspw. das Abspeichern des gerade prozessierten Teilbaums in einem Dictionary zur 
späteren Auswertung bzw. Gruppierung der Key-Elemente.</div><div class="p tags pmarker" data-element="p" contenteditable="true" data-tektur-editor-id="8742b2de-1df8-4c8e-95d3-d62fdba55715">Auch im Akkumulator muss das streamable="yes" Property gesetzt sein, wenn er im 
Streaming-Modus arbeiten soll. In diesem Modus kann der Akkumulatorwert erst ausgelesen werden,
wenn der untersuchte Baum vollständig durchlaufen wurde.</div><div class="p tags pmarker placeholder" data-element="p" contenteditable="true" data-tektur-editor-id="3eec280d-6179-4f13-8bdc-971fcf6e9675">Um die Unterschiede zum "normalen" XSLT Betrieb festzustellen, können im obigen Beispiel 
einige offensichtlich korrekte Änderungen vorgenommen werden, die der Streaming 
Prozessor allerdings nicht akzeptiert.</div></div></div></div>