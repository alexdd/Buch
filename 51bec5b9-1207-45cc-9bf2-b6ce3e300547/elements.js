[{"id":"40515442-a67d-49f4-9945-0f9d227bd97e","type":"para","text":"XSLT Akkumulator","title":" XSLT Akkumulator "},{"id":"6c3d953a-91cc-4be7-bf9d-65d3c6d6c75fd6e21","type":"para","text":"Ein einfaches Streaming Stylesheet könnte z.B. so aussehen:","title":" XSLT Akkumulator "},{"id":"6f3f4202-eb15-429d-8920-07ba60ccfb82d7e6","type":"code","text":"<xsl:stylesheet version=\"3.0\" xmlns:xsl=\"http:\/\/www.w3.org\/1999\/XSL\/Transform\" xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\" exclude-result-prefixes=\"#all\"> <xsl:output method=\"xml\" indent=\"yes\"\/> <xsl:mode on-no-match=\"shallow-copy\" use-accumulators=\"entry-count\" streamable=\"true\"\/> <xsl:accumulator name=\"entry-count\" as=\"xs:integer\" initial-value=\"0\" streamable=\"yes\"> <xsl:accumulator-rule match=\"entry\" select=\"$value + 1\"\/> <\/xsl:accumulator> <xsl:template match=\"\/\"> <result> <xsl:apply-templates\/> <count> <xsl:value-of select=\"accumulator-after('entry-count')\"\/> <\/count> <\/result> <\/xsl:template> <\/xsl:stylesheet>","title":" XSLT Akkumulator "},{"id":"4ba7c650-d5a0-489c-9392-3ab548afa421d6e25","type":"para","text":"Diese Stylesheet hat einige Besonderheiten:","title":" XSLT Akkumulator "},{"id":"06f1d8c6-03dd-4fa3-847b-4554e944f361d6e27","type":"para","text":"Zum einen wird darin ein Default-Modus deklariert, der jeden Knoten der Eingabeinstanz über eine implizite Identity-Transformation (shallow-copy) in die Ausgabeinstanz kopiert.","title":" XSLT Akkumulator "},{"id":"cda2834b-a464-49e5-9b3b-e8880252433cd6e29","type":"para","text":"Auf herkömmlichem Weg würde man dafür ein Templates wie dieses verwenden:","title":" XSLT Akkumulator "},{"id":"f29b9b53-a53a-47e7-9f4b-638ef53b8370d7e14","type":"code","text":"<xsl:template match=\"node()|@*\" <xsl:copy> <xsl:apply-templates select=\"node()|@*\"\/> <\/xsl:copy> <\/xsl:template>","title":" XSLT Akkumulator "},{"id":"6deb7053-43b9-437d-8ce4-ec81a69a7795d6e34","type":"para","text":"Zum anderen wird ein Akkumulator verwendet. Normalerweise gibt es in XSLT keine Variablen, sondern nur Konstanten, so wie das auch bei funktionalen Programmiersprachen der Fall ist.","title":" XSLT Akkumulator "},{"id":"bce045c6-46f1-4745-8326-56beff21e266d6e36","type":"para","text":"Es gab zwar schon länger eine Saxon-Erweiterung, die die mehrmalige Zuweisung eines Wertes an eine Variable erlaubte, im Normallfall braucht man diese Eigenschaft aber nicht.","title":" XSLT Akkumulator "},{"id":"586338d8-49fa-4ddc-b715-99f9688ecd25d6e38","type":"para","text":"Ber der Verarbeitung sehr großer Datemengen, ist es aber unumgänglich, denn sonst würde der Laufzeitstapel schnell an seine Grenzen gelangen.","title":" XSLT Akkumulator "},{"id":"4a5b2945-71be-4b5c-be7f-2e33cd717a4cd6e40","type":"para","text":"Ein Akkumulator akkumuliert Werte, wie der Name schon sagt. Das können atomare Typen sein, wie im obigen Beispiel, aber auch Datenstrukturen können aufgebaut werden, wie bspw. das Abspeichern des gerade prozessierten Teilbaums in einem Dictionary zur späteren Auswertung bzw. Gruppierung der Key-Elemente.","title":" XSLT Akkumulator "},{"id":"825af8ca-d2ab-4357-ba6b-bbf4863f201fd6e42","type":"para","text":"Auch im Akkumulator muss das Property gesetzt sein, wenn er im Streaming-Modus arbeiten soll. In diesem Modus kann der Akkumulatorwert erst ausgelesen werden, wenn der untersuchte Baum vollständig durchlaufen wurde.","title":" XSLT Akkumulator "},{"id":"8d27d621-4d12-4d40-a59e-8d58c45439a5d6e44","type":"para","text":"Um die Unterschiede zum \"normalen\" XSLT Betrieb festzustellen, können im obigen Beispiel einige offensichtlich korrekte Änderungen vorgenommen werden, die der Streaming Prozessor allerdings nicht akzeptiert.","title":" XSLT Akkumulator "},{"id":"c667f9ed-e8a5-4976-906f-3d9b47b589d3d7e29","type":"code","text":"Cannot call accumulator-after except during the post-descent phase of a streaming template","title":" XSLT Akkumulator "},{"id":"c9a77197-237e-49fd-80d3-18a443700c33d6e59","type":"para","text":"Diese Fehlermeldung erscheint, wenn man den Call entfernt. Der Akkumulator wird also nur befüllt, wenn der Baum auch explizit durchlaufen wurde. Dieser Durchlauf kann auch ein reines Kopieren sein, bspw. kann man den Call auch durch ein","title":" XSLT Akkumulator "},{"id":"d0aa03b6-3c6e-4577-a3dc-972ec362e73cd7e33","type":"code","text":"<xsl:copy-of select=\".\"\/>","title":" XSLT Akkumulator "},{"id":"bd5669e8-e0e9-41d0-8854-f9c76aa6d3a3d6e63","type":"para","text":"ersetzen, was gleichbedeutend mit der Mode Einstellung","title":" XSLT Akkumulator "},{"id":"a3fb7034-edcc-40d6-b201-b745f28896c6d7e37","type":"code","text":"on-no-match=\"deep-copy\"","title":" XSLT Akkumulator "},{"id":"073cb9ea-9bed-41e8-ba73-b3cef15a5708d6e68","type":"para","text":"wäre. Wie man sieht hat sich in XSLT 3.0 viel bzgl. der Handhabung verschiedener Verarbeitungsmodi getan. Anstatt Default-Match Regeln zu schreiben, kann man ganz oben am Stylesheet Modus Properties setzen, die den Baumdurchlauf auf verschiedene Arten realisieren.","title":" XSLT Akkumulator "},{"id":"29146b97-98e0-448f-8414-d8a9ee82e847d6e70","type":"para","text":"Die Verarbeitung großer Datenmenden ist aber mit Streaming etwas tricky und es sollte geprüft werden, ob ggf. konventionelles Performanz-optimiertes XSLT für den Answendungsfall ausreichen würde.","title":" XSLT Akkumulator "}]