<?xml version="1.0" encoding="UTF-8"?><elements><element id="40515442-a67d-49f4-9945-0f9d227bd97e">XSLT Akkumulator </element><element id="6c3d953a-91cc-4be7-bf9d-65d3c6d6c75fd6e21">Ein einfaches Streaming Stylesheet könnte z.B. so aussehen:</element><element id="4ba7c650-d5a0-489c-9392-3ab548afa421d6e25">Diese Stylesheet hat einige Besonderheiten:</element><element id="06f1d8c6-03dd-4fa3-847b-4554e944f361d6e27">Zum einen wird darin ein Default-Modus deklariert, der jeden Knoten der Eingabeinstanz über\neine implizite Identity-Transformation (shallow-copy)in die Ausgabeinstanz kopiert.</element><element id="cda2834b-a464-49e5-9b3b-e8880252433cd6e29">Auf herkömmlichem Weg würde man dafür ein Templates wie dieses verwenden:</element><element id="6deb7053-43b9-437d-8ce4-ec81a69a7795d6e34">Zum anderen wird ein Akkumulator verwendet. Normalerweise gibt es in XSLT keine Variablen,\nsondern nur Konstanten, so wie das auch bei funktionalen Programmiersprachen der Fall ist.</element><element id="bce045c6-46f1-4745-8326-56beff21e266d6e36">Es gab zwar schon länger eine Saxon-Erweiterung, die die mehrmalige Zuweisung eines Wertes\nan eine Variable erlaubte, im Normallfall braucht man diese Eigenschaft aber nicht.</element><element id="586338d8-49fa-4ddc-b715-99f9688ecd25d6e38">Ber der Verarbeitung sehr großer Datemengen, ist es aber unumgänglich, denn sonst\nwürde der Laufzeitstapel schnell an seine Grenzen gelangen.</element><element id="4a5b2945-71be-4b5c-be7f-2e33cd717a4cd6e40">Ein Akkumulator akkumuliert Werte, wie der Name schon sagt. Das können atomare Typen sein,\nwie im obigen Beispiel, aber auch Datenstrukturen können aufgebaut werden, wie \nbspw. das Abspeichern des gerade prozessierten Teilbaums in einem Dictionary zur \nspäteren Auswertung bzw. Gruppierung der Key-Elemente.</element><element id="825af8ca-d2ab-4357-ba6b-bbf4863f201fd6e42">Auch im Akkumulator muss das  Property gesetzt sein, wenn er im \nStreaming-Modus arbeiten soll. In diesem Modus kann der Akkumulatorwert erst ausgelesen werden,\nwenn der untersuchte Baum vollständig durchlaufen wurde.</element><element id="8d27d621-4d12-4d40-a59e-8d58c45439a5d6e44">Um die Unterschiede zum \"normalen\" XSLT Betrieb festzustellen, können im obigen Beispiel \neinige offensichtlich korrekte Änderungen vorgenommen werden, die der Streaming \nProzessor allerdings nicht akzeptiert.</element><element id="c9a77197-237e-49fd-80d3-18a443700c33d6e59">Diese Fehlermeldung erscheint, wenn man den  Call entfernt. Der Akkumulator\nwird also nur befüllt, wenn der Baum auch explizit durchlaufen wurde. Dieser Durchlauf \nkann auch ein reines Kopieren sein, bspw. kann man den  Call auch durch ein</element><element id="bd5669e8-e0e9-41d0-8854-f9c76aa6d3a3d6e63">ersetzen, was gleichbedeutend mit der Mode Einstellung</element><element id="073cb9ea-9bed-41e8-ba73-b3cef15a5708d6e68">wäre. Wie man sieht hat sich in XSLT 3.0 viel bzgl. der Handhabung verschiedener\nVerarbeitungsmodi getan. Anstatt Default-Match Regeln zu schreiben, kann man ganz oben\nam Stylesheet Modus Properties setzen, die den Baumdurchlauf auf verschiedene\nArten realisieren.</element><element id="29146b97-98e0-448f-8414-d8a9ee82e847d6e70">Die Verarbeitung großer Datenmenden ist aber mit Streaming etwas tricky und es sollte geprüft \nwerden, ob ggf. konventionelles Performanz-optimiertes XSLT für den Answendungsfall ausreichen\nwürde.</element></elements>