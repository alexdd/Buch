<?xml version="1.0" encoding="UTF-8"?><elements><element id="40515442-a67d-49f4-9945-0f9d227bd97e" type="para">XSLT Akkumulator</element><element id="6c3d953a-91cc-4be7-bf9d-65d3c6d6c75fd6e21" type="para">Ein einfaches Streaming Stylesheet könnte z.B. so aussehen:</element><element id="8fdeb2c3-c71a-4d8c-9bf0-79b569778900d7e6" type="code">&lt;xsl:stylesheet version=\"3.0\"xmlns:xsl=\"http:\/\/www.w3.org\/1999\/XSL\/Transform\"xmlns:xs=\"http:\/\/www.w3.org\/2001\/XMLSchema\"exclude-result-prefixes=\"#all\"&gt; &lt;xsl:output method=\"xml\"indent=\"yes\"\/&gt; &lt;xsl:mode on-no-match=\"shallow-copy\"use-accumulators=\"entry-count\"streamable=\"true\"\/&gt; &lt;xsl:accumulator name=\"entry-count\"as=\"xs:integer\"initial-value=\"0\"streamable=\"yes\"&gt; &lt;xsl:accumulator-rule match=\"entry\"select=\"$value + 1\"\/&gt; &lt;\/xsl:accumulator&gt; &lt;xsl:template match=\"\/\"&gt; &lt;result&gt; &lt;xsl:apply-templates\/&gt; &lt;count&gt; &lt;xsl:value-of select=\"accumulator-after('entry-count')\"\/&gt; &lt;\/count&gt; &lt;\/result&gt; &lt;\/xsl:template&gt; &lt;\/xsl:stylesheet&gt;</element><element id="4ba7c650-d5a0-489c-9392-3ab548afa421d6e25" type="para">Diese Stylesheet hat einige Besonderheiten:</element><element id="06f1d8c6-03dd-4fa3-847b-4554e944f361d6e27" type="para">Zum einen wird darin ein Default-Modus deklariert, der jeden Knoten der Eingabeinstanz über eine impliziteIdentity-Transformation (shallow-copy)in die Ausgabeinstanz kopiert.</element><element id="cda2834b-a464-49e5-9b3b-e8880252433cd6e29" type="para">Auf herkömmlichem Weg würde man dafür ein Templates wie dieses verwenden:</element><element id="8dd31edf-81b1-4327-87f7-d08fbaff4d5ed7e14" type="code">&lt;xsl:template match=\"node()|@*\"&lt;xsl:copy&gt; &lt;xsl:apply-templates select=\"node()|@*\"\/&gt; &lt;\/xsl:copy&gt; &lt;\/xsl:template&gt;</element><element id="6deb7053-43b9-437d-8ce4-ec81a69a7795d6e34" type="para">Zum anderen wird ein Akkumulatorverwendet. Normalerweise gibt es in XSLT keine Variablen, sondern nur Konstanten, so wie das auch bei funktionalen Programmiersprachen der Fall ist.</element><element id="bce045c6-46f1-4745-8326-56beff21e266d6e36" type="para">Es gab zwar schon länger eine Saxon-Erweiterung, die die mehrmalige Zuweisung eines Wertes an eine Variable erlaubte, im Normallfall braucht man diese Eigenschaft aber nicht.</element><element id="586338d8-49fa-4ddc-b715-99f9688ecd25d6e38" type="para">Ber der Verarbeitung sehr großer Datemengen, ist es aber unumgänglich, denn sonst würde der Laufzeitstapel schnell an seine Grenzen gelangen.</element><element id="4a5b2945-71be-4b5c-be7f-2e33cd717a4cd6e40" type="para">Ein Akkumulator akkumuliert Werte, wie der Name schon sagt. Das können atomare Typen sein, wie im obigen Beispiel, aber auch Datenstrukturen können aufgebaut werden, wie bspw. das Abspeichern des gerade prozessierten Teilbaums in einem Dictionary zur späteren Auswertung bzw. Gruppierung der Key-Elemente.</element><element id="825af8ca-d2ab-4357-ba6b-bbf4863f201fd6e42" type="para">Auch im Akkumulator muss dasProperty gesetzt sein, wenn er im Streaming-Modus arbeiten soll. In diesem Modus kann der Akkumulatorwert erst ausgelesen werden, wenn der untersuchte Baum vollständig durchlaufen wurde.</element><element id="8d27d621-4d12-4d40-a59e-8d58c45439a5d6e44" type="para">Um die Unterschiede zum\"normalen\"XSLT Betrieb festzustellen, können im obigen Beispiel einige offensichtlich korrekte Änderungen vorgenommen werden, die der Streaming Prozessor allerdings nicht akzeptiert.</element><element id="25b3c330-d498-4e23-82be-082249b87e1bd7e29" type="code">Cannot call accumulator-after except during the post-descent phase of a streaming template</element><element id="c9a77197-237e-49fd-80d3-18a443700c33d6e59" type="para">Diese Fehlermeldung erscheint, wenn man denCall entfernt. Der Akkumulator wird also nur befüllt, wenn der Baum auch explizit durchlaufen wurde. Dieser Durchlauf kann auch ein reines Kopieren sein, bspw. kann man denCall auch durch ein</element><element id="25c1ddef-c97f-45e6-a343-67453eff94eed7e33" type="code">&lt;xsl:copy-of select=\".\"\/&gt;</element><element id="bd5669e8-e0e9-41d0-8854-f9c76aa6d3a3d6e63" type="para">ersetzen, was gleichbedeutend mit der Mode Einstellung</element><element id="098a715e-e1a5-49fc-a47e-cd846b81f95cd7e37" type="code">on-no-match=\"deep-copy\"</element><element id="073cb9ea-9bed-41e8-ba73-b3cef15a5708d6e68" type="para">wäre. Wie man sieht hat sich in XSLT 3.0 viel bzgl. der Handhabung verschiedener Verarbeitungsmodi getan. Anstatt Default-Match Regeln zu schreiben, kann man ganz oben am Stylesheet Modus Properties setzen, die den Baumdurchlauf auf verschiedene Arten realisieren.</element><element id="29146b97-98e0-448f-8414-d8a9ee82e847d6e70" type="para">Die Verarbeitung großer Datenmenden ist aber mit Streaming etwas tricky und es sollte geprüft werden, ob ggf. konventionelles Performanz-optimiertes XSLT für den Answendungsfall ausreichen würde.</element></elements>