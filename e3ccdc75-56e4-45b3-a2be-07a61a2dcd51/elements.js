[{"id":"6e53fba3-c83c-4a92-8cea-170e5781324c","type":"para","text":"Identifikation mit","title":" Identifikation mit [[ code:generate-id() ]]  "},{"id":"3cd96c4e-4783-468f-a32c-5a009e3cd115","type":"para","text":"Die Funktion gibt es in XSLT schon immer. Mit ihr kann eine Prüfsumme eines Knotens im Baum generiert werden.","title":" Identifikation mit [[ code:generate-id() ]]  "},{"id":"ec777147-e5f9-4922-90d7-da6edb3ba4e4d6e6","type":"para","text":"Das funktioniert natürlich nur, wenn man bei der Auswertung dieses Wertes nicht den Kontext wechselt. D.h. z.B. dass ein Knoten in einem Baum, der in einer Variablen gespeichert ist, eine andere Prüfsumme bekommt, als derselbe Knoten im Kontext-Baum.","title":" Identifikation mit [[ code:generate-id() ]]  "},{"id":"fc5861f4-cba9-4568-8ebe-a70d04f46a66d6e9","type":"para","text":"Beispiel Stückliste","title":" Identifikation mit [[ code:generate-id() ]]  "},{"id":"f1a60882-448a-4f9f-a10b-0b54ef3aa35dd6e10","type":"para","text":"Ein Anwendungszenario wäre bspw. die Generierung einer Target-ID für ein Bauteil in einer Stückliste. Das Bauteil ist nur einmal im System erfasst, hat also eine eindeutige ID, soll aber an mehreren Stellen in die Ausgabe (Eine Dokumentation für eine Maschine) generiert werden.","title":" Identifikation mit [[ code:generate-id() ]]  "},{"id":"8168234a-94fe-432e-900c-567faf2a8552d6e12","type":"para","text":"Die Id an einem Element würde somit mehrfach in die XML Eingabe für einen XSL-FO Prozessor erscheinen und ist für Referenzen unbrauchbar geworden. Deshalb ist es ratsam beim Rendern der Bauteile eine neue Id zu vergeben, das kann z.B. mit den folgenden Templates (vereinfacht) passieren:","title":" Identifikation mit [[ code:generate-id() ]]  "},{"id":"3554af39-a8d1-461b-b1dd-26fc1c984213d7e15","type":"code","text":"<xsl:key name=\"parts\" match=\"part\" use=\"@id\"\/> <xsl:template match=“part” mode=“content\"> <!-- Ausgabe des Bauteils im Content Bereich --> <fo:block id=\"{generate-id()}\"> <fo:external-graphic xsl:use-attribute-sets=\"part.img\"\/> <\/fo:block> <\/xsl:template> <xsl:template match=“part” mode=“part-list\"> <!-- Ausgabe einer Liste mit allen Verweisen an unterschiedicher Stelle --> <fo:block> <xsl:for-each select=\"key('parts',@id)\"> <fo:page-number-citation ref-id=\"{generate-id()}\"\/> <\/xsl:for-each> <\/fo:block> <\/xsl:template>","title":" Identifikation mit [[ code:generate-id() ]]  "},{"id":"90386d0e-7162-471c-8c09-8bb00da36da5d6e17","type":"para","text":"Beispiel Mantel Dokument","title":" Identifikation mit [[ code:generate-id() ]]  "},{"id":"b77784f8-4fa6-4519-b20d-347ba62d7e8bd6e18","type":"para","text":"Im Bereich EDI Datenaustausch werden große XML Dateien versendet, die man auf einzelne Transmissions aufsplitten will, um sie in einer XML Datenbank abspeichern zu können. Die Struktur einer Datenübertragung könnte folgendermassen aussehen:","title":" Identifikation mit [[ code:generate-id() ]]  "},{"id":"1f7fbd3e-ab8a-44a2-9bb9-b1f6e93be1a4d7e25","type":"code","text":"WRAPPER1 SEQUENZ1 SEQUENZ2 SEQUENZ3 WRAPPER2 SEQUENZ1 SEQUENZ2 SEQUENZ3 SEQUENZ4 WRAPPER3 SEQUENZ1 SEQUENZ2 CONTENT DATA1 DATA2 DATA3 DATA4 DATA5 CONTENT DATA1 DATA2 DATA3 DATA4 DATA5 WRAPPER4 SEQUENZ1 CONTENT DATA1 DATA2 DATA3 DATA4 DATA5 [...]","title":" Identifikation mit [[ code:generate-id() ]]  "},{"id":"30f17d4c-717b-4778-ad02-1d6a5f41c443d6e22","type":"para","text":"Jedes einzelne Element soll nun einen Mantel erhalten und separat in einer Datei abgelegt werden. Der \"Umschlag\" soll dabei alle Elemente des Rahmens der Transmission erhalten. Also alles auf der Descendant-Achse bis zum Element , ausserdem noch die Elemente und , sowie das Element mit Kind . Ohne groß auf die Performanz zu achten, könnte das recht einfach so realisiert werden:","title":" Identifikation mit [[ code:generate-id() ]]  "},{"id":"c5aec956-9110-4e4c-9e69-cb60db10b9e4d7e29","type":"code","text":"<xsl:stylesheet xmlns:xsl=\"http:\/\/www.w3.org\/1999\/XSL\/Transform\" version=\"2.0\"> <xsl:output method=\"xml\" indent=\"yes\"\/> <xsl:strip-space elements=\"*\"\/> <xsl:template match=\"\/\"> <xsl:apply-templates select=\"\/WRAPPER1\/WRAPPER2\/WRAPPER3\/CONTENT\" mode=\"umschlag\"\/> <\/xsl:template> <xsl:template match=\"CONTENT\" mode=\"umschlag\"> <xsl:result-document href=\"{concat(@id,'.xml')}\"> <umschlag> <metadaten><!-- einige Metadaten --><\/env:metadata> <nutzdaten> <xsl:apply-templates select=\"ancestor::WRAPPER1\"> <xsl:with-param name=\"this-id\" select=\"generate-id()\" tunnel=\"yes\"\/> <\/xsl:apply-templates> <\/nutzdaten> <\/umschlag> <\/xsl:result-document> <\/xsl:template> <xsl:template match=\"node()|@*\"> <xsl:copy> <xsl:apply-templates select=\"node()|@*\"\/> <\/xsl:copy> <\/xsl:template> <xsl:template match=\"CONTENT\"> <xsl:param name=\"this-element\" tunnel=\"yes\"\/> <xsl:if test=\"$this-id = generate-id()\"> <xsl:copy> <xsl:apply-templates select=\"node()|@*\"\/> <\/xsl:copy> <\/xsl:if> <\/xsl:template> <\/xsl:stylesheet>","title":" Identifikation mit [[ code:generate-id() ]]  "},{"id":"a7ab8655-d9eb-4343-bebf-c4d8850cb2c6d6e26","type":"para","text":"Im rekursiven Abstieg wird im Modus \"umschlag\" jedes Element selektiert und in einen Umschlag verpackt. Der eigentlich Inhalt des Umschlags wird generiert, indem der gesamte XML Baum über die Standard-Kopierregel in das Element gesetzt wird. Dabei wird aber nur derjenige Abschnitt evaluiert, der - zu der als Parameter übergebenen - generierten Id passt.","title":" Identifikation mit [[ code:generate-id() ]]  "}]