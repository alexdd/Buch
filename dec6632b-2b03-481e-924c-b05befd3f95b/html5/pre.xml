<?xml version="1.0" encoding="utf-8"?>
<document>
   <title xmlns:tektur="http://www.stylesheet-entwicklung.de">Entwicklerhandbuch</title>
   <meta xmlns:tektur="http://www.stylesheet-entwicklung.de">
      <owner>alex</owner>
      <date-of-creation>Tue Dec 25 2018 12:56:30 </date-of-creation>
      <date-of-last-change>Thu Mar 28 2019 14:46:23 </date-of-last-change>
      <language>de-DE</language>
      <status>201</status>
      <description>Short Description</description>
      <logo-image>././client/data/dec6632b-2b03-481e-924c-b05befd3f95b/logo.png</logo-image>
      <cover-image>././client/data/dec6632b-2b03-481e-924c-b05befd3f95b/cover.png</cover-image>
      <main-title>XML Hands On</main-title>
      <subtitle>XSLT - XQuery - MarkLogic</subtitle>
      <cover-text>(c) Alex Düsel 2019
Creative Commons Namensnennung-Keine Bearbeitungen 4.0 International Public License
www.github.com/alexdd/Buch</cover-text>
      <structure>
         <format>UNDEFINED</format>
      </structure>
      <design>
         <layout>UNDEFINED</layout>
         <paper-format>UNDEFINED</paper-format>
         <page-margin>UNDEFINED</page-margin>
         <spaces>UNDEFINED</spaces>
         <header>UNDEFINED</header>
         <footer>UNDEFINED</footer>
         <look-and-feel>UNDEFINED</look-and-feel>
         <table-layout>UNDEFINED</table-layout>
      </design>
   </meta>
   <chapter hyphenation="yes" chapterpage="no" id="c15a8d5c-03bc-4ee9-a04a-a123e0ce5d88"
            ismodule="no">
      
         <title>
            <title id="67b2fea2-88ac-4cbc-9763-0e31cf89b469">Intro</title>
         </title>
         
            <figure pdfwidth="margin">
               <img src="./client/data/c15a8d5c-03bc-4ee9-a04a-a123e0ce5d88/dita-logo.jpg"/>
            </figure>
            <p>Dieses Buch wurde mit Tektur CCMS erstellt. Tektur ist ein einfach zu bedienender kollaborativer Editor um <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
              address="https://de.wikipedia.org/wiki/Darwin_Information_Typing_Architecture">DITA</url> Inhalte erstellen, als PDF ausgeben und pflegen zu können. Die Eingabe erfolgt dabei per <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
              address="https://de.wikipedia.org/wiki/WYSIWYG">WYSIWYG</url> mit geführter Benutzerinteraktion. Die Inhalte werden als einzelne Topics verwaltet, die in verschiedenen Maps referenziert werden können; Stichwort: <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
              address="https://en.wikipedia.org/wiki/Topic-based_authoring">Topic Based Authoring</url>.</p>
            <p>Sonstige Features: Rechte- und Rollensystem, Versionskontrolle, konfigurerierbarer Workflow mit Review &amp; Approval Fuktionen. Auf dem <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
              address="http://www.tekturcms.de">Entwicklerblog</url> kann man sich über den Fortschritt informieren.</p>
            <note>
               <consequence>
                  <p>Dieses Buch ist <b>WORK IN PROGRESS</b> und dient in erster Linie als Test für Tektur CCMS. Der Feinschliff kommt noch! Momentan schreibe ich alles was mir irgendwie interessant erscheint - je nach zeitlicher Möglichkeit mehr oder weniger umfangreich - auf und binde die Topics in eine Map ein, um ein PDF erzeugen zu können.</p>
                  <p>Wie schliesslich Struktur und Inhalt genau aussehen sollen, werde ich mir zu einem späteren Zeitpunkt noch genau überlegen :-]</p>
               </consequence>
            </note>
         
      
   </chapter>
   <chapter hyphenation="yes" chapterpage="no" id="792c9845-7c63-4a18-8aee-1878763200b5"
            ismodule="no">
      
         <title>
            <title id="a01d7a84-023f-4c62-ab06-1e8e8b069bed">Anwendungsgebiete</title>
         </title>
         
            <p>
               <b>XML,</b>
               <b>XSLT</b>, <b>XPATH</b>, <b>XSL-FO</b> und <b>XQuery</b> sind Techniken um baumstrukturierte Daten - im Vergleich zu relationalen Daten - aus verschiedenen Quellen ineinader zu überführen, abzuspeichern, zu versenden, darzustellen und auszuwerten.</p>
            <p>Vom Aussehen her sind XML Daten im Prinzip Textdaten. Sie können sehr einfach mit einem Texteditor erstellt werden. Im Gegensatz zu Multimedia-Daten sind keine komplexen Tools, wie z.B. ein Grafikeditor, erforderlich.</p>
            <p>Auch relationale Daten können in Form von Tabellen, als Excel Tabelle oder bspw. als kommaseparierte Textdatei, aus einem System ausgespult und weiterverarbeitet werden. XML erlaubt es jedoch die Daten semantisch auszuzeichnen. Das geschieht durch das Klammern semantisch zusammengehöriger Elemente mittels Klammer-Tags und weiterer Kategorisierung dieser Informationseinheiten mittels weiterer Properties (Attribute) an diesen Tags. Durch das Verschachteln dieser geklammerten Komponenten entsteht ein Baum, der die Hierarchische Ordnung der Daten widerspiegelt.</p>
            <p>Diese Baumstrukturen sind maschinell lesbar und die Daten können, bevor sie von einem Versender zu einem Empfänger gehen, mittels eines automatischen Prozesses validiert werden. Dabei können sowohl der Inhalt als auch die Syntax anhand von definierten Regeln (Schemas) genau überprüft werden.</p>
            <p>Der XML Standard ist mittlerweile 20 Jahre alt. Zuvor gab es SGML, das zum Beispiel auch nicht abgeschlossene Tags erlaubt.</p>
            <p>Der Übergang von SGML zu XML hat die Sache ein bisschen vereinfacht, eine weitere Vereinfachung brachte JSON als Standard. JSON wird gerne im Webbereich eingesetzt um baumstrukturierte Daten auszuzeichnen. JSON ist jedoch nicht so gut maschinenlesbar und es gibt noch nicht so viele Werkzeuge wie z.B. Code Editoren dafür.</p>
            <p>Folgend eine kurze Erläuterung zu den eingangs erwähnten Schlüsselwörtern:</p>
            <ul>
               <li>
                  <p>
                     <b>XML</b> ist das Datenformat. Auf XML arbeiten die anderen Technologien. XML ist immer Input für diese Tools.</p>
               </li>
               <li>
                  <p>
                     <b>XSLT</b> transformiert eine XML Instanz in eine andere. Plain Text ist eine Aneinanderreihung von Text Knoten</p>
               </li>
               <li>
                  <p>
                     <b>XPATH</b> erlaubt es, bestimmte Knoten in einem XML Dokument über bedingte Pfadausdrücke zu selektieren.</p>
               </li>
               <li>
                  <p>
                     <b>XSL-FO</b> ist eine weitere XML basierte Auszeichnungssprache, die ein XSL-FO Prozessor einlesen kann, um daraus z.B. ein PDF zu generieren. </p>
               </li>
               <li>
                  <p>
                     <b>XQuery</b> ist eine Abfragesprache ählich zu SQL, jedoch werden damit nicht relationale Daten abgefragt sondern baumstrukturierte.</p>
               </li>
            </ul>
            <p/>
         
      
      <chapter hyphenation="yes" chapterpage="no" id="a264856d-c5d5-4d7b-993f-421bf222db76"
               ismodule="no">
         
            <title>
               <title id="1ea26780-291c-470f-9559-616cfb744574">XSLT - die Programmiersprache im XML Bereich</title>
            </title>
            
               <p>Ausserhalb der XML Verarbeitung hat XSLT keinen Stellenwert. Im TIOBE Index von 2003 rangierte XSLT einmal auf Platz 60 an letzter Stelle der <url xmlns:tektur="http://www.stylesheet-entwicklung.de" address="">Liste</url>.</p>
               <p>Im Bereich XML würde aber ohne XSLT nicht viel gehen. Es gibt einige exotische Anwendungsgebiete in denen XML effizient 
mit <b>LISP</b> Dialekten verarbeitet wird, bspw. die Verarbeitung von - nach XML konvertierten - <url xmlns:tektur="http://www.stylesheet-entwicklung.de" address="">EDI X12</url> Nachrichten.</p>
               <p>Auch im Bereich Publishing in der Luftfahrt hat sich SGML als Vorreiter von XML im <url xmlns:tektur="http://www.stylesheet-entwicklung.de" address="">S1000D Standard</url> wacker gehalten. Hier wird teilweise noch mit proprietären Programmiersprachen, wie Metamorphosis gearbeitet.</p>
               <p>Alternativen zu XSLT finden sich im entsprechendem <url xmlns:tektur="http://www.stylesheet-entwicklung.de" address="">Wikipedia-Artikel</url>.</p>
               <p>Wir konzentrieren uns hier auf XSLT und XSL Stylesheets.</p>
               <p>Beispielsweise werden die Autohandbücher führender Hersteller mittels XSL gesetzt, deren Eingabedaten aufbereitet und zur Weiterverarbeitung transformiert. Ein paar interessante Stichpunkte:</p>
               <ul>
                  <li>
                     <p>XSLT hat gerade noch den Status "Programmiersprache", weil man damit eine <url xmlns:tektur="http://www.stylesheet-entwicklung.de" address="">Turing Maschine</url> programmieren kann.</p>
                  </li>
                  <li>
                     <p>Mit HTML oder einer Templater Sprache (z.B. JSP) würde das nicht funktionieren.</p>
                  </li>
                  <li>
                     <p>XSLT ist keine imperative Sprache, d.h es werden keine Anweisungen der Reihe nach abgearbeitet, sondern eine deklarative Sprache, d.h für jedes Ereignis (besser gesagt: für jeden durchlaufenen DOM Knoten) wird eine gefundene - und vom Programmierer deklarierte - Regel angewendet.</p>
                  </li>
                  <li>
                     <p>Ausserdem gibt es funktionale Anteile, um bspw. die deklarierten Regeln rekursiv anwenden zu können.</p>
                  </li>
                  <li>
                     <p>T wird oft mit  gleichgesetzt. Aber <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                       address="https://de.wikipedia.org/wiki/XSL_Transformation">XSL</url> ist mehr:</p>
                     <ul>
                        <li>
                           <p>Zum einen kommt noch XPATH hinzu: XPATH erlaubt komplizierte Berechnungen und Selektionen auf den DOM Knoten eines XML Dokuments.</p>
                        </li>
                        <li>
                           <p>Zum anderen ist auch <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                             address="https://www.w3.org/TR/xsl/">XSL-FO</url> Bestandteil der XSL Spezifikation.  Tags sind Anweisungen für einen  Prozessor, der aus einem  Dokument ein PDF Dokument generiert. Es sind auch andere Ausgabe-Formate, wie bspw. RTF möglich.</p>
                        </li>
                     </ul>
                  </li>
               </ul>
            
         
      </chapter>
      <chapter hyphenation="yes" chapterpage="no" id="3c090c4b-2d46-459c-87ba-60a824bf5aa5"
               ismodule="no">
         
            <title>
               <title id="f19c130f-edfe-408f-a9e2-31b53d92bb4c">Aktuelle und vergangene Anwendungen</title>
            </title>
            
               <p>Einige Beispiele - aktuell und aus vergangenen Tagen:</p>
               <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                  id="b8c9093a-7932-46ac-b0d2-4f61bc1e5001d6e6">
                  
                     <title>
                        <title id="ab76273e-04a8-430a-9f91-9a1b68d9c981d6e7">XML Webseiten</title>
                     </title>
                     <p>Einen XSLT Prozessor hat jeder Browser eingebaut. Es gab mal eine Zeit, in der es sehr populär war, Webseiten vom Server als XML auszuliefern. XML erlaubt die semantische Auszeichung des Inhalts, und die strikte Trennung des Inhalts von Layout und Design. Wesentlich besser als dies mit HTML und CSS jemals möglich wäre. U.a. wegen des exzessiven Einsatzes von Javascript (auch inline), hat sich diese Idee nie vollständig durchgesetzt. Schliesslich wurde XHTML spezifiziert und jetzt gibt es HTML5.</p>
                     <p>Betrachten wir das folgende einfache XML Beispiel:</p>
                     <verbatim><color name="green">&lt;?xml</color> version="1.0" encoding="UTF-8"?<color name="green">&gt;</color>
<color name="green">&lt;document&gt;</color>
<color name="green">&lt;title&gt;</color>Das ultimative Zwei-Kapitel Dokument<color name="green">&lt;/title&gt;</color>
  <color name="green">&lt;chapter&gt;</color>
    <color name="green">&lt;title&gt;</color>Kapitel 1<color name="green">&lt;/title&gt;</color>
    <color name="green">&lt;intro&gt;</color>In Kapitel 1 wird kurz gesagt was Sache ist.<color name="green">&lt;/intro&gt;</color>
    <color name="green">&lt;content&gt;</color>Um es kurz zu machen, wie der Hase läuft steht<color name="brown"> in </color>Kapitel 2.<color name="green">&lt;/content&gt;</color>
  <color name="green">&lt;/chapter&gt;</color>
  <color name="green">&lt;chapter&gt;</color>
    <color name="green">&lt;title&gt;</color>Kapitel 2<color name="green">&lt;/title&gt;</color>
    <color name="green">&lt;intro&gt;</color>Hier wird erklärt, wie der Hase läuft.<color name="green">&lt;/intro&gt;</color>
    <color name="green">&lt;content&gt;</color>Im Prinzip ist es ganz einfach.<color name="green">&lt;/content&gt;</color>
  <color name="green">&lt;/chapter&gt;</color>
<color name="green">&lt;/document&gt;</color></verbatim>
                     <p>Ohne XSLT Stylesheet Zuweisung wird der Browser eine Datei mit diesem Inhalt als eingerücktes XML anzeigen - oder die Tags einfach ignorieren und den Textinhalt in einer Zeile darstellen. Fügt man eine <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                    address="https://de.wikipedia.org/wiki/Verarbeitungsanweisung">Processing Instruction</url> am Anfang ein, wird ein XSLT Stylesheet vom Browser herangezogen und vor der Darstellung im Browser wird die so deklarierte XML Transformation ausgeführt:</p>
                     <verbatim><color name="green">&lt;?xml</color> version="1.0" encoding="UTF-8"?<color name="green">&gt;</color>
<color name="green">&lt;?xml-stylesheet</color> type="text/xsl" href="formatiermich.xsl" ?<color name="green">&gt;</color>
<color name="green">&lt;document&gt;</color>
  <color name="green">&lt;title&gt;</color>Das ultimative Zwei-Kapitel Dokument<color name="green">&lt;/title&gt;</color>
  <color name="green">&lt;chapter&gt;</color>
[...]</verbatim>
                     <p>Das XML kann nun im Browser geöffnet werden und alles wird schön formatiert angezeigt:</p>
                     <verbatim><color name="green">&lt;?xml</color> version="1.0" encoding="iso-8859-1"?<color name="green">&gt;</color>
<color name="green">&lt;xsl:stylesheet</color> version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"<color name="green">&gt;</color>

  <color name="green">&lt;xsl:template</color> match="/"<color name="green">&gt;</color>
    <color name="green">&lt;html&gt;</color>
      <color name="green">&lt;xsl:apply-templates/&gt;</color>
    <color name="green">&lt;/html&gt;</color>
  <color name="green">&lt;/xsl:template&gt;</color>

  <color name="green">&lt;xsl:template</color> match="document"<color name="green">&gt;</color>
  <color name="green">&lt;body&gt;</color>
      <color name="green">&lt;xsl:apply-templates/&gt;</color>
    <color name="green">&lt;/body&gt;</color>
  <color name="green">&lt;/xsl:template&gt;</color>

  <color name="green">&lt;xsl:template</color> match="document/title"<color name="green">&gt;</color>     
    <color name="green">&lt;h1&gt;</color>
      <color name="green">&lt;xsl:apply-templates/&gt;</color>
    <color name="green">&lt;/h1&gt;</color>
  <color name="green">&lt;/xsl:template&gt;</color>

  <color name="green">&lt;xsl:template</color> match="chapter"<color name="green">&gt;</color>
    <color name="green">&lt;div</color> class="chapter"<color name="green">&gt;</color>
      <color name="green">&lt;xsl:apply-templates/&gt;</color>
    <color name="green">&lt;/div&gt;</color>
  <color name="green">&lt;/xsl:template&gt;</color>

  <color name="green">&lt;xsl:template</color> match="chapter/title"<color name="green">&gt;</color>
    <color name="green">&lt;h2&gt;</color>
      <color name="green">&lt;xsl:apply-templates/&gt;</color>
    <color name="green">&lt;/h2&gt;</color>
  <color name="green">&lt;/xsl:template&gt;</color>

  <color name="green">&lt;xsl:template</color> match="chapter/intro"<color name="green">&gt;</color>
    <color name="green">&lt;div</color> class="intro"<color name="green">&gt;</color>
      <color name="green">&lt;i&gt;</color><color name="green">&lt;xsl:apply-templates/&gt;</color><color name="green">&lt;/i&gt;</color>      
    <color name="green">&lt;/div&gt;</color>
  <color name="green">&lt;/xsl:template&gt;</color>

  <color name="green">&lt;xsl:template</color> match="chapter/content"<color name="green">&gt;</color>
    <color name="green">&lt;p&gt;</color><color name="green">&lt;xsl:apply-templates/&gt;</color><color name="green">&lt;/p&gt;</color>    
  <color name="green">&lt;/xsl:template&gt;</color>
<color name="green">&lt;/xsl:stylesheet&gt;</color>
</verbatim>
                     <p>Die <b>Processing Instruction</b> hat keinen Einfluss auf den XML Inhalt und wird in einer anderen Eingabeverarbeitung nicht herangezogen.</p>
                  
               </chapter>
               <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                  id="c0c003f5-0b5a-4cf0-84d4-49a4c62c46d0d6e28">
                  
                     <title>
                        <title id="d1a0e576-5434-4f78-a143-0aba397514ddd6e33">Serverseitige Konvertierung</title>
                     </title>
                     <p>Auch eine serverseitige Konvertierung ist gebräuchlich. Ein Beispiel aus vergangenen Tagen - <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                    address="https://de.wikipedia.org/wiki/Wireless_Application_Protocol">WAP-Seiten</url> für unterschiedliche Handy-Modelle.</p>
                     <p>Früher hatten die Handys sehr unterschiedliche Displaygrößen. Handybrowser konnten nicht ausreichend Javascript und die Skalierung der WAP-Seite für das jeweilige Handy passierte nicht im Handy, sondern vor der Auslieferung auf der Serverseite. Dazu wurde eine XML Quelle mittels verschiedener XSLT Stylesheets in unterschiedliche WML WAP Repräsentationen transformiert.</p>
                     <p>So würde das Zwei-Kapitel Beispiel von oben im WML Format aussehen (recht einfach gehalten):</p>
                     <verbatim><color name="green">&lt;?xml</color> version="1.0" encoding="UTF-8"?<color name="green">&gt;</color>
&lt;!DOCTYPE wml PUBLIC "-//WAPFORUM//DTD WML 1.1//EN" "http://www.wap.org/DTD/wml_1.1.xml"&gt;
<color name="green">&lt;wml&gt;</color>
  <color name="green">&lt;head&gt;</color>
    <color name="green">&lt;meta</color> name="title" content="Das ultimative Zwei-Kapitel Dokument"<color name="green">/&gt;</color>   
  <color name="green">&lt;/head&gt;</color> 
  <color name="green">&lt;card</color> id="chapter1" title="Kapitel 1"<color name="green">&gt;</color>
    <color name="green">&lt;p&gt;</color><color name="green">&lt;i&gt;</color>In Kapitel 1 wird kurz gesagt was Sache ist.<color name="green">&lt;/i&gt;</color><color name="green">&lt;/p&gt;</color>        
    <color name="green">&lt;p&gt;</color>Um es kurz zu machen, wie der Hase läuft steht<color name="brown"> in </color>Kapitel 2.<color name="green">&lt;/p&gt;</color>  
  <color name="green">&lt;/card&gt;</color>
  <color name="green">&lt;card</color> id="chapter2" title="Kapitel 2"<color name="green">&gt;</color>
    <color name="green">&lt;p&gt;</color><color name="green">&lt;i&gt;</color>Hier wird erklärt, wie der Hase läuft.<color name="green">&lt;/i&gt;</color><color name="green">&lt;/p&gt;</color>
    <color name="green">&lt;p&gt;</color>Im Prinzip ist es ganz einfach.<color name="green">&lt;/p&gt;</color>
  <color name="green">&lt;/card&gt;</color>
<color name="green">&lt;/wml&gt;</color></verbatim>
                     <p>Eine XSLT Transformation, die die XML Daten von oben in diese WML Darstellung überführt, könnte z.B. so implementiert werden:</p>
                     <verbatim><color name="green">&lt;?xml</color> version="1.0" encoding="UTF-8"?<color name="green">&gt;</color>
<color name="green">&lt;xsl:stylesheet</color> xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"<color name="green">&gt;</color>

  <color name="green">&lt;xsl:output
</color>    doctype-public="-//WAPFORUM//DTD WML 1.2//EN" 
    doctype-system="http://www.wapforum.org/DTD/wml12.dtd"
    indent="yes"<color name="green">/&gt;</color>
    
  <color name="green">&lt;xsl:template</color> match="document"<color name="green">&gt;</color>
    <color name="green">&lt;wml&gt;</color>
      <color name="green">&lt;xsl:apply-templates/&gt;</color>
    <color name="green">&lt;/wml&gt;</color>
  <color name="green">&lt;/xsl:template&gt;</color>
    
  <color name="green">&lt;xsl:template</color> match="document/title"<color name="green">&gt;</color>
    <color name="green">&lt;head&gt;</color>
      <color name="green">&lt;meta</color> name="title"<color name="green">&gt;</color>
        <color name="green">&lt;xsl:attribute</color> name="content"<color name="green">&gt;</color>
          <color name="green">&lt;xsl:value-of</color> select="."<color name="green">/&gt;</color>               
        <color name="green">&lt;/xsl:attribute&gt;</color>
      <color name="green">&lt;/meta&gt;</color>      
    <color name="green">&lt;/head&gt;</color>
  <color name="green">&lt;/xsl:template&gt;</color>
    
  <color name="green">&lt;xsl:template</color> match="chapter"<color name="green">&gt;</color>
    <color name="green">&lt;card</color> id="{concat('chapter',count(preceding-sibling::chapter)+1)}"<color name="green">&gt;</color>
      <color name="green">&lt;xsl:attribute</color> name="title"<color name="green">&gt;</color>
        <color name="green">&lt;xsl:value-of</color> select="title"<color name="green">/&gt;</color>
      <color name="green">&lt;/xsl:attribute&gt;</color>
      <color name="green">&lt;xsl:apply-templates</color> select="*[not(self::title)]"<color name="green">/&gt;</color>
    <color name="green">&lt;/card&gt;</color>
  <color name="green">&lt;/xsl:template&gt;</color>
  
  <color name="green">&lt;xsl:template</color> match="node()|@*"<color name="green">&gt;</color>
    <color name="green">&lt;xsl:copy&gt;</color>
      <color name="green">&lt;xsl:apply-templates</color> select="node()|@*"<color name="green">/&gt;</color>
    <color name="green">&lt;/xsl:copy&gt;</color>
  <color name="green">&lt;/xsl:template&gt;</color>
  
  <color name="green">&lt;xsl:template</color> match="processing-instruction()"<color name="green">/&gt;</color>
  
  <color name="green">&lt;xsl:template</color> match="intro"<color name="green">&gt;</color>
    <color name="green">&lt;p&gt;</color><color name="green">&lt;i&gt;</color><color name="green">&lt;xsl:apply-templates/&gt;</color><color name="green">&lt;/i&gt;</color><color name="green">&lt;/p&gt;</color>
  <color name="green">&lt;/xsl:template&gt;</color>
  
  <color name="green">&lt;xsl:template</color> match="content"<color name="green">&gt;</color>
    <color name="green">&lt;p&gt;</color><color name="green">&lt;xsl:apply-templates/&gt;</color><color name="green">&lt;/p&gt;</color>
  <color name="green">&lt;/xsl:template&gt;</color>
<color name="green">&lt;/xsl:stylesheet&gt;</color></verbatim>
                  
               </chapter>
               <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                  id="dba4d628-9c1b-411a-ae77-d04c769b8227d6e43">
                  
                     <title>
                        <title id="fa0123f8-d2ab-48fe-a8a4-69c5ea6e5b29d6e48">Ausgabeformate</title>
                     </title>
                     <p>Aus einer XML Quelle können auch leicht weitere Format erzeugt werden, bspw. <b>ePub</b>. <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                    address="https://de.wikipedia.org/wiki/EPUB">EPUB</url> ist das Standardformat für eBooks. Neben Tags zur Formatierung für den Content, gibt es bspw. auch Anweisungen zum Erzeugen des Inhaltsverzeichnisses oder anderer Navigationsstrukturen.</p>
                     <p>Weitere gängige Formate sind neben dem oben veralteten WML Format, elektronische Ausgabe-Formate wie: <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                    address="https://de.wikipedia.org/wiki/CHM_(Dateiformat">CHM</url>, <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                    address="https://www.ibm.com/developerworks/library/os-echelp/index.html">EclipseHelp</url>, <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                    address="https://en.wikipedia.org/wiki/JavaHelp">JavaHelp</url>, ..., Print-Ausgabe Formate, wie PDF oder <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                    address="https://de.wikipedia.org/wiki/FrameMaker">Adobe Framemaker</url>,  oder XML Standard Austauschformate, wie DITA, S1000D, <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                    address="https://www.i4icm.de/forschungstransfer/pi-mod/">PI-MOD</url>, <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                    address="https://de.wikipedia.org/wiki/Journal_Article_Tag_Suite">JATS</url> oder <url xmlns:tektur="http://www.stylesheet-entwicklung.de" address="">TEI</url>.</p>
                  
               </chapter>
               <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                  id="65ab0654-cf37-4549-b03e-a129f268e745d6e53">
                  
                     <title>
                        <title id="4135a624-a45f-433c-8d0b-18416fe3765fd6e55">Menschenlesbare Ausgabe</title>
                     </title>
                     <p>Kryptische XML Log-, Daten- oder Konfigurationsfiles können leicht mit XSLT menschenlesbar formatiert werden. Ein Arbeitskollege im neuen Job kam kürzlich auf mich zu, ob ich um eine Möglichkeit wüsste, wie man sein kryptisches Datenfile für einen Übersetzungsdienst formatieren könnte:</p>
                     <verbatim><color name="green">&lt;?xml</color> version="1.0" encoding="UTF-8"?<color name="green">&gt;</color>?<color name="green">&lt;?xml-stylesheet</color> type="text/xsl" href="de.xsl"?<color name="green">&gt;</color>
<color name="green">&lt;jcr:root</color> xmlns:sling="http://sling.apache.org/jcr/sling/1.0"
  xmlns:jcr="http://www.jcp.org/jcr/1.0" 
  xmlns:mix="http://www.jcp.org/jcr/mix/1.0"
  xmlns:nt="http://www.jcp.org/jcr/nt/1.0"
  jcr:language="de"
  jcr:mixinTypes="[mix:language]"
  jcr:primaryType="sling:Folder"<color name="green">&gt;</color>
<color name="green">&lt;b_manual</color> 
  jcr:primaryType="sling:MessageEntry"
  sling:message="Bedienungsanleitung"<color name="green">/&gt;</color>
  <color name="green">&lt;b_warning
</color>    jcr:primaryType="sling:MessageEntry"
    sling:message="Warnung"<color name="green">/&gt;</color>
  <color name="green">&lt;b_danger
</color>    jcr:primaryType="sling:MessageEntry"
    sling:message="Vorsicht"<color name="green">/&gt;</color>
  <color name="green">&lt;b_note
</color>    jcr:primaryType="sling:MessageEntry"
    sling:message="Notiz"<color name="green">/&gt;</color>
  <color name="green">&lt;b_notice
</color>    jcr:primaryType="sling:MessageEntry"
    sling:message="Hinweis"<color name="green">/&gt;</color>
  [...]</verbatim>
                     <p>Mit einem eingehängten XSLT Stylesheet <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>de.xsl</nb>
               </code> wird so ein Datenfile als Tabelle formatiert:</p>
                     <verbatim><color name="green">&lt;?xml</color> version="1.0" encoding="iso-8859-1"?<color name="green">&gt;</color>
<color name="green">&lt;xsl:stylesheet</color> version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:jcr="http://www.jcp.org/jcr/1.0"
  xmlns:sling="http://sling.apache.org/jcr/sling/1.0"<color name="green">&gt;</color>
  
  <color name="green">&lt;xsl:template</color> match="jcr:root"<color name="green">&gt;</color>
    <color name="green">&lt;html&gt;</color>
      <color name="green">&lt;table</color> border="1" cellpadding="5" cellspacing="5"<color name="green">&gt;</color>
        <color name="green">&lt;xsl:apply-templates/&gt;</color>
      <color name="green">&lt;/table&gt;</color>
    <color name="green">&lt;/html&gt;</color>
  <color name="green">&lt;/xsl:template&gt;</color>
  
  <color name="green">&lt;xsl:template</color> match="*"<color name="green">&gt;</color>
    <color name="green">&lt;tr&gt;</color>
      <color name="green">&lt;td&gt;</color>
        <color name="green">&lt;xsl:value-of</color> select="concat(count(preceding::*[@sling:message]) + 1,'.')"<color name="green">/&gt;</color>
      <color name="green">&lt;/td&gt;</color>
      <color name="green">&lt;td&gt;</color>
        <color name="green">&lt;xsl:value-of</color> select="name()"<color name="green">/&gt;</color>
      <color name="green">&lt;/td&gt;</color>
      <color name="green">&lt;td</color> contenteditable="true"<color name="green">&gt;</color>
        <color name="green">&lt;xsl:value-of</color> select="@sling:message"<color name="green">/&gt;</color>
      <color name="green">&lt;/td&gt;</color>
    <color name="green">&lt;/tr&gt;</color>
  <color name="green">&lt;/xsl:template&gt;</color>
<color name="green">&lt;/xsl:stylesheet&gt;</color></verbatim>
                     <p>Hängt man an dieses Beispiel noch ein bisschen Javascript Logik und macht die Felder für die Übersetzungen mittels des HTML5 <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>contenteditable</nb>
               </code> Attributs editierbar, dann bräuchte man nur noch eine Rücktransformation HTML nach XML und hätte schon einen kleinen XML Editor gebaut. So funktioniert auch der Editor in <nb xmlns:tektur="http://www.stylesheet-entwicklung.de">Tektur</nb>.</p>
                  
               </chapter>
               <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                  id="8f7b5093-7373-447b-9150-8e384b08a39cd6e66">
                  
                     <title>
                        <title id="5ab04d47-2964-42e4-8002-ba2b7828111bd6e68">Diagramme darstellen</title>
                     </title>
                     <p>Nachdem eine SVG Grafik im XML Format vorliegt kann diese auch direkt aus XML Daten mittels XSLT erzeugt werden. Über das HTML5 <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>&lt;svg&gt;</nb>
               </code> Element kann so eine erzeugte Grafik inline in das ebenfalls durch das XSLT generierte HTML Dokument eingebunden werden.</p>
                     <p>Betrachten wir unser Beispiel von oben, erweitert um drei neue <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>&lt;block&gt;</nb>
               </code> Elemente:</p>
                     <verbatim><color name="green">&lt;?xml</color> version="1.0" encoding="UTF-8"?<color name="green">&gt;</color>
<color name="green">&lt;?xml-stylesheet</color> type="text/xsl" href="chart.xsl" ?<color name="green">&gt;</color>
<color name="green">&lt;document&gt;</color>
  <color name="green">&lt;title&gt;</color>Das ultimative Zwei-Kapitel Dokument<color name="green">&lt;/title&gt;</color>
  <color name="green">&lt;chapter&gt;</color>
    <color name="green">&lt;title&gt;</color>Kapitel 1<color name="green">&lt;/title&gt;</color>
    <color name="green">&lt;intro&gt;</color>In Kapitel 1 wird kurz gesagt was Sache ist.<color name="green">&lt;/intro&gt;</color>
    <color name="green">&lt;content&gt;</color>Um es kurz zu machen, wie der Hase läuft steht<color name="brown"> in </color>Kapitel 2.<color name="green">&lt;/content&gt;</color>
  <color name="green">&lt;/chapter&gt;</color>
  <color name="green">&lt;chapter&gt;</color>
    <color name="green">&lt;title&gt;</color>Kapitel 2<color name="green">&lt;/title&gt;</color>
    <color name="green">&lt;intro&gt;</color>Hier wird erklärt, wie der Hase läuft.<color name="green">&lt;/intro&gt;</color>
    <color name="green">&lt;content&gt;</color>Im Prinzip ist es ganz einfach. Betrachten wir doch drei gelbe Blöcke:
    <color name="green">&lt;/content&gt;</color>
    <color name="green">&lt;block/&gt;</color>
    <color name="green">&lt;block/&gt;</color>
    <color name="green">&lt;block/&gt;</color>
  <color name="green">&lt;/chapter&gt;</color>
<color name="green">&lt;/document&gt;</color></verbatim>
                     <p>Wenn wir das XSLT Stylesheet noch um eine Regel für das neue <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>&lt;block&gt;</nb>
               </code> Element ergänzen, so wie hier:</p>
                     <verbatim><color name="green">&lt;xsl:template</color> match="block"<color name="green">&gt;</color>
   <color name="green">&lt;svg</color> style="background-color:yellow" width="30" height="30" 
     xmlns:xlink="http://www.w3.org/1999/xlink" 
     xmlns="http://www.w3.org/2000/svg"<color name="green">/&gt;</color>
  <color name="green">&lt;br/&gt;</color>
  <color name="green">&lt;br/&gt;</color>
<color name="green">&lt;/xsl:template&gt;</color></verbatim>
                     <p>Dann erhalten wir drei schön formatierte gelbe SVG Blöcke ...</p>
                     <p>
                        <b>Weiterführende Links:</b>
                     </p>
                     <ul>
                        <li>
                           <p>
                     <url xmlns:tektur="http://www.stylesheet-entwicklung.de" address="">Client-side image generation with SVG and XSLT</url>
                  </p>
                        </li>
                        <li>
                           <p>
                     <url xmlns:tektur="http://www.stylesheet-entwicklung.de" address="">Knotentyp Visualisierung im Apache Jack Rabbit Projekt</url>
                  </p>
                        </li>
                     </ul>
                  
               </chapter>
            
         
      </chapter>
      <chapter hyphenation="yes" chapterpage="no" id="151a9719-a32a-4fca-a55c-769b47a73b34"
               ismodule="no">
         
            <title>
               <title id="47f2fdc5-eca0-4e9b-bfc8-f2fbd76403d8">Professionelle XML Verarbeitung</title>
            </title>
            
               <p>Vom Single-Source Publishing bis zur Generierung von Java Code aus Klassendiagrammen.</p>
               <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                  id="b3ef9995-0478-4867-b02a-e2a3b0d9cf2cd6e6">
                  
                     <title>
                        <title id="012db970-b72c-425a-a3ad-3e817e002282d6e7">Single Source Publishing</title>
                     </title>
                     <p>Gängige Formate in der Technischen Dokumentation sind elektronische Ausgabe-Formate wie: CHM, EclipseHelp, JavaHelp, ePub, ..., Print-Ausgabe Formate, wie PDF oder Adobe Framemaker, oder XML Standard Austauschformate, wie DITA, S1000D, PI-MOD oder TEI.
Vorteile:</p>
                     <ul>
                        <li>
                           <p>Bei einer Änderung in der XML Quelle werden auch automatisch alle anschließenden Formate aktualisiert.</p>
                        </li>
                        <li>
                           <p>Strikte Trennung von Content/Semantik und Layout/Design.</p>
                        </li>
                        <li>
                           <p>Auf der XML Quelle sind XML Features möglich, wie:
	
		<b>Modularisierung</b>: Erlaubt die fein-granulare <b>Wiederverwendung</b> von Content-Bausteinen, sowie das Verlinken, Filtern, Suchen und Exportieren derselben.
		<b>Generalisierung</b> ist ein DITA Konzept, welches die Wiederverendung von angepassten Topics in anderen DITA Systemen ermöglicht.
		<b>Gültigkeiten</b> erlauben die bedingte Anwendung von Content-Bestandteilen auf Satz und Wort-Ebene.
		<b>Versionierung</b> und <b>Diffing</b> - Vergleich von Änderungen zwischen Versionen. <b>Intelligente Querverweise</b>: Ein Link zwischen einzelnen XML Topics  bleibt versionstreu.
		<b>Automatischer Satz</b>, inkl. Zusamenhalte- und Trennregeln für Seiten, Absätze und Blöcke (Listen, Tabellen, etc).
	
	</p>
                        </li>
                        <li>
                           <p>Veraltete Formate können ausgetauscht werden, ohne dass der Content geändert werden muss oder verlorengeht.</p>
                        </li>
                        <li>
                           <p>Die XML Quelle kann ohne Aufbereitung in anderen Systemen wiederverwendet werden.</p>
                        </li>
                        <li>
                           <p>Es gibt weit verbreitete <b>Standards</b> zur Struktur der XML Quelle.</p>
                        </li>
                        <li>
                           <p>Nur das XML wird in der Datenhaltung persistiert.</p>
                        </li>
                        <li>
                           <p>Es gibt spezialisierte <doclink class="3337f433-44bf-430d-a809-73fd1de5ba6c"
                              id="1b7d4b0c-4559-48b0-9e66-21a243a47897"
                              type="topic">XML Datenbanken</doclink>, die besonders gut auf Baumstrukturen arbeiten. (Dokumente sind per se baum-strukturiert und sind eigentlich für eine relationale Datenbank ungeignet)</p>
                        </li>
                     </ul>
                     <p>Die Redaktionssysteme der Technischen Dokumentation der führenden Hersteller in Deutschland haben XML unter der Haube und setzen auf die <b>Single-Source Strategie</b>.</p>
                  
               </chapter>
               <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                  id="084a7657-95f1-4ade-905e-cada919a0918d6e72">
                  
                     <title>
                        <title id="c2ea4ffe-bfc9-4c96-b5d9-d793083fc510d6e39">Code Generierung</title>
                     </title>
                     <p>Nachdem man bei XSLT im Format der Ausgabe frei ist, kann auch direkt Plain-Text mit  XSLT Regeln generiert werden. Daher liegt es nahe sich jegliche Form von Quelltext aus einer XML Repräsentation erzeugen zu lassen.</p>
                     <p>Beispielsweise speichern gängige CASE Tools (Computer Aided Software Engineering) UML Diagramme im XML Format ab, so z.B. <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                    address="http://argouml.tigris.org">ArgoUML</url>.</p>
                     <p>Diese Klassendiagramme lassen sich mittels XSLT direkt in Java-Code transformieren, wie z.B. in einem kleinen Open Source Projekt (aus vergangenen Tagen) : <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                    address="http://butterflycode.sourceforge.net">Butterfly Code Generator</url>
            </p>
                     <p>Es gibt auch einen schönen Artikel dazu im <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                    address="https://www.javaworld.com/article/2073998/java-web-development/generate-javabean-classes-dynamically-with-xslt.html">Java World Journal</url>.</p>
                  
               </chapter>
               <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                  id="ce09156d-5ebb-4829-b9dc-21a3bfdf8107d6e83">
                  
                     <title>
                        <title id="bd0e17e7-dce2-45a0-b5eb-90297e678e88d6e56">Migrationen und Konvertierungen</title>
                     </title>
                     <p>Für jede erdenkliche Art der Migration eines XML Datenbestands oder eines Datenbank-Dumps / -Exports im XML Format, zwischen Produktversionen oder zwischen Dienstleister- und Dienstnutzer-Systemen, bietet sich XSLT zur Transformation an.</p>
                     <p>Dabei ist zu beachten, dass XSLT besonders schnell und gut auf verschachtelten Strukturen arbeitet. Entartet ein Baum zur Liste und/oder sind nur geringe Strukturanpassungen notwendig, wird man sich mit einem schnellen SAX Parser leichter tun. </p>
                     <p> Mittels der XSLT3.0  können auch sehr große XML Quellen (Big Data) verarbeitet werden. Saxon bietet bspw. diese <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                    address="http://www.saxonica.com/html/documentation/sourcedocs/streaming/">Streaming Option</url>.</p>
                  
               </chapter>
            
         
      </chapter>
   </chapter>
   <chapter hyphenation="yes" chapterpage="no" id="31a92dc0-959c-49a1-b06e-01e2369e050e"
            ismodule="no">
      
         <title>
            <title id="6a6d03c2-e2be-4b5f-b515-ed4ec3132dd1">Wichtige Konzepte</title>
         </title>
         
            <p>XSLT und XQuery erlauben es Probleme auf viele verschiedene Arten zu lösen. Sicherlich wird jeder Programmierer im Laufe der Zeit seinen eigenen Stil entwickeln. Das kommt nicht zuletzt daher, dass man als XSLT Entwickler in vielen Firmen eine Expertenrolle einnimmt.</p>
            <p>Umso wichtiger ist es, sich an allgemeine Konzepte, Muster und Best Practices zu halten, um einen schwer wartbaren Wildwuchs zu vermeiden.</p>
            <p>Auf den folgenden Seiten wird versucht einige dieser Konzepte zusammenzutragen und mit eigenen Erfahrungen und Ideen zu kombinieren.</p>
            <p>Es wird weder der Anspruch auf Vollständigkeit noch auf Korrektheit dieser Informationen erhoben. Das Kapitel soll vielmehr als Denkanstoß mit hoffentlich einigen verwertbaren Ideen dienen.</p>
            <p/>
         
      
      <chapter hyphenation="yes" chapterpage="no" id="5b73f348-0058-45e0-82f7-c3de72ec5d41"
               ismodule="no">
         
            <title>
               <title id="c16fd330-a145-443c-bf0a-2ca245527453">Push vs. Pull Stylesheets </title>
            </title>
            
               <p>XSLT ist eine ereignisgesteuerte, regelbasierte Umgebung zur Konvertierung von XML Daten. Gerade der Vorteil des regelbasierten Ansatzes ist vielen Entwicklern nicht bewusst, und es entsteht Quellcode der aussieht, wie mit XPath angereicherter PHP Code.</p>
               <p>Wieso nimmt man dann überhaupt XSLT, wenn man keine Template-Match Regeln verwendet, oder nur spärlich verwendet?</p>
               <p>Um diesen Umstand aufzuklären ist ein bisschen Theorie notwendig:</p>
               <figure pdfwidth="page">
                  <subtitle>Pull Stylesheet</subtitle>
                  <desc id="07322c84-0481-44ab-a799-bf52da6b8dded6e13">Beim "Pull" werden Elemente in der Quellinstanz selektiert und an einer passenden Stelle in der Zielinstanz eingefügt. Diese Vorgehensweise ist vergleichbar mit derer von Template-Engines, wie JSP oder ASP. Das kann in mehreren Stufen erfolgen, bis schrittweise die Quellinstanz in die finale Zielinstanz überführt wurde.</desc>
                  <img src="./client/data/5b73f348-0058-45e0-82f7-c3de72ec5d41/pull.svg"/>
               </figure>
               <figure pdfwidth="page">
                  <subtitle>Push Stylesheet</subtitle>
                  <desc id="9a63a604-831f-49cb-81a7-0b79d0c947bdd6e19">Beim "Push" werden die Quelldaten schrittweise in die Zieldaten konvertiert. Diese Vorgehensweise kann explorativ erfolgen und beim Transformieren in einen Zwischenschritt entstehen Erkenntnisse, die bei der Weiterverarbeitung nützlich sind. <b>Merke:</b> XSLT steht für eXtensible Stylesheet Transformation.</desc>
                  <img src="./client/data/5b73f348-0058-45e0-82f7-c3de72ec5d41/pusch.svg"/>
               </figure>
               <p>Das bisher Gesagte verdeutlicht zwar den "Pull" Ansatz, was genau aber ge"pusht" wird, ist vermutlich noch unklar. Betrachten wir XML in der Baumdarstellung.</p>
               <figure pdfwidth="page">
                  <subtitle>Transformation des Quellbaums in den Zielbaum</subtitle>
                  <desc id="b407302b-5344-487c-963d-1bf2e2625dded6e30">Der XSLT Prozessor unternimmt einen Tiefensuchlauf und überprüft bei jedem Knoten den er betritt, ob in seiner Regelbasis eine Regel existiert, die auf diesen Knoten "matched". Dabei gibt es drei grundsätzliche Möglichkeiten, wie die Knoten des Quellbaums in den Zielbaum kopiert - oder eben nicht kopiert - werden können.</desc>
                  <img src="./client/data/5b73f348-0058-45e0-82f7-c3de72ec5d41/push.svg"/>
                  <legend>
                     <leg-entry id="f9455559-67ce-4901-9444-ccdd01d21c56d6e43">
                        <leg-pos>
                           <p>Remove</p>
                        </leg-pos>
                        <leg-name>
                           <p>Beim Betreten einer leeren Match-Regel wird ein Teilbaum nicht kopiert</p>
                        </leg-name>
                     </leg-entry>
                     <leg-entry id="4f2540c3-a78f-49dc-a2b3-3e3d5c7d1c16d6e50">
                        <leg-pos>
                           <p>Bypass</p>
                        </leg-pos>
                        <leg-name>
                           <p>Beim Betreten einer Match-Regel ohne Kopieranweisung wird der Knoten übersprungen</p>
                        </leg-name>
                     </leg-entry>
                     <leg-entry id="f38f09a2-6878-42f6-bcfe-621ca2fc7fa5d6e57">
                        <leg-pos>
                           <p>Push</p>
                        </leg-pos>
                        <leg-name>
                           <p>Durch gezielte Auswahl einer Knotenmenge auf der Descendant-Achse wird der XSLT Prozessor in eine bestimmte Richtung ge"pusht".</p>
                        </leg-name>
                     </leg-entry>
                  </legend>
               </figure>
               <p>Pull-Stylesheets werden gewöhlich mit <b>for-each</b> Loops programmiert. Dieser Ansatz ist meiner Ansicht nach gebräuchlich, wenn keine großen DTD Änderungen zu erwarten sind, der XML Baum flach strukturiert ist und die Anforderungen an die  Knvertierung relativ einfach sind, bspw. beim Auswerten / Konvertieren von Konfigurationsdateien. In alles anderen Fällen sind Push-Stylesheets vorzuziehen, d.h. möglichst wenige <b>for-each</b> loops und möglichst viele <b>Template-Match</b> Regeln.</p>
            
         
      </chapter>
      <chapter hyphenation="yes" chapterpage="no" id="db988919-f71e-437e-b699-b6fdd2a32cb9"
               ismodule="no">
         
            <title>
               <title id="b8539c31-c176-46bb-b028-e811b2decfbe">Eindeutigkeit der Regelbasis</title>
            </title>
            
               <p>Die Regelbasis der XSLT ereignisgesteuerten Laufzeitumgebung kann unendlich viele Regeln aufnehmen. Für die Vollständigkeit, Eindeutigkeit und Konsistenz der Regelbasis ist der Programmierer selbst verantwortlich.</p>
               <p>Um die Eindeutigkeit der Regeln zu gewährleisten,  gibt es verschiedene Mechanismen.</p>
               <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                  id="dddb5d5f-b523-4d70-871c-9deadda78661d6e8">
                  
                     <title>
                        <title id="e16576ad-fbf7-41d7-a23e-deb174c6b176d6e9">Reihenfolge der Match-Regeln</title>
                     </title>
                     <p>Im Normalfall sollte auf einen bestimmten Knoten in einem bestimmten Szenario genau eine Regel matchen. Falls es einen Konflikt gibt, wird zumindest bei Saxon diejenige Regel herangezogen, die im Stylesheet zuletzt deklariert wurde.</p>
                     <p>Diesen Umstand zu kennen, ist genau dann wichtig, wenn man einen bestehenden Stylesheet-Code übernehmen muss. Getreu dem Motto "Never change a running system" sollte man die Sache diesbzgl. sehr behutsam aufräumen.</p>
                  
               </chapter>
               <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                  id="9ee01e85-e2da-4c26-9c87-8ab4ef47faf6d6e15">
                  
                     <title>
                        <title id="c35ab440-7d81-4466-a34f-32545cec227ad6e14">Präzedenz der Auswertung</title>
                     </title>
                     <p>Match-Regeln werden gemäß ihrer Spezifität sortiert und diejenige, die auf einem Knoten in einem bestimmten Szenario am besten zutrifft, wird zur Auswertung herangezogen. Grds. werden die Regeln anhand folgender Kriterien sortiert:</p>
                     <procedure type="ol">
                        <step>
                           <action>
                              <p>Importierte Template Regeln haben immer eine niedrigere Priorität als die Regeln des importierenden Stylesheets.</p>
                           </action>
                        </step>
                        <step>
                           <action>
                              <p>Templates mit einem höheren Priority Attribut haben Vorrang.</p>
                           </action>
                        </step>
                        <step>
                           <action>
                              <p>Templates ohne Priorität bekommen automatisch eine Default-Priorität. Die höchste Default-Priorität ist <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                           <nb>0.5</nb>
                        </code>.</p>
                           </action>
                        </step>
                        <step>
                           <action>
                              <p>Diese Default Priorität errechnet sich anhand der Bedingungen oder Wildcards, die an einen Match-Regel geknüpft sind: </p>
                              <ul>
                                 <li>
                                    <p>Wenn mehrere Templates matchen, dann wird das am meisten spezifische zur Auswertung herangezogen.</p>
                                 </li>
                                 <li>
                                    <p>Das am meisten spezifische Template wird anhand der Prioritäten berechnet.</p>
                                 </li>
                                 <li>
                                    <p>Einfache Elementnamen (z.B. "para") haben Prio <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                                 <nb>0</nb>
                              </code>.</p>
                                 </li>
                                 <li>
                                    <p>Wildcards (z.B. <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                                 <nb>*, @*</nb>
                              </code>) haben Priorität <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                                 <nb>-0.25</nb>
                              </code>
                           </p>
                                 </li>
                                 <li>
                                    <p>Knoten-Tests für andere Knoten (e.g. <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                                 <nb>comment(), node()</nb>
                              </code>, etc. ) haben Priorität <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                                 <nb>-0.5</nb>
                              </code>
                           </p>
                                 </li>
                                 <li>
                                    <p>In allen anderen Fällen ist die Prio <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                                 <nb>0.5</nb>
                              </code>.</p>
                                 </li>
                              </ul>
                              <p>Beispiele:</p>
                              <ul>
                                 <li>
                                    <p>
                              <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                                 <nb>para -&gt; 0</nb>
                              </code>
                           </p>
                                 </li>
                                 <li>
                                    <p>
                              <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                                 <nb>h:* -&gt; -0.25</nb>
                              </code>
                           </p>
                                 </li>
                                 <li>
                                    <p>
                              <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                                 <nb>* -&gt; -0.25</nb>
                              </code>
                           </p>
                                 </li>
                                 <li>
                                    <p>
                              <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                                 <nb>node() -&gt; -0.25</nb>
                              </code>
                           </p>
                                 </li>
                                 <li>
                                    <p>
                              <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                                 <nb>contents/para -&gt; 0.5</nb>
                              </code>
                           </p>
                                 </li>
                                 <li>
                                    <p>
                              <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                                 <nb>contents/* -&gt; 0.5</nb>
                              </code>
                           </p>
                                 </li>
                              </ul>
                           </action>
                        </step>
                        <step>
                           <action>
                              <p>Mit einer Kommandozeilen-Option kann bei Saxon festgelegt werden, dass die Transformation abbricht, sobald es einen Konflikt bei der Regelauswertung gibt.</p>
                           </action>
                        </step>
                     </procedure>
                  
               </chapter>
               <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                  id="daccc985-d7ea-41a7-8408-3094b807352dd6e76">
                  
                     <title>
                        <title id="5b4364ca-516c-4edb-a9e8-3de574a18cc2d6e19">Import Präzendenz und Default-Regel</title>
                     </title>
                     <p>Wie in der obigen Sektion unter Punkt 1. angegeben, haben alle Regeln in einem importierten Stylesheet eine geringere Priorität als im importierenden Stylesheet. Diesen Umstand kann man sich zunutze machen, um eine Default-Regel einzubinden, bspw:</p>
                     <verbatim><color name="green">&lt;xsl:template</color> match="*" mode="#all"<color name="green">/&gt;</color></verbatim>
                     <p>Da sie sich in einem importierten Stylesheet befindet, hat sie geringere Priorität als alle anderen Regeln und greift nur dann, wenn für einen betretenen Knoten keine andere Match-Regel definiert ist.</p>
                     <p>Das ist z.B. praktisch, um nicht "gehandelte" Element zu identifizieren - dazu wäre die obige Regel nicht leer, sondern würde bspw. einen gelb markierten Warntext direkt in das Ausgabeformat schreiben.</p>
                     <p>Eine leere Default-Regel ist dagegen gut, wenn bspw. in einer XML-2-XML Migration automatisch Knoten im XML Baum abgetrennt werden sollen, für die keine Match-Regel existiert.</p>
                  
               </chapter>
               <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                  id="8159cee1-a749-403e-8f24-6ca446baade4d6e89">
                  
                     <title>
                        <title id="be710deb-554e-4962-beb9-9de58d386c7fd6e24">Prioritäten</title>
                     </title>
                     <p>Wie oben schon verdeutlicht werden alle Match-Regeln mit einer Priorität ausgestattet. Der Stylesheet-Entwickler hat die Möglichkeit diese Priorität zu überschreiben. Dazu wird das Attribut <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>@priority</nb>
               </code> an der Match-Regel verwendet. Ein Use-Case für die Prioritäten wäre bspw. folgendes Szenario:</p>
                     <ul>
                        <li>
                           <p>Die Eingabeinstanz soll in einer Vorprozessierung gefiltert werden.</p>
                        </li>
                        <li>
                           <p>Dabei sollen Seminar-Elemente markiert werden, die nicht besonderen Bedingungen entsprechen:</p>
                           <ul>
                              <li>
                                 <p>Das Seminar-Element hat ein Feld "Ende-Datum" das abgelaufen ist.</p>
                              </li>
                              <li>
                                 <p>Am Seminar-Element sind mehrere Dozenten angestellt, obwohl das Seminar-Element vom Type "Single" ist.</p>
                              </li>
                              <li>
                                 <p>em Seminar-Element ist kein Dozent zugeordnet.</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>Sicherlich kann es Seminar-Elemente geben, die alle drei Bedingungen erfüllen. Um das Error-Log aber nicht zu überfüllen, sollen die Filter nach ihren Prioritäten ausgeführt werden.</p>
                        </li>
                     </ul>
                     <p>In Templates überführt, könnte diese Anforderung so umgsetzt werden:</p>
                     <verbatim><color name="green">&lt;xsl:template</color> match="Seminar[Ende-Datum/xs:date(.) le current-date()]" 
              priority="30" mode="filter-network"<color name="green">&gt;</color> 
  <color name="green">&lt;xsl:element</color> name="Filtered-Seminar" namespace="{namespace-uri()}"<color name="green">&gt;</color> 
    <color name="green">&lt;xsl:attribute</color> name="reason"<color name="green">&gt;</color>termed-seminar<color name="green">&lt;/xsl:attribute&gt;</color> 
    <color name="green">&lt;xsl:apply-templates</color> select="node()|@*" mode="filter-network"<color name="green">/&gt;</color> 
  <color name="green">&lt;/xsl:element&gt;</color> 
<color name="green">&lt;/xsl:template&gt;</color> 

<color name="green">&lt;xsl:template</color> match="Seminar[Type eq 'SINGLE' and count(dozenten/dozent) gt 1]"
              priority="20" mode="filter-network"<color name="green">&gt;</color> 
  <color name="green">&lt;xsl:element</color> name="filtered-Seminar" namespace="{namespace-uri()}"<color name="green">&gt;</color> 
    <color name="green">&lt;xsl:attribute</color> name="reason"<color name="green">&gt;</color>dozenten-count<color name="green">&lt;/xsl:attribute&gt;</color> 
    <color name="green">&lt;xsl:apply-templates</color> select="node()|@*" mode="filter-network"<color name="green">/&gt;</color> 
  <color name="green">&lt;/xsl:element&gt;</color> 
<color name="green">&lt;/xsl:template&gt;</color> 

<color name="green">&lt;xsl:template</color> match="Seminar[not(dozenten/dozent)]" mode="filter-network"<color name="green">&gt;</color> 
  <color name="green">&lt;xsl:element</color> name="filtered-Seminar" namespace="{namespace-uri()}"<color name="green">&gt;</color> 
    <color name="green">&lt;xsl:attribute</color> name="reason"<color name="green">&gt;</color>dozenten-missing<color name="green">&lt;/xsl:attribute&gt;</color> 
    <color name="green">&lt;xsl:apply-templates</color> select="node()|@*" mode="filter-network"<color name="green">/&gt;</color> 
  <color name="green">&lt;/xsl:element&gt;</color> 
<color name="green">&lt;/xsl:template&gt;</color></verbatim>
                  
               </chapter>
               <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                  id="1c1d47cc-6418-4bdb-ad46-5f097384af28d6e118">
                  
                     <title>
                        <title id="8950e48f-85c8-4fc8-98f7-e1f7e42ed7d5d6e29">Modus Attribute</title>
                     </title>
                     <p>An allen Templates hat man die Möglichkeit einen selbst deklarierten Modus anzugeben. Wenn dann der XSLT Prozessor in eine bestimmte Richtung gepusht, vgl. <doclink class="5b73f348-0058-45e0-82f7-c3de72ec5d41"
                        id="8e5f35b9-8707-4d46-bf49-cfcfbdc2c7c9"
                        type="none">Push vs. Pull Stylesheets</doclink> , wird, werden nur diejenigen Regeln zur Auswertung herangezogen, die im selben Modus sind, wie der <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>apply-templates</nb>
               </code> Call.</p>
                     <p>Beispielsweise möchte man die Titel im Kapitel anders behandeln als die Kapitel im Inhaltsverzeichnis, denn im TOC sollen z.B. keine Fussnoten-Marker angezeigt werden. </p>
                     <p>In Templates formuliert würde diese Anweisung folgendermassen aussehen:</p>
                     <verbatim><color name="green">&lt;xsl:template</color> match="title" mode="toc"<color name="green">&gt;</color>
  <color name="green">&lt;div</color> class="toc-entry"<color name="green">&gt;</color>
    <color name="green">&lt;xsl:apply-templates</color> select="*[not(self::footnote)]"<color name="green">/&gt;</color>
  <color name="green">&lt;/div&gt;</color>
<color name="green">&lt;/xsl:template&gt;</color>

<color name="green">&lt;xsl:template</color> match="title"<color name="green">&gt;</color>
  <color name="green">&lt;h1&gt;</color>
    <color name="green">&lt;xsl:apply-templates/&gt;</color>
  <color name="green">&lt;/h1&gt;</color>
<color name="green">&lt;/xsl:template&gt;</color></verbatim>
                     <p>Die Generierung des TOC könnte dann so ablaufen:</p>
                     <verbatim><color name="green">&lt;xsl:for-each</color> select="chapter"<color name="green">&gt;</color>
  <color name="green">&lt;xsl:apply-templates</color> select="title" mode="toc"<color name="green">&gt;</color>
<color name="green">&lt;/xsl:for-each&gt;</color></verbatim>
                     <p>Bzgl. der Eindeutigkeit der Regelbasis kann man also auch noch anhand des Mode-Attributes Ausführungs-Gruppen bilden. </p>
                     <warning>
                        <cause>Wie auch bei Angabe der Priorities kann man auf diese Weise Regeln setzen, die nie ausgeführt wurden, weil sie vllt. im Zuge einer Refactoring-Massnahme abgeklemmt und dann vergessen wurden.</cause>
                        <consequence>Auch das mode-Attribut ist also mit Vorsicht zu geniessen und sparsam einzusetzen.</consequence>
                     </warning>
                  
               </chapter>
            
         
      </chapter>
      <chapter hyphenation="yes" chapterpage="no" id="3e443c28-8698-470b-b443-f286ff7ed2d5"
               ismodule="no">
         
            <title>
               <title id="743f34bc-c83e-49d3-9a2e-2c38d1c384c9">Namespaces</title>
            </title>
            
               <p>Wenn man XML Instanzen aus unterschiedlichen Quellen mit XSLT verarbeiten will, wird man sich wohl
oder übel mit dem Thema Namespaces (NS) auseinander setzen müssen, um Konflikte in den 
Elementselektoren zu vermeiden.</p>
               <p>Gerade bei hintereinandergeschalteten Transformationen kann es auch passieren, 
dass unerwartet ein Namespace in die Ausgabe generiert wird,
den der folgende Prozesschritt nicht versteht, weil er dort nicht deklariert wurde.</p>
               <p>Es gibt meherere Möglichkeiten einen Namespace im Stylesheet zu deklarieren. Gehen wir davon aus,
dass in einem Transformationsschritt genau eine Quelle und max. eine Konfigurationsdatei verarbeitet 
wird, dann kann das Stylsheet-Element bspw. so aussehen:</p>
               <verbatim><color name="green">&lt;xsl:stylesheet</color> version="2.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xs="http://www.w3.org/2001/XMLSchema" 
  xmlns:tektur="https://namespace-eigener-xslt-funktionen"
  xmlns="http://namespace-in-der-xml-eingabe.com/"
  xpath-default-namespace="https://namespace-der-konfigdatei.com/"
  exclude-result-prefixes="#all"<color name="green">&gt;</color></verbatim>
               <ul>
                  <li>
                     <p>Der <b>xsl</b> Namespace ist klar</p>
                  </li>
                  <li>
                     <p>Der <b>xs</b> Namespace ist notwendig, wenn man typisiert arbeiten will. Er erlaubt das Einbinden von Datentypen
nach der <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                       address="https://de.wikipedia.org/wiki/XML_Schema">XML Schema Spezifikation</url> und somit die 
bessere Validierung des Stylesheets zur Compile-Zeit.</p>
                  </li>
                  <li>
                     <p>Die Deklaration eines eigenen geprefixten Namespaces erlaubt das Einbinden von eigenen XSLT Funktionen, 
wie z.B. auch das Einbinden der <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                       address="http://www.xsltfunctions.com/">FunctX Bibliothek</url>
               </p>
                  </li>
                  <li>
                     <p>Der Nicht-geprefixte Namespace ist der Default-Namespace und kann einen NS aus der Eingabe handeln</p>
                  </li>
                  <li>
                     <p>Das Attribut <b>xpath-default-namespace</b> gibt einen weiteren NS an, der in XPATH Funktionen verwendet werden kann.
In diesem Feld würde ich den NS einer Konfigurations- oder separaten Datendatei angeben.</p>
                  </li>
               </ul>
               <p>Mehr als einen NS in der Eingabe sollte man aus meiner Sicht bei der XML Verarbeitung nit XSLT vermeiden wenn es geht.
GGf. empfiehlt es sich, die Eingabe vor der Verabeitung zu normalisieren und Elemente ggf. umzubennen. Ansonsten kann man auch eigene Namespace-Prefixes deklarieren, wie z.B.:</p>
               <verbatim>xmlns:ext="https://www.tekturcms.de/external-tools"</verbatim>
               <p>und diese in XPATH Selektionen und Match-Regeln verwenden.</p>
               <danger>
                  <cause>Befinden sich in den Eingabedaten Namespaces, die man in den XSLT Stylesheets nicht handelt - der Namespace kann auch nur
an einem ganz bestimmten Element hängen - so kann es bei der Transformation - ohne Fehlermeldung - zu unerwarteten Ergebnissen kommen.</cause>
                  <consequence>Deshalb sollte man die Daten im Vorfeld bzgl. Namespaces sehr genau analysieren.</consequence>
               </danger>
               <p>Namespaces in der Eingabe werden also meistens über die Kopfdeklaration in der Stylesheetdatei gehandelt, welcher Namespace
schliesslich in die Ausgabe geschrieben wird, hängt vom aktuell verarbeiteten Kontextknoten ab:</p>
               <ul>
                  <li>
                     <p>Elemente, die man erzeugt, erhalten automatisch den Default-Namespace, wenn man nicht explizit einen NS angibt.</p>
                  </li>
                  <li>
                     <p>Elemente, die man kopiert, transportieren den Namespace, den sie in der Eingabe hatten, wenn man dies nicht explizit verhindert.</p>
                  </li>
               </ul>
               <p>Um diese beiden Default Einstellungen zu steuern (bzw. zu überschreiben) gibt es mehrere Möglichkeiten:</p>
               <verbatim><color name="green">&lt;xsl:element</color> name="{local-name()}" namespace="{namespace-uri()}"<color name="green">&gt;</color></verbatim>
               <p>Hier wird ein Element mit dem un-geprefixten Namespace des Kontextknotens deklariert.
Wenn der Kontextknoten keinen anderen Namespace hat, so wird hierdurch sichergestellt,
dass der Default Namespace auch tatsächlich in die Ausgabe kommt.</p>
               <verbatim><color name="green">&lt;xsl:element</color> name="meinelement" namespace="mein-namespace"<color name="green">&gt;</color></verbatim>
               <p>Hier wird ein Element mit eigener Namespace Angabe in die Ausgabe geschrieben. Einfacher geschrieben:</p>
               <verbatim><color name="green">&lt;mein-element</color> xmlns="mein-namespace"<color name="green">&gt;</color></verbatim>
               <p>Es gibt auch ein Attribut am xsl:copy Element,
das den Vorgang des Namespace-Kopierens steuern kann:</p>
               <verbatim><color name="green">&lt;xsl:template</color> match="p"<color name="green">&gt;</color>
  <color name="green">&lt;xsl:copy</color> copy-namespaces="no"<color name="green">&gt;</color>
     <color name="green">&lt;xsl:apply-templates/&gt;</color>
   <color name="green">&lt;/xsl:copy&gt;</color>
<color name="green">&lt;/xsl:template&gt;</color></verbatim>
               <p>Hier wird der Namespace am <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
               <nb>p</nb>
            </code> Element nicht in die Ausgabe geschrieben. Ggf. funktiniert diese
Funktion aber mit unerwarteten Ergebnissen, deshalb sollte man sich ohne genauen Test nicht darauf verlassen.</p>
               <p>Ebenso kann eine Default-Kopierregel verwendet werden, die es verbietet einen Namespace
weiterzuvererben:</p>
               <verbatim><color name="green">&lt;xsl:template</color> match="@* | node()"<color name="green">&gt;</color>
   <color name="green">&lt;xsl:copy</color> inherit-namespaces="no"<color name="green">&gt;</color>
     <color name="green">&lt;xsl:apply-templates</color> select="@* | node()"<color name="green">/&gt;</color>
   <color name="green">&lt;/xsl:copy&gt;</color>
<color name="green">&lt;/xsl:template&gt;</color></verbatim>
               <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                  id="93174629-fa2e-4ee4-a5f4-805f4708bb69d6e82">
                  
                     <title>
                        <title id="ad139a27-9649-4c97-8f05-a62edd570cb7d6e74">Namespaces in XQuery</title>
                     </title>
                     <p>Während XSLT dazu dienen sollte, XML Daten in andere (XML-) Formate zu transformieren, dient XQuery 
z.B. dazu auf einer NoSQL Datenbank Daten aus unterschiedlichen Quellen
zu selektieren, zu harmonisieren und an verarbeitende Prozesse weiterzugeben.</p>
                     <p>Deshalb ist es für mich nicht so erstaunlich, dass das Namespace Konzept in XQuery irgendwie besser
funktioniert.</p>
                     <p>Damit man überhaupt Daten auf einem mit Namespaces versehenen XML Dokument selektieren
kann, müssen alle Namspaces am Anfang des XQuery Ausdrucks angegeben werden, das sieht so aus:</p>
                     <verbatim>xquery version "1.0-ml";

import <color name="brown">module </color><color name="brown">namespace </color>tektur = "http://www.teturcms.de/xquery/common" 
                                  at "common.xqy";
import <color name="brown">module </color><color name="brown">namespace </color>mem = "http://xqdev.com/in-mem-update" 
                                  at '/MarkLogic/appservices/utils/in-mem-update.xqy';
<color name="brown">declare </color><color name="brown">namespace </color>local = "https://lambdawerk.com/code/alex-sandbox/1.0";
<color name="brown">declare </color><color name="brown">namespace </color>weiredns = "https://weired-ns-in-input-data.com/weired/ns";
<color name="brown">declare </color><color name="brown">namespace </color>xs = "http://www.w3.org/2001/XMLSchema"; </verbatim>
                     <p>Hier werden zuerst Funktionen aus anderen Modulen eingebunden, nämlich die in einer Datei common.xqy
im selben Verzeichnis aus der eigenen Entwicklung, sowie die Bibliothek mem aus der MArklogic
Umgebung. Danach wird ein NS local deklariert, den man verwenden wird, wenn im weiteren Verlauf
eigene XQuery Funktionen verwendet werden sollen, sowie der NS weiredns, der in den Eingabedaten
vorhanden ist. Der NS <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>xs</nb>
               </code> ist analog zum XSLT Beispiel gesetzt.</p>
                  
               </chapter>
            
         
      </chapter>
   </chapter>
   <chapter hyphenation="yes" chapterpage="no" id="f838f9be-97bf-44a4-ac63-2e813a87f2ea"
            ismodule="no">
      
         <title>
            <title id="e959b617-429c-4a40-9ba2-c55ac946a753">Ausgewählte Themen</title>
         </title>
         
            <p>Auf den folgenden Seiten habe ich Themen ausgewählt, die für mich gerade besonders interessant erscheinen. Nach einer drei-jährigen Pause im Bereich XML, gibt es nun doch wieder viele neue Sachen ...</p>
            <p/>
         
      
      <chapter hyphenation="yes" chapterpage="no" id="c20c1e01-1175-4664-a26a-71317760930f"
               ismodule="no">
         
            <title>
               <title id="81e11338-11b3-42c9-917d-d3f9d4bffb12">Transformationen mit XSLT</title>
            </title>
            
               <p>XSLT ist die Standardlösung für XML Transformationen. Es gibt noch einige exotische Lösungen, wie:</p>
               <ul>
                  <li>
                     <p>
                        <undefined id="538b0aea-451b-474a-ab72-33a03e5638edd6e9" href="undefined"/>Metamorphosis<undefined id="637314cc-588a-404d-aade-40f6251755a1d6e12" href="undefined"> ist eine proprietäre Sprache der Firma Ovidius GmbH in Berlin. Sie findet hauptsächlich Anwendung im Bereich Publishing in der Luftfahrt / Verteidigung.</undefined>
                     </p>
                  </li>
                  <li>
                     <p>Und auch Spielereien, wie eine Nachbildung der XSLT Syntax in Erlang: <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                       address="http://erlang.org/doc/man/xmerl_xs.html">xmerl_xs</url>
               </p>
                  </li>
               </ul>
               <p>In diese Kapitel werden einige ausgewählte Themen zur XML Proezessierung mit XSLT dargestellt. Dabei geht es weder um Vollständigkeit, noch um die beste/eleganteste Lösung, sondern eher um die Vorstellung eines Anwendungsszenarios mit einem potentiellen Lösungsansatz - so wie ich die Sache halt angehen würde ...</p>
            
         
         <chapter hyphenation="yes" chapterpage="no" id="ceed4546-a60b-4d5f-a625-6e79c180cc13"
                  ismodule="no">
            
               <title>
                  <title id="28a8c9ba-33b0-41ff-8681-da976df43b85">Vortransformationen </title>
               </title>
               
                  <p>Bei einer komplexen Transformation ist es ratsam und sogar manchmal unabdingbar die Konvertierung in einzelne Stufen aufzuteilen. Das hat folgende Vorteile:</p>
                  <ul>
                     <li>
                        <p>Der Prozess ist transparenter, da die einzelnen Stufen leichter überschaubar sind.</p>
                     </li>
                     <li>
                        <p>Die Zwischenergebnisse können für Debug-Zwecke ausgewertet werde oder dienen als Eingabe für andere Prozesse.</p>
                     </li>
                     <li>
                        <p>Nicht-relevante oder invalide Teilbäume können aus der Eingabeinstanz gefiltert werden, um so die weitere Verarbeitung zu beschleunigen.</p>
                     </li>
                     <li>
                        <p>Hilfskonstrukte können erzeugt werden. Diese erleichtern die weitere Verarbeitung.</p>
                     </li>
                  </ul>
                  <p>Es gibt zwei Möglichkeiten, wie eine Vortransformation eingebunden werden kann:</p>
                  <ul>
                     <li>
                        <p>In einem separaten File bzw. einer XML Instanz, die vom XSLT Prozessor vor der eigentlichen Transformation aufgerufen wird und einen Zwischenstand produziert. Dieser kann dann als Eingabe für den Haupttransformationsschritt dienen.</p>
                     </li>
                     <li>
                        <p>Innerhalb des eigentlichen XSLT Stylesheets. Hier wird das Ergebnis der Vortransformation in einer Variablen erzeugt.</p>
                     </li>
                  </ul>
                  <p>Den zweiten Punkt möchte ich anhand eines Beispiel XSLT Skripts vorführen. Betrachten wir folgende Input Daten:</p>
                  <verbatim><color name="green">&lt;education-system&gt;</color>
  <color name="green">&lt;administrative-regions&gt;</color>
    [...]
    <color name="green">&lt;dministrative-region</color> id="31" name="Bavaria"<color name="green">&gt;</color>
      <color name="green">&lt;shools&gt;</color>
        <color name="green">&lt;school</color> id="45"<color name="green">&gt;</color>
          <color name="green">&lt;teachers&gt;</color>
            <color name="green">&lt;teacher</color> id="576"<color name="green">/&gt;</color>
            <color name="green">&lt;teacher</color> id="345"<color name="green">/&gt;</color>
            <color name="green">&lt;teacher</color> id="12"<color name="green">/&gt;</color>
          <color name="green">&lt;/teachers&gt;</color>
        <color name="green">&lt;/school&gt;</color>
        <color name="green">&lt;school</color> id="36"<color name="green">&gt;</color>
          <color name="green">&lt;teachers&gt;</color>
            <color name="green">&lt;teacher</color> id="576"<color name="green">/&gt;</color>
            <color name="green">&lt;teacher</color> id="8"<color name="green">/&gt;</color>
          <color name="green">&lt;/teachers&gt;</color>
        <color name="green">&lt;/school&gt;</color>
        [...]
      <color name="green">&lt;/shools&gt;</color>
    <color name="green">&lt;/dministrative-region&gt;</color>
    [...]
  <color name="green">&lt;/administrative-regions&gt;</color>
<color name="green">&lt;/education-system&gt;</color></verbatim>
                  <p>Die erste Datei beinhaltet eine Zuordnung von Lehrern zu Schulen in verschiedenen Regierungsbezirken. Um die Daten zu den beiden referenzierten Objekten einzusehen, müssen zwei weitere Dateien konsultiert werden. Die Datei, welche die Lehrer auflistet:</p>
                  <verbatim><color name="green">&lt;teachers&gt;</color>
  [...]
  <color name="green">&lt;teacher</color> id="576"<color name="green">&gt;</color>
    <color name="green">&lt;first-name&gt;</color>Alfons<color name="green">&lt;/first-name&gt;</color>
    <color name="green">&lt;last-name&gt;</color>Blimetsrieder<color name="green">&lt;/last-name&gt;</color>
    <color name="green">&lt;subjects&gt;</color>
      <color name="green">&lt;subject&gt;</color>Biology<color name="green">&lt;/subject&gt;</color>
      <color name="green">&lt;subject&gt;</color>Math<color name="green">&lt;/subject&gt;</color>
      <color name="green">&lt;subject&gt;</color>Sport<color name="green">&lt;/subject&gt;</color>
    <color name="green">&lt;/subjects&gt;</color>
    <color name="green">&lt;suspended&gt;</color>2017-12-31<color name="green">&lt;/suspended&gt;</color>
    [...]
  <color name="green">&lt;/teacher&gt;</color>
  [...]
<color name="green">&lt;/teachers&gt;</color></verbatim>
                  <p>Und die Datei, welche die Schulen auflistet:</p>
                  <verbatim><color name="green">&lt;schools&gt;</color>
  [...]
  <color name="green">&lt;school</color> id="45"<color name="green">&gt;</color>
    <color name="green">&lt;name&gt;</color>Gymnasium Bad Aibling<color name="green">&lt;/name&gt;</color>
    <color name="green">&lt;type&gt;</color>Oberschule<color name="green">&lt;/type&gt;</color>
    [...]
  <color name="green">&lt;/school&gt;</color>
  [...]
<color name="green">&lt;/schools&gt;</color></verbatim>
                  <p>Um diese Daten verarbeiten zu können ist es sinnvoll, die drei Dateien in einem ersten "Resolver" Schritt zusammenzuführen und ggf. irrelevante Strukturen zu entfernen. Lehrer aus obigem Beispiel können beispielsweise suspendiert worden sein. Das folgende Skript erledigt dies mittels einer zusätzlichen Transformation in eine Variable:</p>
                  <verbatim><color name="green">&lt;?xml</color> version="1.0" encoding="UTF-8"?<color name="green">&gt;</color>
<color name="green">&lt;xsl:stylesheet</color> version="2.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  exclude-result-prefixes="#all"<color name="green">&gt;</color>
  
  <color name="green">&lt;xsl:output</color> indent="yes" method="xml"<color name="green">/&gt;</color>
  
  <color name="green">&lt;xsl:strip-space</color> elements="*"<color name="green">/&gt;</color>
  
  <color name="green">&lt;xsl:param</color> name="file-1" required="yes"<color name="green">/&gt;</color>
  <color name="green">&lt;xsl:param</color> name="file-2" required="yes"<color name="green">/&gt;</color>
  <color name="green">&lt;xsl:param</color> name="file-3" required="yes"<color name="green">/&gt;</color>
  
  <color name="green">&lt;xsl:variable</color> name="files" select="(doc($file-1), doc($file-2), doc($file-3))"<color name="green">/&gt;</color>
  <color name="green">&lt;xsl:variable</color> name="bavaria-region-ids" select="(31, 58)"<color name="green">/&gt;</color>
  
  <color name="green">&lt;xsl:key</color> name="teachers" match="teacher" use="@id"<color name="green">/&gt;</color>
  <color name="green">&lt;xsl:key</color> name="schools" match="school" use="@id"<color name="green">/&gt;</color>
  
  <color name="green">&lt;xsl:template</color> name="main"<color name="green">&gt;</color>
    <color name="green">&lt;xsl:variable</color> name="resolve-result"<color name="green">&gt;</color>
      <color name="green">&lt;xsl:apply-templates</color> select="$files/administrative-regions" mode="resolve"<color name="green">/&gt;</color>
    <color name="green">&lt;/xsl:variable&gt;</color>
    <color name="green">&lt;xsl:apply-templates</color> select="$resolve-result/administrative-regions"<color name="green">/&gt;</color>
  <color name="green">&lt;/xsl:template&gt;</color>
  
  <color name="green">&lt;xsl:template</color> match="administrative-region[not(@id = $bavaria-region-ids)]" 
                mode="resolve"<color name="green">/&gt;</color>

  <color name="green">&lt;xsl:template</color> match="school" mode="resolve"<color name="green">&gt;</color>
    <color name="green">&lt;xsl:copy&gt;</color>
      <color name="green">&lt;xsl:copy-of</color> select="key('schools',@id, $files/schools[1]/root())/node()"<color name="green">/&gt;</color>
      <color name="green">&lt;xsl:apply-templates</color> select="node()|@*" mode="resolve"<color name="green">/&gt;</color>      
    <color name="green">&lt;/xsl:copy&gt;</color>
  <color name="green">&lt;/xsl:template&gt;</color>

  <color name="green">&lt;xsl:template</color> match="teacher" mode="resolve"<color name="green">&gt;</color>
    <color name="green">&lt;xsl:copy-of</color> select="key('teachers',@id, $files/teachers[1]/root())/node()"<color name="green">/&gt;</color>
  <color name="green">&lt;/xsl:template&gt;</color>
    
  <color name="green">&lt;xsl:template</color> match="teacher[suspended/xs:date(.) le current-date()]"<color name="green">/&gt;</color>
  
  <color name="green">&lt;xsl:template</color> match="node()|@*" mode="#all"<color name="green">&gt;</color>
    <color name="green">&lt;xsl:copy&gt;</color>
      <color name="green">&lt;xsl:apply-templates</color> mode="#current"<color name="green">/&gt;</color>
    <color name="green">&lt;/xsl:copy&gt;</color>
  <color name="green">&lt;/xsl:template&gt;</color>
  
<color name="green">&lt;/xsl:stylesheet&gt;</color></verbatim>
                  <p>Im ersten Resolve-Schritt werden die Referenzen zu den Lehrer- und Schul-Objekten aufgelöst, d.h. die Attribute des Schul-Objekts werden in die Struktur aus der ersten Datei kopiert. </p>
                  <p>Die Liste der Lehrer an diesen Schul-Objekten bleibt erhalten und wird mit dem Inhalt aus der zweiten Datei bestückt. </p>
                  <p>Zusätzlich werden alle Regierungsbezirke entfernt, die nicht zu Bayern gehören - was die weitere Verarbeitung wesentlich beschleunigen wird. Lehrer die suspendiert worden sind fliegen ebenfalls raus ...</p>
               
            
         </chapter>
         <chapter hyphenation="yes" chapterpage="no" id="888d37da-0dbe-4fae-bec9-2ad1e99f7818"
                  ismodule="no">
            
               <title>
                  <title id="d97b76dd-7b2b-48e3-9b9e-53a4197d41f8">Vererbung </title>
               </title>
               
                  <p>Mit XSLT kann man Konstrukte nachbilden, so wie sie in anderen Programmiersprachen auch vorhanden sind. Bspw. die Vererbung. Dabei wird in einer Spezialisierung eine schon bereits getätigte Implementierung übernommen und erweitert oder eingeschränkt.</p>
                  <p>Der Vorteil dabei ist, dass man nicht alles nochmal neu schreiben muss. Das verkleinert die Redundanz, führt zu einer besseren Wartbarkeit und einer geringeren Fehleranfälligkeit.</p>
                  <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                     id="df11855f-2b16-4ccb-b01c-f3ad33cc67bed6e8">
                     
                        <title>
                           <title id="3e8c9912-e49a-4cf3-8836-4c6d59415fcdd6e9">Beispiel: Parameterisierung</title>
                        </title>
                        <p>Gewöhnlich implementiert man ein Stylsheet für ein bestimmtes Ausgabeformat und eine Produktvariante. Schrittweise werden dann weitere Varianten und Formate hinzugefügt.</p>
                        <p>Am komfortabelsten hat man es natürlich, wenn zu Beginn der Implementierung eine vollständige Spezifikation vorliegt... Das ist aber natürlich eher selten der Fall.</p>
                        <p>Aus diesem Grund ist es wichtig, sich eine gute Strategie zu überlegen, damit die Architektur nicht in Spagetthi-Code auswartet.</p>
                        <p>Eine gute Option wäre, die XSLT Import Präzedenz auszunutzen, vgl. Kapitel <doclink class="db988919-f71e-437e-b699-b6fdd2a32cb9"
                           id="a66a728b-6a98-455a-a8e6-c68417213069"
                           type="topic">Eindeutigkeit der Regelbasis</doclink>.</p>
                        <p>Angenommen es geht darum zu einem späteren Zeitpunkt weitere Parameter einzuführen. Ein Switch, wie der folgende, müsste dann an mehreren Stellen im Code aktualisiert werden.</p>
                        <verbatim><color name="green">&lt;xsl:choose&gt;</color>
    <color name="green">&lt;xsl:when</color> test="$myParameter='this_option'"<color name="green">&gt;</color>
        &lt;!-- do this --&gt;
    <color name="green">&lt;/xsl:when&gt;</color>
    <color name="green">&lt;xsl:when</color> test="$myParameter='that_option'"<color name="green">&gt;</color>
        &lt;!-- do that --&gt;
    <color name="green">&lt;/xsl:when&gt;</color>
        [...]
<color name="green">&lt;/xsl:choose&gt;</color></verbatim>
                        <p>Besser ist es, wenn man ein Core-Stylesheet pflegt, das für ein Format und eine Produktvariante gut ausgetestet ist. Dieses Core-Stylesheet wird dann einfach für eine neue Variante importiert und relevante Teile werden für die neue "Spezialisierung" überschrieben. Beispielsweise könnte eine Regel zum Setzen des Headers auf jeder Seite so implementiert sein:</p>
                        <verbatim><color name="green">&lt;xsl:template</color> name="render-header"<color name="green">&gt;</color>
    &lt;!-- print logo on the left side spanning two rows--&gt;
    &lt;!-- print some metadata right side first row --&gt;
    &lt;!-- print a running header right side second row --&gt;
<color name="green">&lt;/xsl:template&gt;</color></verbatim>
                        <p>Will man in einem neuen Format, bspw. A5, diese Logik austauschen und nur eine Zeile drucken, z.B. weil man nicht so viel Platz hat, so würde in einem "abgeleiteten" Stylesheet einfach die Regel noch einmal implementiert.</p>
                        <verbatim><color name="green">&lt;xsl:choose&gt;</color>
<color name="green">&lt;xsl:template</color> name="render-header"<color name="green">&gt;</color>
    &lt;!-- print a running header on left side --&gt;
    &lt;!-- print logo on right side --&gt;
<color name="green">&lt;/xsl:template&gt;</color></verbatim>
                        <p>Dieses Template hat nun Vorrang und wird zur Auswertung herangezogen, mit der Konsequenz, dass der Header nur einzeilig gedruckt wird. Das schöne an diesen "Named-Templates" ist auch, dass man sie innerhalb von Variablen verwenden kann:</p>
                        <verbatim><color name="green">&lt;xsl:variable</color> name="margin-width"<color name="green">&gt;</color>
    <color name="green">&lt;xsl:call-template</color> name="get-margin-width"<color name="green">/&gt;</color>
<color name="green">&lt;/xsl:variable&gt;</color></verbatim>
                        <p>Das Template "get-margin-width" kann in einem "Sub"-Stylesheet überschrieben werden ohne dass die Variablen-Zugriffe im Core-Stylesheet angepasst werden müssten. Eine Zuweisung, wie:</p>
                        <verbatim>width="{<color name="red">$margin-width</color>}"</verbatim>
                        <p>müsste nirgendwo im Code nochmal angefasst werden.</p>
                     
                  </chapter>
               
            
         </chapter>
         <chapter hyphenation="yes" chapterpage="no" id="1f8595d0-4ed9-4070-8cff-c5c59f690093"
                  ismodule="no">
            
               <title>
                  <title id="cb79aa28-6141-41b3-9bb7-5dc5f10cd81d">XSLT Streaming</title>
               </title>
               
                  <p>Bei grossen flach strukturierten Datenmengen gibt es zwei Möglichkeiten:</p>
                  <procedure type="ol">
                     <step>
                        <action>
                           <p>Für einfache Sammel- und Auswertungsaufgaben schreibt man sich am besten einen kleinen Parser, z.B. mit der Python<url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                             address="https://docs.python.org/2/library/sgmllib.html">sgmllib</url>.</p>
                        </action>
                     </step>
                     <step>
                        <action>
                           <p>Für komplexere Aufgaben, in denen man nicht an jeder Stelle über den ganzen XML Baum navigiert und sich die Werte zusammensuchen suchen muss, kann man die Streaming Funktion des Saxon XSLT Prozessors verwenden.</p>
                        </action>
                     </step>
                  </procedure>
                  <p>XSLT Streaming ist in der <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                    address="https://www.saxonica.com/html/documentation/sourcedocs/streaming/xslt-streaming.html">XSLT Version 3.0</url> neu hinzugekommen und in der
kommerziellen <url xmlns:tektur="http://www.stylesheet-entwicklung.de" address="">Saxon-EE Löusug </url> implementiert. Bei dieser Methode wird kein Eingabebaum im Speicher aufgebaut, was zu einer drastischen Performanzsteigerung führt.</p>
                  <p>Es gibt ein paar Regeln, die man bei der Verarbeitung großer Datenmengen über die Streaming Funktionen beachten sollte:</p>
                  <ul>
                     <li>
                        <p>Bei einer XPATH Auswertung sollte nur ein einfacher Ausdruck mit höchstens einer konsumierenden Selektion gegeben sein. Konsumieren heißt, dass vom Kontextknoten aus eine Knotenmenge abwärts selektiert wird. Dagegen bleibt die Information bzgl. der Ancestor-Achse erhalten.</p>
                     </li>
                     <li>
                        <p>Bei einer Selektion sollte man aber darauf achten nur atomarische Werte auszuwählen.</p>
                     </li>
                     <li>
                        <p>Knotenmengen, die über die Streaming Option eingelesen wurden, können nicht einer Funktion übergeben werden. Sie sind auch nicht einer Variablen zuweisbar.</p>
                     </li>
                     <li>
                        <p>"Crawler”-Ausdrücke, wie <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                        <nb>//section</nb>
                     </code> sind nicht nicht zu verwenden, ebenso ein rekursiver Abstieg mit Selektion, wie bspw. mit einem <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                        <nb>apply-templates</nb>
                     </code> Call.</p>
                     </li>
                  </ul>
                  <p>Zu Beginn der Streaming-Aktion kann man sich auf konventionelle Art und Weise Teilbäume, die nicht so performanzlastig aufgebaut werden, in einer Variablen abspeichern und im Verlauf der Streaming-Verarbeitung z.B. für einen Vergleich auswerten.</p>
               
            
            <chapter hyphenation="yes" chapterpage="no" id="51bec5b9-1207-45cc-9bf2-b6ce3e300547"
                     ismodule="no">
               
                  <title>
                     <title id="40515442-a67d-49f4-9945-0f9d227bd97e">XSLT Akkumulator</title>
                  </title>
                  
                     <p>Ein einfaches Streaming Stylesheet könnte z.B. so aussehen:</p>
                     <verbatim><color name="green">&lt;xsl:stylesheet</color> version="3.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  exclude-result-prefixes="#all"<color name="green">&gt;</color>
  
  <color name="green">&lt;xsl:output</color> method="xml" indent="yes"<color name="green">/&gt;</color>
  
  <color name="green">&lt;xsl:mode</color> on-no-match="shallow-copy" use-accumulators="entry-count" streamable="true"<color name="green">/&gt;</color>
  
  <color name="green">&lt;xsl:accumulator</color> name="entry-count" as="xs:integer" initial-value="0" 
                   streamable="yes"<color name="green">&gt;</color>
    <color name="green">&lt;xsl:accumulator-rule</color> match="entry" select="$value + 1"<color name="green">/&gt;</color>
  <color name="green">&lt;/xsl:accumulator&gt;</color>
  
  <color name="green">&lt;xsl:template</color> match="/"<color name="green">&gt;</color>
    <color name="green">&lt;result&gt;</color>
      <color name="green">&lt;xsl:apply-templates/&gt;</color>
      <color name="green">&lt;count&gt;</color>
        <color name="green">&lt;xsl:value-of</color> select="accumulator-after('entry-count')"<color name="green">/&gt;</color> 
      <color name="green">&lt;/count&gt;</color>
    <color name="green">&lt;/result&gt;</color>
  <color name="green">&lt;/xsl:template&gt;</color>
  
<color name="green">&lt;/xsl:stylesheet&gt;</color></verbatim>
                     <p>Diese Stylesheet hat einige Besonderheiten:</p>
                     <p>Zum einen wird darin ein Default-Modus deklariert, der jeden Knoten der Eingabeinstanz über
eine implizite <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                       address="https://www.saxonica.com/html/documentation/xsl-elements/mode.html">Identity-Transformation (shallow-copy)</url>in die Ausgabeinstanz kopiert.</p>
                     <p>Auf herkömmlichem Weg würde man dafür ein Templates wie dieses verwenden:</p>
                     <verbatim><color name="green">&lt;xsl:template</color> match="node()|@*"
  &lt;xsl:copy<color name="green">&gt;</color>
    <color name="green">&lt;xsl:apply-templates</color> select="node()|@*"<color name="green">/&gt;</color>
  <color name="green">&lt;/xsl:copy&gt;</color>
<color name="green">&lt;/xsl:template&gt;</color></verbatim>
                     <p>Zum anderen wird ein Akkumulator verwendet. Normalerweise gibt es in XSLT keine Variablen,
sondern nur Konstanten, so wie das auch bei funktionalen Programmiersprachen der Fall ist.</p>
                     <p>Es gab zwar schon länger eine Saxon-Erweiterung, die die mehrmalige Zuweisung eines Wertes
an eine Variable erlaubte, im Normallfall braucht man diese Eigenschaft aber nicht.</p>
                     <p>Ber der Verarbeitung sehr großer Datemengen, ist es aber unumgänglich, denn sonst
würde der Laufzeitstapel schnell an seine Grenzen gelangen.</p>
                     <p>Ein Akkumulator akkumuliert Werte, wie der Name schon sagt. Das können atomare Typen sein,
wie im obigen Beispiel, aber auch Datenstrukturen können aufgebaut werden, wie 
bspw. das Abspeichern des gerade prozessierten Teilbaums in einem Dictionary zur 
späteren Auswertung bzw. Gruppierung der Key-Elemente.</p>
                     <p>Auch im Akkumulator muss das <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>streamable="yes"</nb>
                  </code> Property gesetzt sein, wenn er im 
Streaming-Modus arbeiten soll. In diesem Modus kann der Akkumulatorwert erst ausgelesen werden,
wenn der untersuchte Baum vollständig durchlaufen wurde.</p>
                     <p>Um die Unterschiede zum "normalen" XSLT Betrieb festzustellen, können im obigen Beispiel 
einige offensichtlich korrekte Änderungen vorgenommen werden, die der Streaming 
Prozessor allerdings nicht akzeptiert.</p>
                     <verbatim>Cannot call accumulator-after except during the post-descent 
phase of a streaming template</verbatim>
                     <p>Diese Fehlermeldung erscheint, wenn man den <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>apply-templates</nb>
                  </code> Call entfernt. Der Akkumulator
wird also nur befüllt, wenn der Baum auch explizit durchlaufen wurde. Dieser Durchlauf 
kann auch ein reines Kopieren sein, bspw. kann man den <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>apply-templates</nb>
                  </code> Call auch durch ein</p>
                     <verbatim><color name="green">&lt;xsl:copy-of</color> select="."<color name="green">/&gt;</color></verbatim>
                     <p>ersetzen, was gleichbedeutend mit der Mode Einstellung</p>
                     <verbatim>on-no-match="deep-copy"</verbatim>
                     <p>wäre. Wie man sieht hat sich in XSLT 3.0 viel bzgl. der Handhabung verschiedener
Verarbeitungsmodi getan. Anstatt Default-Match Regeln zu schreiben, kann man ganz oben
am Stylesheet Modus Properties setzen, die den Baumdurchlauf auf verschiedene
Arten realisieren.</p>
                     <p>Die Verarbeitung großer Datenmenden ist aber mit Streaming etwas tricky und es sollte geprüft 
werden, ob ggf. konventionelles Performanz-optimiertes XSLT für den Answendungsfall ausreichen
würde.</p>
                  
               
            </chapter>
            <chapter hyphenation="yes" chapterpage="no" id="b308e60a-c7f3-4143-8e04-6c0d3bd4df01"
                     ismodule="no">
               
                  <title>
                     <title id="8a54eb22-afbb-4741-b3e5-8088e75c9ebd">XSLT Iterator</title>
                  </title>
                  
                     <p>XSLT Streaming ist ziemlich tricky. Betrachten wir ein einfaches Problem. Es soll ein kommaseparierter Report aus folgender XML Quelle generiert werden.</p>
                     <verbatim><color name="green">&lt;status-report&gt;</color>
  <color name="green">&lt;status-change&gt;</color>
    <color name="green">&lt;billing_id&gt;</color>360788<color name="green">&lt;/dentaltrac_encounter_id&gt;</color>
    <color name="green">&lt;claim_ids&gt;</color>967382,673647<color name="green">&lt;/claim_ids&gt;</color>
    <color name="green">&lt;status&gt;</color>open<color name="green">&lt;/status&gt;</color>
    <color name="green">&lt;time_stamp&gt;</color>2019-02-22T13:53:34.605Z<color name="green">&lt;/status_time&gt;</color>
  <color name="green">&lt;/status-change&gt;</color>
  <color name="green">&lt;status-change&gt;</color>
    <color name="green">&lt;billing_id&gt;</color>360788<color name="green">&lt;/dentaltrac_encounter_id&gt;</color>
    <color name="green">&lt;claim_ids&gt;</color>967382,673647<color name="green">&lt;/claim_ids&gt;</color>
    <color name="green">&lt;status&gt;</color>open<color name="green">&lt;/status&gt;</color>
    <color name="green">&lt;time_stamp&gt;</color>2019-02-22T13:53:34.605Z<color name="green">&lt;/status_time&gt;</color>
  <color name="green">&lt;/status-change&gt;</color>
  [...]</verbatim>
                     <p>Mit einer <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>for-each</nb>
                  </code> Loop und einem Named-Template würde das so gehen:</p>
                     <verbatim>
<color name="green">&lt;xsl:template</color> name="main"<color name="green">&gt;</color>
  <color name="green">&lt;xsl:for-each</color> select="$input-file/status-report/status-change"<color name="green">&gt;</color>
    <color name="green">&lt;xsl:value-of</color> select="concat(billing_id,',')"<color name="green">/&gt;</color>
    <color name="green">&lt;xsl:value-of</color> select="concat(claim_ids,',')"<color name="green">/&gt;</color>
    <color name="green">&lt;xsl:value-of</color> select="concat(status,',')"<color name="green">/&gt;</color>
    <color name="green">&lt;xsl:value-of</color> select="concat(format-dateTime(xs:dateTime(time_stamp),
                                        '[Y]-[M]-[D] [H]:[m]'),'&amp;#10;')"<color name="green">/&gt;</color>
  <color name="green">&lt;/xsl:for-each&gt;</color>
<color name="green">&lt;/xsl:template&gt;</color></verbatim>
                     <note>
                        <consequence>
                           <p>Named-Templates, die direkt über den Saxon Aufruf <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                           <nb>saxon -it:main</nb>
                        </code> aufgerufen werden, sind dann
brauchbar, wenn keine eindeutige Eingabequelle vorhanden ist, bspw. weil aus mehreren
Quellen eingelesen werden soll, wenn die Eingabe von einem Webservice kommt oder 
vom XSLT Skript selbst erzeugt wird.</p>
                        </consequence>
                     </note>
                     <p>Im vorliegenden Fall wird von einer Datei eingelesen - wir brauchen also kein Named-Template. Statt der  Schleife können wir uns auch auf den rekursiven Abstieg des XSLT Prozessors
verlassen, was den Code weiter vereinfacht:</p>
                     <verbatim>
<color name="green">&lt;xsl:template</color> match="/status-report/status-change"<color name="green">&gt;</color>
  <color name="green">&lt;xsl:value-of</color> select="concat(billing_id,',')"<color name="green">/&gt;</color>
  <color name="green">&lt;xsl:value-of</color> select="concat(claim_ids,',')"<color name="green">/&gt;</color>
  <color name="green">&lt;xsl:value-of</color> select="concat(status,',')"<color name="green">/&gt;</color>
  <color name="green">&lt;xsl:value-of</color> select="concat(format-dateTime(xs:dateTime(time_stamp),
                                      '[Y]-[M]-[D] [H]:[m]'),'&amp;#10;')"<color name="green">/&gt;</color>
<color name="green">&lt;/xsl:template&gt;</color></verbatim>
                     <p>Wollen wir große Datenmengen schnell verarbeiten mit ein paar Hundert MB, so ist es sinnvoll
auf die neue XSLT3.0 Streaming Option umzuschalten, weil dadurch kein Eingabebaunm in-Memory
aufgebaut wird. Wie schon im Kapitel <doclink class="51bec5b9-1207-45cc-9bf2-b6ce3e300547"
                           id="3488cd63-8d28-404a-8c32-6694daa8c6bb"
                           type="topic">XSLT Akkumulator</doclink> angesprochen, gibt es dazu mehrere Möglichkeiten.</p>
                     <p>Wir betrachten hier das <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>xsl:iterator</nb>
                  </code>
                  <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                       address="https://www.saxonica.com/html/documentation/xsl-elements/iterate.html">(Doku)</url>
 Konstrukt und stossen dabei auf einige Fallstricke. Zunächst einmal unsere Settings:</p>
                     <ul>
                        <li>
                           <p>Wir benutzen <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                           <nb>xsl:source-document</nb>
                        </code> in Verbindung mit dem <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                           <nb>streamable='yes'</nb>
                        </code> Attribut,
um dem Prozessor mitzuteilen, dass er im Streaming Modus arbeiten soll.</p>
                        </li>
                        <li>
                           <p>Wenn wir die Quelle über einen Parameter einlesen, dann müssen wir auch die Transformation über ein Named-Template
starten.</p>
                        </li>
                     </ul>
                     <p>Ohne zu wissen, wie XSLT Streaming genau funktioniert, setzen wir eine Reihe von <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>value-of select</nb>
                  </code> statements in den Iterator:</p>
                     <verbatim>
<color name="green">&lt;xsl:template</color> name="main"<color name="green">&gt;</color>
  <color name="green">&lt;xsl:source-document</color> href="{$input-file}" streamable='yes'<color name="green">&gt;</color>
    <color name="green">&lt;xsl:iterate</color> select="status-report/status-change"<color name="green">&gt;</color>
      <color name="green">&lt;xsl:value-of</color> select="concat(billing_id,',')"<color name="green">/&gt;</color>
      <color name="green">&lt;xsl:value-of</color> select="concat(claim_ids,',')"<color name="green">/&gt;</color>
      <color name="green">&lt;xsl:value-of</color> select="concat(status,',')"<color name="green">/&gt;</color>
      <color name="green">&lt;xsl:value-of</color> select="concat(format-dateTime(xs:dateTime(time_stamp),
                                          '[Y]-[M]-[D] [H]:[m]'),'&amp;#10;')"<color name="green">/&gt;</color>
    <color name="green">&lt;/xsl:iterate&gt;</color>
  <color name="green">&lt;/xsl:source-document&gt;</color> 
<color name="green">&lt;/xsl:template&gt;</color></verbatim>
                     <p>und werden dafür prompt mit einer Fehlermeldung belohnt:</p>
                     <verbatim>Static error on line 16 column 64 of report.xsl:
  XTSE3430: The body of the xsl:stream instruction is not streamable
  *  There is more than one consuming operand: {xsl:value-of} on line 18, and
  {xsl:value-of} on line 19</verbatim>
                     <p>In diesem Iterator ist also nur eine "konsumierende" <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>value-of</nb>
                  </code> Operation erlaubt. Um nur einmal zu selektieren, müssen wir - auf Kosten der Lesbarkeit - ziemlich umbauen. Eine Lösung könnte z.B. so aussehen:</p>
                     <verbatim><color name="green">&lt;?xml</color> version="1.0" encoding="UTF-8"?<color name="green">&gt;</color>
<color name="green">&lt;xsl:stylesheet</color> xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  exclude-result-prefixes="xs"
  xpath-default-namespace="https://tekturcms.de/schema/status-report/1.0"
  version="3.0"<color name="green">&gt;</color>
   
  <color name="green">&lt;xsl:param</color> name="input-file" required="yes"<color name="green">/&gt;</color>
  
  <color name="green">&lt;xsl:output</color> method="text"<color name="green">/&gt;</color>
 
  &lt;!-- https://www.saxonica.com/html/documentation/xsl-elements/iterate.html --&gt;

  <color name="green">&lt;xsl:template</color> name="main"<color name="green">&gt;</color>
    <color name="green">&lt;xsl:source-document</color> href="{$input-file}" streamable='yes'<color name="green">&gt;</color>
      <color name="green">&lt;xsl:iterate</color> select="status-report/status-change/*"<color name="green">&gt;</color>
        <color name="green">&lt;xsl:choose&gt;</color>
          <color name="green">&lt;xsl:when</color> test="name()='time_stamp'"<color name="green">&gt;</color>
            <color name="green">&lt;xsl:value-of</color> select="concat(format-dateTime(xs:dateTime(time_stamp),
                                               '[Y]-[M]-[D] [H]:[m]'),'&amp;#10;')"<color name="green">/&gt;</color>
          <color name="green">&lt;/xsl:when&gt;</color>
          <color name="green">&lt;xsl:otherwise&gt;</color>
            <color name="green">&lt;xsl:value-of</color> select="concat(.,',')"<color name="green">/&gt;</color>
          <color name="green">&lt;/xsl:otherwise&gt;</color>
        <color name="green">&lt;/xsl:choose&gt;</color>
      <color name="green">&lt;/xsl:iterate&gt;</color>
    <color name="green">&lt;/xsl:source-document&gt;</color>
  <color name="green">&lt;/xsl:template&gt;</color>  
<color name="green">&lt;/xsl:stylesheet&gt;</color>
</verbatim>
                     <p>Hier wird davon ausgegangen, dass das Element mit Namen 'time_stamp' als letztes in der Sequenz vorkommt und beim Auftreten (<code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>&amp;#10;</nb>
                  </code>) wird ein Zeilenumbruch gesetzt. Der deklarative Ansatz aus dem ersten Beispiel geht dabei verloren. </p>
                     <note>
                        <consequence>
                           <p>Logisch wird beim XSLT Streaming auf einer niedrigeren Abstraktionsebene programmiert, um den Anforderungen des Prozessors gerecht zu werden.</p>
                        </consequence>
                     </note>
                     <p>Für eine <b>1.6 GB Datei</b> benötigt das obige Skript auf meinem Rechner gute<b> drei Minuten</b>. Der traditionelle temlate-match Ansatz bricht mit einer Out-of-Memory Exception ab, selbst wenn man den Java Heap Size auf 4GB einstellt.</p>
                  
               
            </chapter>
         </chapter>
         <chapter hyphenation="yes" chapterpage="no" id="e3ccdc75-56e4-45b3-a2be-07a61a2dcd51"
                  ismodule="no">
            
               <title>
                  <title id="6e53fba3-c83c-4a92-8cea-170e5781324c">Identifikation mit <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>generate-id()</nb>
                  </code>
               </title>
               </title>
               
                  <p>Die <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>generate-id()</nb>
               </code> Funktion gibt es in XSLT schon immer. Mit ihr kann eine Prüfsumme eines Knotens im Baum generiert werden.</p>
                  <p>Das funktioniert natürlich nur, wenn man bei der Auswertung dieses Wertes nicht den Kontext wechselt. D.h. z.B. dass ein Knoten in einem Baum,
der in einer Variablen gespeichert ist, eine andere Prüfsumme bekommt, als derselbe Knoten im Kontext-Baum.</p>
                  <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                     id="15182a91-9dc5-4632-9c80-05f50c8fc942d6e8">
                     
                        <title>
                           <title id="fc5861f4-cba9-4568-8ebe-a70d04f46a66d6e9">Beispiel Stückliste</title>
                        </title>
                        <p>Ein Anwendungszenario wäre bspw. die Generierung einer Target-ID für ein Bauteil in einer Stückliste. Das Bauteil ist nur einmal im 
System erfasst, hat also eine eindeutige ID, soll aber an mehreren Stellen in die Ausgabe (Eine Dokumentation für eine Maschine)
generiert werden.</p>
                        <p>Die Id an einem Element <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>&lt;part id=“1234”&gt;</nb>
                  </code> würde somit mehrfach in die XML Eingabe für einen XSL-FO Prozessor erscheinen und ist 
für Referenzen unbrauchbar geworden.  Deshalb ist es ratsam beim Rendern der Bauteile eine neue Id zu vergeben, das kann z.B. 
mit den folgenden Templates (vereinfacht) passieren:</p>
                        <verbatim><color name="green">&lt;xsl:key</color> name="parts" match="part" use="@id"<color name="green">/&gt;</color>
  
<color name="green">&lt;xsl:template</color> match=“part” mode=“content"<color name="green">&gt;</color>
  &lt;!-- Ausgabe des Bauteils im Content Bereich --&gt;
  <color name="green">&lt;fo:block</color> id="{generate-id()}"<color name="green">&gt;</color>
    <color name="green">&lt;fo:external-graphic</color> xsl:use-attribute-sets="part.img"<color name="green">/&gt;</color>  
  <color name="green">&lt;/fo:block&gt;</color>
<color name="green">&lt;/xsl:template&gt;</color>
    
<color name="green">&lt;xsl:template</color> match=“part” mode=“part-list"<color name="green">&gt;</color>
  &lt;!-- Ausgabe einer Liste mit allen Verweisen an unterschiedicher Stelle --&gt;
  <color name="green">&lt;fo:block&gt;</color>
    <color name="green">&lt;xsl:for-each</color> select="key('parts',@id)"<color name="green">&gt;</color>
      <color name="green">&lt;fo:page-number-citation</color> ref-id="{generate-id()}"<color name="green">/&gt;</color>
    <color name="green">&lt;/xsl:for-each&gt;</color>
  <color name="green">&lt;/fo:block&gt;</color>
<color name="green">&lt;/xsl:template&gt;</color></verbatim>
                     
                  </chapter>
                  <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                     id="f95ff6a2-1583-451f-b21a-8f4761eb4e46d6e17">
                     
                        <title>
                           <title id="90386d0e-7162-471c-8c09-8bb00da36da5d6e17">Beispiel Mantel Dokument</title>
                        </title>
                        <p>Im Bereich EDI Datenaustausch werden große XML Dateien versendet, die man auf einzelne Transmissions 
aufsplitten will, um sie in einer XML Datenbank abspeichern zu können. Die Struktur einer Datenübertragung
könnte folgendermassen aussehen:</p>
                        <verbatim>WRAPPER1
  SEQUENZ1
  SEQUENZ2
  SEQUENZ3
  WRAPPER2
    SEQUENZ1
    SEQUENZ2
    SEQUENZ3
    SEQUENZ4
    WRAPPER3
      SEQUENZ1
      SEQUENZ2
      CONTENT
        DATA1
        DATA2
        DATA3
        DATA4
        DATA5
      CONTENT
        DATA1
        DATA2
        DATA3
        DATA4
        DATA5
      WRAPPER4
        SEQUENZ1
      CONTENT
        DATA1
        DATA2
        DATA3
        DATA4
        DATA5
      [...]</verbatim>
                        <p>Jedes einzelne <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>CONTENT</nb>
                  </code> Element soll nun einen Mantel erhalten und separat in einer Datei abgelegt werden.
Der "Umschlag" soll dabei alle Elemente des Rahmens der Transmission erhalten. Also alles auf der
Descendant-Achse bis zum Element <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>WRAPPER3</nb>
                  </code>, ausserdem noch die Elemente <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>SEQUENZ1</nb>
                  </code> und <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>SEQUENZ2</nb>
                  </code>,
sowie das Element <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>WRAPPER4</nb>
                  </code> mit Kind <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>SEQUENZ1</nb>
                  </code> .Ohne groß auf die Performanz zu achten, könnte das recht einfach so realisiert werden:</p>
                        <verbatim><color name="green">&lt;xsl:stylesheet</color> xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"<color name="green">&gt;</color>
    
  <color name="green">&lt;xsl:output</color> method="xml" indent="yes"<color name="green">/&gt;</color>
  <color name="green">&lt;xsl:strip-space</color> elements="*"<color name="green">/&gt;</color>
  
  <color name="green">&lt;xsl:template</color> match="/"<color name="green">&gt;</color>
    <color name="green">&lt;xsl:apply-templates</color> select="/WRAPPER1/WRAPPER2/WRAPPER3/CONTENT" mode="umschlag"<color name="green">/&gt;</color>
  <color name="green">&lt;/xsl:template&gt;</color>
    
  <color name="green">&lt;xsl:template</color> match="CONTENT" mode="umschlag"<color name="green">&gt;</color>
    <color name="green">&lt;xsl:result-document</color> href="{concat(@id,'.xml')}"<color name="green">&gt;</color>
      <color name="green">&lt;umschlag&gt;</color>
        <color name="green">&lt;metadaten&gt;</color>&lt;!-- einige Metadaten --&gt;<color name="green">&lt;/env:metadata&gt;</color>
        <color name="green">&lt;nutzdaten&gt;</color>
            <color name="green">&lt;xsl:apply-templates</color> select="ancestor::WRAPPER1"<color name="green">&gt;</color>
              <color name="green">&lt;xsl:with-param</color> name="this-id" select="generate-id()" tunnel="yes"<color name="green">/&gt;</color>
            <color name="green">&lt;/xsl:apply-templates&gt;</color>
        <color name="green">&lt;/nutzdaten&gt;</color>
      <color name="green">&lt;/umschlag&gt;</color>
    <color name="green">&lt;/xsl:result-document&gt;</color>
  <color name="green">&lt;/xsl:template&gt;</color>

  <color name="green">&lt;xsl:template</color> match="node()|@*"<color name="green">&gt;</color>
    <color name="green">&lt;xsl:copy&gt;</color>
      <color name="green">&lt;xsl:apply-templates</color> select="node()|@*"<color name="green">/&gt;</color>
    <color name="green">&lt;/xsl:copy&gt;</color>
  <color name="green">&lt;/xsl:template&gt;</color>
    
  <color name="green">&lt;xsl:template</color> match="CONTENT"<color name="green">&gt;</color>
    <color name="green">&lt;xsl:param</color> name="this-element" tunnel="yes"<color name="green">/&gt;</color>
    <color name="green">&lt;xsl:if</color> test="$this-id = generate-id()"<color name="green">&gt;</color>
      <color name="green">&lt;xsl:copy&gt;</color>
        <color name="green">&lt;xsl:apply-templates</color> select="node()|@*"<color name="green">/&gt;</color>
      <color name="green">&lt;/xsl:copy&gt;</color>
    <color name="green">&lt;/xsl:if&gt;</color>
  <color name="green">&lt;/xsl:template&gt;</color>
    
<color name="green">&lt;/xsl:stylesheet&gt;</color></verbatim>
                        <p>Im rekursiven Abstieg wird im Modus "umschlag" jedes <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>CONTENT</nb>
                  </code> Element selektiert und
in einen Umschlag verpackt. Der eigentlich Inhalt des Umschlags wird generiert,
indem der gesamte XML Baum über die Standard-Kopierregel in das Element <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>&lt;nutzdaten&gt;</nb>
                  </code> gesetzt wird. Dabei wird aber nur derjenige <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>CONTENT</nb>
                  </code> Abschnitt evaluiert, der
zu der als Parameter übergebenen generierten Id passt.</p>
                     
                  </chapter>
               
            
         </chapter>
         <chapter hyphenation="yes" chapterpage="no" id="12f4b667-2093-456b-8986-d269a6375d60"
                  ismodule="no">
            
               <title>
                  <title id="a3acd735-e2ec-4c5f-940d-72d647e5bd74">Reguläre Ausdrücke</title>
               </title>
               
                  <p>Manchmal reicht für das Durchsuchen des XML Baums XPATH nicht mehr aus und man will auf den Textknoten reguläre Ausdrücke aufrufen. Mir sind derzeit drei XPATH Funktionen bekannt, in denen man XPATH angeben kann:</p>
                  <ul>
                     <li>
                        <p>
                     <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                        <nb>fn:matches(subject, pattern, flags)</nb>
                     </code>
                  </p>
                     </li>
                     <li>
                        <p>
                     <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                        <nb>fn:replace(subject, pattern, replacement, flags)</nb>
                     </code>
                  </p>
                     </li>
                     <li>
                        <p>
                     <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                        <nb>fn:tokenize(subject, pattern, flags)</nb>
                     </code>
                  </p>
                     </li>
                  </ul>
                  <p>Bei der EIngabe des regulaären Ausdrucks muss man natürlich Zeichen, wie <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>&gt;,&lt;,&amp;</nb>
               </code> maskieren, was den Ausdruck im Gegensatz zur herkömmlichen Nicht-XML Programmierung noch ein bisschen komplizierter macht.</p>
                  <p>Der Audruck, der bspw. auf alle XML Tags matched ist folgender: <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>&amp;lt;[^&amp;gt;^!]+&amp;gt;</nb>
               </code>. Hier sind die für XML reservierten Zeichen bereits maskiert.</p>
                  <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                     id="4f0ab2b5-80b9-4cba-9bfb-5c3f37d9887ad6e20">
                     
                        <title>
                           <title id="055ae7ca-d2b1-41e4-be84-675e3e8827bdd6e21">XSLT Analyze String</title>
                        </title>
                        <p>Es gibt aber auch ein eigenes XSLT Konstrukt, unabhängig von XPATH, um reguläre Ausdrücke anwenden zu können. Der Quelltext dazu sieht so aus:</p>
                        <verbatim><color name="green">&lt;xsl:template</color> match="text()[parent::xml-code]"<color name="green">&gt;</color>
  &lt;xsl:analyze-string select="." regex="&amp;lt;[^&amp;gt;^!]+&amp;gt;"&gt;
    <color name="green">&lt;xsl:matching-substring&gt;</color>
      <color name="green">&lt;b&gt;</color><color name="green">&lt;xsl:value-of</color> select="."<color name="green">/&gt;</color><color name="green">&lt;/b&gt;</color>     
    <color name="green">&lt;/xsl:matching-substring&gt;</color>
    <color name="green">&lt;xsl:non-matching-substring&gt;</color>
      <color name="green">&lt;xsl:value-of</color> select="."<color name="green">/&gt;</color>
    <color name="green">&lt;/xsl:non-matching-substring&gt;</color>
<color name="green">&lt;/xsl:template&gt;</color></verbatim>
                        <p>Hier wird jeder Textknoten eines Elements untersucht und falls ein XML-Tag enthalten ist, so wird dieses über die <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>xsl:matching-substring</nb>
                  </code> Anweisung in ein <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>&lt;b&gt;</nb>
                  </code> Tag gewrapped. Im nächsten Transformationsschritt wird dieses wiederum in Fettschrift dargestellt.</p>
                        <p>Das ist ein einfacher Syntax-Highlighter für XML Quelltexte. Auf diese Weise ist der Syntax-Highlighter für dieses PDF realisiert.</p>
                        <note>
                           <consequence>
                              <p>Man kann auch die <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                           <nb>xsl:analyze-string</nb>
                        </code> Elemente in den <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                           <nb>xsl:matching-substring</nb>
                        </code> und <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                           <nb>xsl:non-matching-substring</nb>
                        </code> Elementen verschachteln, was natürlich noch wesentlich kompliziertere Problemstellungen erlaubt.</p>
                           </consequence>
                        </note>
                     
                  </chapter>
               
            
         </chapter>
         <chapter hyphenation="yes" chapterpage="no" id="11ebc17e-560c-4961-8dd6-9aa6776dc160"
                  ismodule="no">
            
               <title>
                  <title id="fbbe8267-ed7b-4b78-b547-d00fe41f0b5c">Webservice Calls mit <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>doc()</nb>
                  </code> und <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>unparsed-text()</nb>
                  </code>
               </title>
               </title>
               
                  <p>Eine verbreitete Paxis ist es, mit der Funktion <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>document()</nb>
               </code> oder kurz <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>doc()</nb>
               </code> 
entfernte Ressourcen in die Transformation einzubinden. 
Bei einer Schematron-Validierung, würde bspw. eine Regel, wie:</p>
                  <verbatim><color name="green">&lt;sch:not-assert</color> id="personal-check"
    role="error"
    test="doc(concat('https://tekturcms.de/personal.xqy?personal-id=',personal-id))/kuendigung"<color name="green">&gt;</color>
        Angestellter mit ID "<color name="green">&lt;sch:value-of</color> select="personal-id"<color name="green">/&gt;</color>" hat gekündigt!
<color name="green">&lt;/sch:not-assert&gt;</color></verbatim>
                  <p>einen entferneten Webservice aufrufen und prüfen, ob für den Angestellten mit <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>personal-id</nb>
               </code>
eine Kündigung vorliegt. Ist dies der Fall, so ist die negative Zusicherung <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>not-assert</nb>
               </code> nicht
erfüllt und die Schematron Regel feuert - was sich wohl im einfachsten Fall in einem 
Logfile Eintrag äussern sollte.</p>
                  <p>Was vermutlich viele noch nicht kennen - ich nehme jetzt einfach mal an, dass mein 
bisheriger Kenntnisstand dem der Mehrheit der XML-Entwickler entspricht - ist der Umstand,
dass auch die Funktion <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>unparsed-text()</nb>
               </code> eine URL als Parameter nimmt:</p>
                  <verbatim><color name="green">&lt;xsl:template</color> match="angestellter"
    &lt;xsl:copy<color name="green">&gt;</color>
        <color name="green">&lt;xsl:apply-templates</color> select="node()|@*"<color name="green">/&gt;</color>
        <color name="green">&lt;hat-gekuendigt&gt;</color>
            <color name="green">&lt;xsl:sequence</color> select="json-to-xml(
                                  unparsed-text(
                                  concat('https://tekturcms.de/personal.xqy?personal-id=',
                                  personal-id))))/descendant::*[@key='gekuendigt']/text()"<color name="green">/&gt;</color>
        <color name="green">&lt;/hat-gekuendigt&gt;</color>
    <color name="green">&lt;/xsl:copy&gt;</color>
<color name="green">&lt;/xsl:template&gt;</color></verbatim>
                  <p>Während mit <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>doc()</nb>
               </code> oder <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>document()</nb>
               </code> ein zurückgeliefertes XML Fragment 
prozessiert wird, erwartet <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>unparsed-text()</nb>
               </code> z.B. einen JSON-String, der dann mittels
der Funktion <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>json-to-xml()</nb>
               </code> nach XML konvertiert werden kann.</p>
                  <p>Beispielsweise könnte die Gegenseite zum <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>angestellter</nb>
               </code> Template mittels XQuery
folgendermassen realisiert sein:</p>
                  <verbatim>xquery version "1.0-ml";

<color name="brown">declare </color><color name="brown">variable </color><color name="red">$personal-id</color> := <color name="blue">xdmp:get-request-field</color>('personal-id');

<color name="brown">let </color><color name="red">$gekuendigt</color> := <color name="brown">if </color>(collection('/personal')/*[personal-id = <color name="red">$personal-id</color> and 
                                                 <color name="blue">fn:exists</color>(kuendingung)] <color name="brown">then </color>
                                                 'ja' else 'nein'
<color name="brown">return </color>
    <color name="blue">common:render-response</color>(concat('{"gekuendigt":"',<color name="red">$gekuendigt</color>,'",
                                    "personal-id":"',<color name="red">$personal-id</color>,'"}'))</verbatim>
                  <p>(<doclink class="98665bd9-d40d-4fc7-ab7a-e340be6190a6"
                        id="86e61dc1-c690-4420-b3ce-83c39c6bf091"
                        type="none">Mehr zu XQuery und den hier verwendeten Konstrukten</doclink>, wie <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>render-response()</nb>
               </code>))</p>
                  <p>Das zurückgeklieferte JSON Dokument sieht dann so aus:</p>
                  <verbatim>{"gekuendig":"ja","personal-id":"q5687500"}</verbatim>
                  <p>Konvertiert nach XML erhält man eine Map Struktur:</p>
                  <verbatim><color name="green">&lt;map</color> xmlns="http://www.w3.org/2005/xpath-functions"<color name="green">&gt;</color>
    <color name="green">&lt;string</color> key="gekuedigt"<color name="green">&gt;</color>ja<color name="green">&lt;/string&gt;</color>
    <color name="green">&lt;string</color> key="personal-id"<color name="green">&gt;</color>q5687500<color name="green">&lt;/string&gt;</color>
<color name="green">&lt;/map&gt;</color></verbatim>
                  <p>was den Selektorausdruck im obigen XPATH erklärt:</p>
                  <verbatim>json-to-xml(
unparsed-text(
concat('https://tekturcms.de/personal.xqy?personal-id=',
personal-id))))/descendant::*[@key='gekuendigt']/text()</verbatim>
                  <p>Resultat der Konvertierung wäre also dann - wie erwartet - ein um 
das <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>gekuendigt</nb>
               </code> Flag erweitertes <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>&lt;angestellter&gt;</nb>
               </code>
Element:</p>
                  <verbatim><color name="green">&lt;angestellter&gt;</color>
    <color name="green">&lt;perosnal-id&gt;</color>q5687500<color name="green">&lt;/perosnal-id&gt;</color>
    <color name="green">&lt;name&gt;</color>Alex<color name="green">&lt;/name&gt;</color>
    [...]
    <color name="green">&lt;gekuendigt&gt;</color>nein<color name="green">&lt;/gekuendigt&gt;</color>
<color name="green">&lt;/angestellter&gt;</color></verbatim>
                  <p>Sicherlich wird der XML Entwicler eine <doclink class="3337f433-44bf-430d-a809-73fd1de5ba6c"
                        id="997e18de-4390-4b97-9f13-5198617f39e4"
                        type="none">XML Datenbank</doclink>, wie MarkLogic, vorziehen
und sich gleich XML Fragmente ausliefern laasen. <nb xmlns:tektur="http://www.stylesheet-entwicklung.de">Tektur</nb> ist aber bspw. mit
<url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                    address="https://www.mongodb.com/">MongoDB</url>
realisiert, die auf JSON arbeitet... Nicht zuletzt deshalb finde ich JSON Verarbeitung
mit XSLT recht spannend.</p>
               
            
         </chapter>
      </chapter>
      <chapter hyphenation="yes" chapterpage="no" id="0846d6a2-6999-42ab-9e83-55bc197fc11c"
               ismodule="no">
         
            <title>
               <title id="0e661463-0259-4d9f-a784-93f4f169bc52">Abfragen mit XQuery </title>
            </title>
            
               <p>Xquery führt im Publishing-Bereich ein Schattendasein. In meiner Zeit als XSL Programmierer für zwei Publishing  Firmen hatte ich damit nie zu tun. Erst als ich näher an den eigentlichen Daten war und mit XML Datenbanken zu tun hatte, kam ich mit XQuery in Berührung.</p>
               <p>Während relationale Datenbanken mit SQL abgefragt werden, verwendet man bei XML Datenbanken, wie <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                 address="http://exist-db.org/exist/apps/homepage/index.html">eXist</url> oder <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                 address="https://de.marklogic.com/">Marklogic</url>, XQuery als Abfragesprache.</p>
               <p>Aber auch einzelne XML Dokumente können z.B. in Oxygen XML Editor mit dem <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                 address="https://www.oxygenxml.com/xml_editor/xquery_builder.html">XQuery Builder Tool</url> oder auch per Saxon Kommandozeile abgefragt werden:</p>
               <verbatim>java -cp usr/lib/saxon/saxon.jar net.sf.saxon.Query 
     -s:"schulen.xml" 
     -qs:"/schulen/schule[id='6']" 
     -o:"/Users/Alex/Desktop/schule_6.xml"</verbatim>
               <p>Mit der Option <b>-qs </b>kann hier der Querystring angebenen werden. </p>
               <p>Wie man an dem einfachen Beispiel schon sieht, ist XQuery mit XPATH verwandt. XQuery umfasst den Sprachumfang von XPATH bietet aber zusätzlich die FLOWR Syntax um mächtigere Abfragen stellen zu können. Mittels weiterer <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                 address="http://cs.au.dk/~amoeller/XML/querying/flwrexp.html">Extensions</url> können aber auch ganze Programme erstellt werden, die weit über die Funktionalität einer "Abfragesprache" hinausgehen.</p>
               <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                  id="60f1ab16-16a4-4e41-a4c0-0729b99f5850d6e19">
                  
                     <title>
                        <title id="c7e8acb5-6c21-4de1-a88d-8bbd376bbbb4d6e20">XQuery Builder</title>
                     </title>
                     <p>Oxygen XML Editor bietet eine schöne Möglichkeit XQuery-Abfragen 
auf einem geladenen XML Dokument auszuführen. Dazu kann man 
seine Query in das betreffende Eingabefenster schreiben.</p>
                     <figure pdfwidth="page">
                        <subtitle>oXygen XQuery Builder</subtitle>
                        <desc id="ea069e8a-c165-414e-a888-67e68b8876fbd6e27">Mit dem XQuery Builder von oXygen lassen sich unkompliziert Queries testen</desc>
                        <img src="./client/data/0846d6a2-6999-42ab-9e83-55bc197fc11c/xquery-builder.png"/>
                     </figure>
                     <p>Mit folgendem Ergebnis:</p>
                     <verbatim><color name="green">&lt;dates&gt;</color>
  <color name="green">&lt;today&gt;</color>2019-01-16+01:00<color name="green">&lt;/today&gt;</color>
  <color name="green">&lt;formatted&gt;</color>Wednesday, 16th January 2019<color name="green">&lt;/formatted&gt;</color>
<color name="green">&lt;/dates&gt;</color></verbatim>
                  
               </chapter>
               <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                  id="ac0f96f1-87d9-4191-a515-5e04a69a2147d6e34">
                  
                     <title>
                        <title id="59f98501-17c8-47d7-a314-8f89c6b7299ed6e33">FLOWR Expression</title>
                     </title>
                     <p>FLOWR steht für <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>for, let, where, order by, return</nb>
               </code>. Das sind die Query-Anweisungen, die in 
dem Ausdruck erlaubt sind - in genau dieser Reihenfolge.</p>
                     <verbatim><color name="brown">let </color><color name="red">$bibliothek</color> := .
<color name="brown">for </color><color name="red">$x</color><color name="brown"> in </color><color name="red">$bibliothek</color>//buecher,
    <color name="red">$y</color><color name="brown"> in </color><color name="red">$bibliothek</color>//autoren/autor
<color name="brown">where </color>starts-with(<color name="red">$autor</color>, 'Grass')
    and <color name="red">$x</color>/@autorId = <color name="red">$y</color>/@id
<color name="brown">return </color><color name="red">$x</color>/titel</verbatim>
                     <p>In dieser Query werden die Titel aller Bücher von Grass zurückgeliefert.
Bemerkenswert ist hier die Syntax.</p>
                     <note>
                        <consequence>
                           <p>Normalerweise würde man zwischen den
einzelnen Anweisungen einen Blockabschluss, wie ein Semikolon erwarten.
Da wir aber hier funtional prorgammieren, ist die Sache etwas anders...</p>
                        </consequence>
                     </note>
                  
               </chapter>
               <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                  id="6b5b8b5e-b7cf-4b53-8f93-b659fadaea06d6e46">
                  
                     <title>
                        <title id="7dbf0fb3-8421-43c4-b792-0eba61c4bf27d6e44">XML per XQuery</title>
                     </title>
                     <p>Es ist aber auch möglich XML zu erzeugen, wobei natürlich für eine Transformation XSLT 
vorzuziehen ist. Dazu werden Tags direkt in die Expression geschrieben, wie z.B. hier:</p>
                     <verbatim><color name="brown">declare </color><color name="brown">variable </color><color name="red">$nachname</color> as xs:string external;
<color name="green">&lt;buecher</color> autor="{$nachname}"<color name="green">&gt;</color>
{
  <color name="brown">let </color><color name="red">$bibliothek</color> := .
  <color name="brown">for </color><color name="red">$x</color><color name="brown"> in </color><color name="red">$bibliothek</color>/buecher//buch,
      <color name="red">$y</color><color name="brown"> in </color><color name="red">$bibliothek</color>/autoren//autor
  <color name="brown">where </color>starts-with(<color name="red">$y</color>, <color name="red">$nachname</color>)
      and <color name="red">$x</color>/@autorId = <color name="red">$y</color>/@id
  <color name="brown">order </color>by <color name="red">$x</color>/ausgabe
  return
  <color name="green">&lt;buch</color> ausgabe="{$x/ausgabe}"<color name="green">&gt;</color>
    {<color name="red">$x</color>/titel}
  <color name="green">&lt;/buch&gt;</color>
}
<color name="green">&lt;/buecher&gt;</color></verbatim>
                     <p>Speichert man dieses Schnippsel in einer Datei <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>buecher.xquery</nb>
               </code> ab,
so kann man mit der folgenden Kommandozeile auf einer <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>buecher.xml</nb>
               </code> Datei als Eingabe suchen:</p>
                     <verbatim>java -cp usr/lib/saxon/saxon.jar net.sf.saxon.Query -t -s:buecher.xml 
                                                       -q:buecher.xquery 
                                                       -o:ergebnis.xml 
                                                       nachname=grass</verbatim>
                  
               </chapter>
               <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                  id="188bbf60-b618-401b-8e47-be36a013c7b7d6e57">
                  
                     <title>
                        <title id="72199b87-ef45-4bac-93aa-a03892a63e12d6e54">Document Projection</title>
                     </title>
                     <p>
               <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                    address="http://www.saxonica.com/documentation/#!sourcedocs/projection">Document Projection</url>  ist ein verstecktes Saxon XQuery Feature. Es funktioniert nur für eine einzige Abfrage.
Das kann schon recht hilfreich sein, wenn man ein mehrere 100MB großes Dokument durchsuchen
will.</p>
                     <p>Ohne Projection würde das Beispiel von oben so verarbeitet:</p>
                     <verbatim>java -cp usr/lib/saxon/saxon.jar net.sf.saxon.Query -t 
     -s:buecher.xml 
     -q:buecher.xquery 
     -o:ergebnis.xml 
     -projection:off 
     nachname=grass
Saxon-EE 9.7.0.20J from Saxonica
Java version 1.8.0_60
Using license serial number V005095
Analyzing query from Desktop/buecher.xquery
Generating byte code...
Analysis time: 201.10095 milliseconds
Processing file:/Users/Alex/buecher.xml
Using parser com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl<color name="red">$JAXPSAXParser</color>
Building tree <color name="brown">for </color>file:/Users/Alex/buecher.xml 
using class net.sf.saxon.tree.tiny.TinyBuilder
Tree built<color name="brown"> in </color>3.482278ms
Tree size: 46 nodes, 58 characters, 6 attributes
Execution time: 27.137589ms
Memory used: 67031664</verbatim>
                     <p>Mit der Option <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>-projection:on</nb>
               </code> verändert sich die Ausführungszeit signifikant:</p>
                     <verbatim>[...]

Document projection <color name="brown">for </color>file:/Users/Alex/buecher.xml
-- Input nodes 50; output nodes 27; reduction = 46%
Tree built<color name="brown"> in </color>3.80615ms
Tree size: 26 nodes, 58 characters, 3 attributes
Execution time: 15.83463ms
Memory used: 64339064</verbatim>
                  
               </chapter>
            
         
         <chapter hyphenation="yes" chapterpage="no" id="98665bd9-d40d-4fc7-ab7a-e340be6190a6"
                  ismodule="no">
            
               <title>
                  <title id="8c5a4500-d080-4910-b4cd-529caeb12ae3">XQuery als Programmiersprache</title>
               </title>
               
                  <p>Erste Schritte in XQuery gehen sehr schön  
mit der Query Konsole auf dem Marklogic Server (Port 8000).
Hat man parallel auch noch oXygen offen, kann man die Testergbnisse aus der Konsole direkt in ein XQuery Server Skript packen.</p>
                  <p>wqdqwd</p>
                  <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                     id="1cba86ea-2760-4a82-b5d7-349bfa73e49fd6e8">
                     
                        <title>
                           <title id="fa1956ff-e468-4fb8-99dc-1a7a8f773707d6e7">Schleifen</title>
                        </title>
                        <p>Die ersten 10 Dokumente auf dem Server bekommt man z.B. mit:</p>
                        <verbatim>(doc())[position() lt 11]</verbatim>
                        <p>Die Zahlen von 1 bis 100 mit:</p>
                        <verbatim>(<color name="brown">for </color><color name="red">$i</color><color name="brown"> in </color>(1 to 100) <color name="brown">return </color><color name="red">$i</color>)</verbatim>
                        <p>Wenn man diese beide Anweisungen untereinander in die Konsole
schreibt bekommt man einen Fehler. Trennt man sie mit einem 
Komma - ein Tupel wird erzeugt - dann klappt es.</p>
                     
                  </chapter>
                  <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                     id="19cc7202-f7bb-4cb1-ad46-9c7465c3d3b3d6e21">
                     
                        <title>
                           <title id="0bbb962d-b38e-431a-855a-294425a5a016d6e20">Dokumente in der DB anlegen</title>
                        </title>
                        <p>Der Befehl zum Anlegen eines Dokuments in der Marklogic DB sieht
folgendermassen aus <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                       address="https://docs.marklogic.com/xdmp:document-insert">(Doku)</url>:</p>
                        <verbatim><color name="blue">xdmp:document-insert</color>(
  "/alex-test/example-alex.xml",
  <color name="green">&lt;root&gt;</color>Hier steht der Content<color name="green">&lt;/root&gt;</color>, 
  <color name="green">&lt;options</color> xmlns="xdmp:document-insert"<color name="green">&gt;</color>  
    <color name="green">&lt;metadata&gt;</color>{
      <color name="blue">map:map</color>() =&gt; <color name="blue">map:with</color>("valid-start", "2014-06-03T14:13:05.472585-07:00")
      =&gt; <color name="blue">map:with</color>("valid-end", "9999-12-31T11:59:59Z")
      }<color name="green">&lt;/metadata&gt;</color>
  <color name="green">&lt;/options&gt;</color>)</verbatim>
                        <p>Packt man diese Instruktion in die for-Schleife oben, dann sieht das Konstrukt so aus:</p>
                        <verbatim>(<color name="brown">for </color><color name="red">$i</color><color name="brown"> in </color>(1 to 10) <color name="brown">return </color>
  <color name="blue">xdmp:document-insert</color>(
  concat("/alex-test/example-alex-",<color name="red">$i</color>,".xml"),
  <color name="green">&lt;root&gt;</color>Hier steht der Content {<color name="red">$i</color>}<color name="green">&lt;/root&gt;</color>, 
  <color name="green">&lt;options</color> xmlns="xdmp:document-insert"<color name="green">&gt;</color>  
    <color name="green">&lt;metadata&gt;</color>{
      <color name="blue">map:map</color>() =&gt; <color name="blue">map:with</color>("valid-start", "2014-06-03T14:13:05.472585-07:00")
      =&gt; <color name="blue">map:with</color>("valid-end", "9999-12-31T11:59:59Z")
      }<color name="green">&lt;/metadata&gt;</color>
  <color name="green">&lt;/options&gt;</color>)
)</verbatim>
                        <p>Dokumente kann man einer Collection zuweisen, um sie leichter finden und auswerten
zu können. Das geht mit dem folgenden Befehl <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                       address="https://docs.marklogic.com/xdmp:document-add-collections">(Doku)</url> und diesem Schnippsel:</p>
                        <verbatim><color name="brown">let </color><color name="red">$root</color> :=
<color name="green">&lt;mein-test&gt;</color>
   <color name="green">&lt;id&gt;</color>{<color name="red">$id</color>}<color name="green">&lt;/id&gt;</color>
   <color name="green">&lt;content&gt;</color>Hallo Welt!<color name="green">&lt;/content&gt;</color>
<color name="green">&lt;/mein-test&gt;</color>,
<color name="red">$options</color> :=
<color name="green">&lt;options</color> xmlns="xdmp:document-insert"<color name="green">&gt;</color>  
  <color name="green">&lt;permissions&gt;</color><color name="blue">{xdmp:default-permissions</color>()}<color name="green">&lt;/permissions&gt;</color>
  <color name="green">&lt;collections&gt;</color>
    <color name="green">&lt;collection&gt;</color>/alex-test<color name="green">&lt;/collection&gt;</color>
  <color name="green">&lt;/collections&gt;</color>
<color name="green">&lt;/options&gt;</color>,
<color name="red">$fname</color> := concat('/',<color name="red">$id</color>,'_','.xml'),
<color name="red">$td</color> := <color name="blue">xdmp:document-insert</color>(<color name="red">$fname</color>,<color name="red">$root</color>,<color name="red">$options</color>)
<color name="brown">return </color>
  [...]</verbatim>
                        <p>Die Dokumente, die mit der Collection alex-test getaggt wurden, kann man sich mit der folgenden Schleife ausgeben lassen:</p>
                        <verbatim><color name="brown">for </color><color name="red">$x</color><color name="brown"> in </color>collection("/alex-test")
  return
    <color name="blue">fn:document-uri</color>(<color name="red">$x</color>)</verbatim>
                     
                  </chapter>
               
            
            <chapter hyphenation="yes" chapterpage="no" id="3630ee02-616b-4bbc-8655-9064d57bf945"
                     ismodule="no">
               
                  <title>
                     <title id="9c13d213-40d3-4e74-b343-23cc42779c6d">Funktionen und Module</title>
                  </title>
                  
                     <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                        id="6388d720-5add-45c0-aea2-4fd40ba5b64fd6e4">
                        
                           <title>
                              <title id="2b09a4f1-af09-482e-b220-bbaa5e4f0897d6e5">Funktionen</title>
                           </title>
                           <p>Um bestimmte Abschnitte des XQuery Programm wiederverwendbar zu machen, stehen Funktionsdeklarationen zur verfügung. Eine einfache Funktion wäre z.B. diese hier:</p>
                           <verbatim><color name="brown">declare </color><color name="brown">function </color><color name="blue">local:wrap-header</color>(<color name="red">$json</color>) {
  <color name="blue">xdmp:add-response-header</color>("Pragma", "no-cache"),
  <color name="blue">xdmp:add-response-header</color>("Cache-Control", "no-cache"),
  <color name="blue">xdmp:add-response-header</color>("Expires", "0"),
  <color name="blue">xdmp:set-response-content-type</color>('text/json; charset=utf-8'),
  <color name="red">$json</color>
};</verbatim>
                           <p>Sie wickelt um einen JSON String eine passende Header Information.</p>
                           <p>Damit die Funktion eingebunden werden kann, muss ein passender Namespace deklariert werden:</p>
                           <verbatim><color name="brown">declare </color><color name="brown">namespace </color>local = 'local:';</verbatim>
                           <p>Nicht nur bzgl. Wiederverwendbarkeit sind Funktionen praktisch, sondern auch
um ganz elementare Konstrukte, wie <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                        <nb>while...do</nb>
                     </code> Schleifen, zu realisieren.</p>
                           <p>Dazu nutzt man, wie in der funktionalen Programmierung üblich, die Rekursion:</p>
                           <verbatim><color name="brown">declare </color><color name="brown">function </color><color name="blue">local:ist-letzter-wert-in-kette</color>(<color name="red">$glied</color>) {
  <color name="brown">let </color><color name="red">$wert</color> := <color name="blue">local:komplizierte-berechnung</color>(<color name="red">$glied</color>),
    <color name="red">$naechstes-glied</color> := <color name="blue">local:komplizierte-berechnung-der-position</color>(<color name="red">$glied</color>),
  return
    <color name="brown">if </color>(<color name="red">$naechstes-glied</color> and not(<color name="red">$wert</color> = 'foobar')) then
      <color name="blue">local:durchlaufe-kette</color>(<color name="red">$naechstes-glied</color>)
    else
      <color name="red">$wert</color> = 'foobar'
};</verbatim>
                           <p>In diesem kleinen Schnippsel sind schon einige Besonderheiten von 
XQuery zu sehen. Variablenzuweisungen geschehen mit einem Doppelpunkt,
Vergleiche dagegen nur mit einem einfachen "=". Statements werden mit einem
Komma getrennt.</p>
                        
                     </chapter>
                     <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                        id="9924b5ed-d340-4e18-8580-c728182f2babd6e25">
                        
                           <title>
                              <title id="dab65cd2-0eb9-4487-99e0-07422d3c3759d6e26">Module</title>
                           </title>
                           <p>Um eine XQuery Anwendung zu modularisieren, können einzelne Skripte in
Module ausgelagert werden. Ein Modul, z.B. common.xqy, wird dabei über einen eigenen
Namespace deklariert:</p>
                           <verbatim><color name="brown">module </color><color name="brown">namespace </color>common = "https://www.tekturcms.de/common";</verbatim>
                           <p>Dieses Modul kann dann in anderen Skripten eingebunden werden:</p>
                           <verbatim>import <color name="brown">module </color><color name="brown">namespace </color>common = "https://www.tekturcms.de/common" at "common.xqy";</verbatim>
                           <p>Funktionen und Variablen werden dann mir dem Namespace geprefixt aufgerufen:</p>
                           <verbatim>Funktionsaufruf: <color name="blue">common:wrap-response-header</color>(...)
Variablenauswertung: <color name="red">$common</color>:collection-books</verbatim>
                        
                     </chapter>
                  
               
            </chapter>
            <chapter hyphenation="yes" chapterpage="no" id="d9cd641f-29f4-485d-8e67-32519d422b08"
                     ismodule="no">
               
                  <title>
                     <title id="86a66f53-eb4a-4cc0-b14c-12d5c2bb84bd">If..then..else Ausdrücke</title>
                  </title>
                  
                     <p>In nicht-funktionalen Programmiersprachen sind die Schlüsselwörter <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>if</nb>
                  </code> und <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>then</nb>
                  </code> dazu da, um dem Compiler oder Interpreter mitzuteilen, dass eine bedingte Anweisung ausgewertet werden soll.</p>
                     <p>Was für den Nicht-funktionalen Programmierer etwas befremdlich erscheint, ist der Umstand, dass in XQuery <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>if..then</nb>
                  </code> als Ausdrücke ausgewertet werden.</p>
                     <p>Das ist einerseits sehr praktisch, weil es richtig angewandt den Code verkürzt und damit das Wesentliche herausstellt, kann aber auch weiter zur allg. Verwirrung bzgl. des kryptischen XQuery Codes beitragen.</p>
                     <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                        id="9c590583-7d07-494e-b104-e28426ceaf65d6e10">
                        
                           <title>
                              <title id="b0df228c-1f72-4a12-9302-805fa0022b03d6e11">XQuery Server Application</title>
                           </title>
                           <p>Betrachten wir ein einfaches Beispiel: Wir generieren auf einer Marklogic-Webapp eine JSON Response. Da wir diesen Mechanismus an mehreren Stellen im Code einsetzen, empfiehlt es sich das Rendern des Headers in eine Funktion auszulagern.</p>
                           <verbatim><color name="brown">declare </color><color name="brown">function </color><color name="blue">common:wrap-response</color>(<color name="red">$json</color>)
{
  <color name="blue">xdmp:add-response-header</color>("Pragma", "no-cache"),
  <color name="blue">xdmp:add-response-header</color>("Cache-Control", "no-cache"),
  <color name="blue">xdmp:add-response-header</color>("Expires", "0"),
  <color name="blue">xdmp:set-response-content-type</color>('text/json; charset=utf-8'),
  <color name="red">$json</color>
};</verbatim>
                           <p>In unserem Request-Handler wird je nach Auswertung einer Variablen eine 
bedingte Anweisung ausgeführt, diese sieht bspw. so aus:</p>
                           <verbatim><color name="brown">let </color><color name="red">$name</color> := <color name="blue">xdmp:get-request-field</color>('name'),
    <color name="red">$is-afternoon</color> := <color name="blue">xs:time</color>(current-dateTime()) gt <color name="blue">xs:time</color>('12:00:00')
<color name="brown">return </color>
  <color name="brown">if </color>(<color name="red">$is-afternoon</color>) <color name="brown">then </color>
   <color name="blue">common:wrap-response</color>(<color name="blue">xdmp:unquote</color>(concat('{"greeting":"Good Afternoon! ',<color name="red">$name</color>,'!"}')))
  else
   <color name="blue">common:wrap-response</color>(<color name="blue">xdmp:unquote</color>(concat('{"greeting":"Good Morning! ',<color name="red">$name</color>,'!"}')))</verbatim>
                           <p>Als prozeduraler Programmierer wäre ich mit diesem Switch voll und ganz zufrieden, 
der funktionale Programmier erkennt abaer sofort einen Optimierungsbedarf.</p>
                           <p>Da es sich bei der bedingten Anweisung auch um einen Ausdruck handelt, der [[code:true}} oder [[code:false}} zurückgibt, können wir die gleichen Funktionsaufrufe herausziehen:</p>
                           <verbatim><color name="blue">ommon:wrap-response</color>(<color name="blue">xdmp:unquote</color>(
    <color name="brown">let </color><color name="red">$is-afternoon</color> := <color name="blue">xs:time</color>(current-dateTime()) gt <color name="blue">xs:time</color>('12:00:00')
        <color name="brown">return </color>
            <color name="brown">if </color>(<color name="red">$is-afternoon</color>) <color name="brown">then </color>concat('{"greeting":"Good Afternoon! ',<color name="red">$name</color>,'!"}') 
            else concat('{"greeting":"Good Morning! ',<color name="red">$name</color>,'!"}')
)</verbatim>
                           <p>Hier wird der abstrakt denkende Programmierer aber einwenden, dass eine abstrakte
Logik nicht in eine Low-Level Funktion, wie [code:xsdmp:unquote] gewrapped werden sollte.</p>
                           <p>Das stimmt - und mehr noch, die Maskierung mit <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                        <nb>xsdmp:unquote</nb>
                     </code> sollte auch noch in unsere 
Funktion gepackt werden. So dass der Code schliesslich so aussehen würde:</p>
                           <verbatim><color name="brown">declare </color><color name="brown">function </color><color name="blue">common:render-response</color>(<color name="red">$json</color>)
{
  <color name="blue">xdmp:add-response-header</color>("Pragma", "no-cache"),
  <color name="blue">xdmp:add-response-header</color>("Cache-Control", "no-cache"),
  <color name="blue">xdmp:add-response-header</color>("Expires", "0"),
  <color name="blue">xdmp:set-response-content-type</color>('text/json; charset=utf-8'),
  <color name="blue">xdmp:unquote</color>(<color name="red">$json</color>)
};
<color name="blue">
common:render-response</color>(
    <color name="brown">let </color><color name="red">$is-afternoon</color> := <color name="blue">xs:time</color>(current-dateTime()) gt <color name="blue">xs:time</color>('12:00:00')
        <color name="brown">return </color>
            <color name="brown">if </color>(<color name="red">$is-afternoon</color>) <color name="brown">then </color>concat('{"greeting":"Good Afternoon! ',<color name="red">$name</color>,'!"}') 
            else concat('{"greeting":"Good Morning! ',<color name="red">$name</color>,'!"}')
)</verbatim>
                           <p>Sicherlich lässt sich darüber streiten, ob nun der funktionale Ansatz besser lesbar ist als
der prozedurale ganz oben.</p>
                           <p>Ich denke jeder Programmierer hat hier seinen eigenen, individuellen
und bewährten Programmierstil entwickelt, den er auch beibehalten sollte.</p>
                        
                     </chapter>
                  
               
            </chapter>
         </chapter>
      </chapter>
      <chapter hyphenation="yes" chapterpage="no" id="3337f433-44bf-430d-a809-73fd1de5ba6c"
               ismodule="no">
         
            <title>
               <title id="b49f74f7-6d65-4672-beef-5fd92c877526">XML Datenbanken</title>
            </title>
            
               <p>XML Datenbanken konzentrieren sich im Gegensatz zu den verbreiteten relationalen 
Datenbanken auf die Struktur eines Dokuments, die abstrakt gesehen einen Baum darstellt, und weniger auf die Beziehungen zwischen Objekten, die eher einen Graphen aufspannen.</p>
               <p>Natürlich ist auch jeder Baum ein Graph ohne Kreise, und sicherlich kann man auch Bäume
in einer relationalen Datenbank abspeichern. Eine XML Datenbank ist aber für diese Struktur optimiert. </p>
               <p>Es gibt gegenwärtig vier reine XML Datenbanken und einige Erweiterungen für konventionelle SQL Datenbanken:</p>
               <table type="dl">
                  <tgroup>
                     <colspec colwidth="0.25*"/>
                     <colspec colwidth="0.75*"/>
                     <tbody>
                        <row>
                           <entry>
                              <b>Datenbank</b>
                           </entry>
                           <entry>
                              <b>Besonderheiten</b>
                           </entry>
                        </row>
                        <row>
                           <entry>
                        <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                             address="http://exist-db.org/exist/apps/homepage/index.html">eXist DB</url>
                     </entry>
                           <entry>
                              <p>eXist DB ist ein Open Source Projekt. Neben der Datenbank umfasst diese Software eine komplette Entwicklungsumgebung für Webapplikationen. Für diese DB xistiert ein 1-Klick Installer in Form eines Java Jars. eXist ist im Bereich Digital Humanities (ein Fachbereich der Geschichts- und Kulturwissenschaften) sehr verbreitet.</p>
                           </entry>
                        </row>
                        <row>
                           <entry>
                        <url xmlns:tektur="http://www.stylesheet-entwicklung.de" address="http://basex.org/">BaseX</url>
                     </entry>
                           <entry>
                              <p>BaseX ist ebenfalls OpenSource und die Homepage macht einen ordentlichen Eindruck. Bisher bin ich noch nicht dazugekommen, BaseX zu evaluieren. Unter meiner Java 10 Installation lief erst einmal nichts - weshalb die erste Kontaktaufnahme scheiterte. </p>
                           </entry>
                        </row>
                        <row>
                           <entry>
                        <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                             address="https://www.marklogic.com/">MarkLogic</url>
                     </entry>
                           <entry>
                              <p>MarkLogic ist der Platzhirsch unter den kommerziellen Anbietern. Hier ist alles "Enterprise"... die Funktionalität, der Support und auch der Preis. Obwohl ML viele Erweiterungen für XQuery bietet, ist der XQuery 3.0 Standard noch nicht umgesetzt.</p>
                           </entry>
                        </row>
                        <row>
                           <entry>
                        <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                             address="https://www.oracle.com/database/berkeley-db/xml.html">Berkely DB XML Datenbank</url>
                     </entry>
                           <entry>
                              <p>Die gute alte Berkely DB war der Key-Value Unterbau für viele andere Datenbanken, wie auch MySQL. Sicherlich hat auch die XML Variante einiges in Petto.</p>
                           </entry>
                        </row>
                     </tbody>
                  </tgroup>
               </table>
               <p>Da ich zur Zeit beruflich mit MarkLogic zu tun habe, lasse ich mir die Gelegenheit nicht nehmen, meine Erfahrungen und Erkenntnisse dazu in diesem Kapitel zu beschreiben. Es gibt auch eine <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                 address="https://developer.marklogic.com/free-developer">Developer License</url> mit der man die Software ausprobieren kann. Für alle langfristigen XQuery Spielereien ist die eXist DB wohl die erste Wahl, da hier auch der aktuelle XQuery 3.0 Standard umgesetzt ist.</p>
            
         
         <chapter hyphenation="yes" chapterpage="no" id="38f7a676-cbef-4a69-9ae9-d89bddde2719"
                  ismodule="no">
            
               <title>
                  <title id="d9ecd69d-0fbd-4931-8d5b-fe5bee02f362">Connector zu Marklogic in Oxygen Test</title>
               </title>
               
                  <p>Marklogic bietet zwar auf Port 8000 per Default ein Query Console im Browser, mit der man bestimmte Sachen ausprobieren kann. Komfortabler arbeitet man aber mit einem Oxygen-Connector. Dazu öffnet man den <i id="69aba0a2-ccaa-4d60-bbf7-1fd62f608ca5d6e6">Data Source Explorer</i>: </p>
                  <p>und konfiguriert eine neue Datenquelle:</p>
                  <figure pdfwidth="page">
                     <desc id="b41efc60-b68d-4e9a-b659-363ecbea1d66d6e12">oXygen Data Source Explorer View öffnen</desc>
                     <img src="./client/data/38f7a676-cbef-4a69-9ae9-d89bddde2719/d-source-explorer-1.png"/>
                  </figure>
                  <p>Dazu muss man den <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                    address="https://www.oxygenxml.com/doc/versions/20.1/ug-editor/topics/configure-marklogic-datasource.html">Marklogic Treiber installieren</url> und diesen im folgenden Screen verfügbar machen.</p>
                  <figure pdfwidth="page">
                     <desc id="4ac1ff51-23a5-45c8-9044-89ffb6f8816cd6e18">Neue Datenquelle in oXygen konfigurieren</desc>
                     <img src="./client/data/38f7a676-cbef-4a69-9ae9-d89bddde2719/d-source-explorer-2.png"/>
                  </figure>
                  <caution>
                     <cause>Das Jar sollte an einem soliden Ort abgespeichert werden, da hier nur ein Verweis auf diesen Ort gesetzt wird.</cause>
                     <consequence/>
                  </caution>
                  <figure pdfwidth="page">
                     <desc id="9cb017ac-29d4-4449-a705-a48768bcca40d6e27">Marklogic Treiber auswählen</desc>
                     <img src="./client/data/38f7a676-cbef-4a69-9ae9-d89bddde2719/add-marklogic-jar.png"/>
                  </figure>
                  <p>Natürlich ist auf der Serverseite auch eine Einstellung notwendig. Man wechselt als Admin in den Bereich <b>App Servers</b> und fügt einen neuen <b>WebDAV Server</b>  hinzu. Ggf. muss man bei der Auswahl der Datenbank diese noch auf "automatische Directory Erzeugung" umstellen.</p>
                  <figure pdfwidth="page">
                     <desc id="3d85ad8f-310f-41a3-a5b0-c8758ffad484d6e39">Wechseln in die Marklogic App Server Verwaltung</desc>
                     <img src="./client/data/38f7a676-cbef-4a69-9ae9-d89bddde2719/appserver.png"/>
                  </figure>
                  <figure pdfwidth="page">
                     <desc id="a718f7dc-2ba9-4243-b9e3-afa1a7541143d6e43">WebDAV in Marklogic konfigurieren</desc>
                     <img src="./client/data/38f7a676-cbef-4a69-9ae9-d89bddde2719/marklogic-create-webdav.png"/>
                  </figure>
                  <p>Hat man den WebDAV Server erzeugt und diesem eine bestehende oder neu angelegte Datenbank zugewiesen, dann kann man diese DB im Konfigurationsdialog der neuen WebDav Connection auswählen.</p>
                  <figure pdfwidth="page">
                     <desc id="6597d0b8-1ff1-4dd4-8c14-d99b5011aca5d6e50">Konfigurieren der WebDAV Connection Einstellungen in oXygen</desc>
                     <img src="./client/data/38f7a676-cbef-4a69-9ae9-d89bddde2719/cnfigure-database-connection.png"/>
                  </figure>
                  <p>Schliesslich hat man im Data Source Explorer in oXygen die neue Verbindung verfügbar und kann gefühlt wie im Dateisystem mit den Files auf dem Server arbeiten.</p>
                  <figure pdfwidth="page">
                     <desc id="902cb29c-0bfb-4708-aa7d-c3fbffb4c6d0d6e56">oXagen Data Source Explorer zeigt die WebDAV Verzeichnisse auf dem Marklogic Server</desc>
                     <img src="./client/data/38f7a676-cbef-4a69-9ae9-d89bddde2719/Data-Source_explorer.png"/>
                  </figure>
               
            
         </chapter>
         <chapter hyphenation="yes" chapterpage="no" id="382bb96a-5a06-460c-8d69-4c4cd613297c"
                  ismodule="no">
            
               <title>
                  <title id="6dc3be8f-5b8c-407c-9853-0533fdbf8267">SQL Views in MarkLogic</title>
               </title>
               
                  <p>Es macht nicht immer Sinn über eine Baumstruktur zu suchen. Obwohl das in einer 
XML Datenbank rasend schnell geht, weil jeder Knoten des Baums initial in einen Index
aufgenommen wird. So gibt es doch Anwendungsfälle bei denen man lieber eine relationale
Sicht auf die Daten hätte.</p>
                  <p>In MarkLogic heisst die Lösung dazu SQL Views.</p>
                  <p>Bspw. benötigt man eine relationale Sicht auf die Daten,
wenn über verschiedene Datensätze ein Report generiert werden soll.</p>
                  <p>Nehmen wir an es gibt im Datenbestand die folgenden Dokumente:</p>
                  <verbatim><color name="green">&lt;k:kunde&gt;</color>
  <color name="green">&lt;k:id&gt;</color>1<color name="green">&lt;/k:id&gt;</color>
  <color name="green">&lt;k:name&gt;</color>Alex<color name="green">&lt;/k:name&gt;</color>
  <color name="green">&lt;k:eMail&gt;</color>tekturcms@gmail.com<color name="green">&lt;/k:eMail&gt;</color>
<color name="green">&lt;/k:kunde&gt;</color>

<color name="green">&lt;k:kunde&gt;</color>
  <color name="green">&lt;k:id&gt;</color>2<color name="green">&lt;/k:id&gt;</color>
  <color name="green">&lt;k:name&gt;</color>Horst<color name="green">&lt;/k:name&gt;</color>
  <color name="green">&lt;k:eMail&gt;</color>horst@horst.de<color name="green">&lt;/k:eMail&gt;</color>
<color name="green">&lt;/k:kunde&gt;</color>

<color name="green">&lt;k:kunde&gt;</color>
  <color name="green">&lt;k:id&gt;</color>3<color name="green">&lt;/k:id&gt;</color>
  <color name="green">&lt;k:name&gt;</color>Gundula<color name="green">&lt;/k:name&gt;</color>
  <color name="green">&lt;k:eMail&gt;</color>gundl@gundula.de<color name="green">&lt;/k:eMail&gt;</color>
<color name="green">&lt;/k:kunde&gt;</color>

<color name="green">&lt;b:bestellung&gt;</color>
  <color name="green">&lt;b:id&gt;</color>1<color name="green">&lt;/b:id&gt;</color>
  <color name="green">&lt;b:datum&gt;</color>02.01.2019<color name="green">&lt;/b:datum&gt;</color>
  <color name="green">&lt;b:preis&gt;</color>99.90<color name="green">&lt;/b:preis&gt;</color>
  <color name="green">&lt;kunde-id&gt;</color>2<color name="green">&lt;/kunde-id&gt;</color>
<color name="green">&lt;/b:bestellung&gt;</color>

<color name="green">&lt;b:bestellung&gt;</color>
  <color name="green">&lt;b:id&gt;</color>2<color name="green">&lt;/b:id&gt;</color>
  <color name="green">&lt;b:datum&gt;</color>03.01.2019<color name="green">&lt;/b:datum&gt;</color>
  <color name="green">&lt;b:preis&gt;</color>68.90<color name="green">&lt;/b:preis&gt;</color>
  <color name="green">&lt;b:kunde-id&gt;</color>1<color name="green">&lt;/b:kunde-id&gt;</color>
<color name="green">&lt;/b:bestellung&gt;</color></verbatim>
                  <p>Will man sich alle Kunden anzeigen lassen, die eine Bestellung 
abgegeben haben - das sind Alex und Horst - so würde man bei
einem relationalen Ansatz einen JOIN verwenden, so wie:</p>
                  <verbatim>SELECT name, datum, preis
FROM kunden k
INNER JOIN bestellungen b
ON k.id = b.kunde_id</verbatim>
                  <p>In einer relationalen Sicht würde uns das dann die folgende Tabelle liefern:</p>
                  <verbatim>name, datum, preis
Alex, 03.01.2019, 68.90
Horst, 02.01.2019, 99.90</verbatim>
                  <p>Um für MarkLogic eine SQL View zu definieren verwendet man einen Mechanismus,
der da heisst: <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                    address="https://docs.marklogic.com/guide/app-dev/TDE">Template Driven Extraction</url>
            </p>
                  <p>Dazu werden Templates in XML deklariert und in die Template Collection eingefügt. Für unser obiges Beispiel
würden wir zwei Templates brauchen, die so aussehen:</p>
                  <verbatim>xquery version "1.0-ml";

import <color name="brown">module </color><color name="brown">namespace </color>tde = "http://marklogic.com/xdmp/tde" 
                            at "/MarkLogic/tde.xqy";

<color name="brown">let </color><color name="red">$sql-view-name</color> := 'kunden-view.xml'
<color name="brown">let </color><color name="red">$sql-view</color> := <color name="green">&lt;template</color> xmlns="http://marklogic.com/xdmp/tde"<color name="green">&gt;</color>
   <color name="green">&lt;path-namespaces&gt;</color>
      <color name="green">&lt;path-namespace&gt;</color>
         <color name="green">&lt;prefix&gt;</color>k<color name="green">&lt;/prefix&gt;</color>
         <color name="green">&lt;namespace-uri&gt;</color>https://tekturcms.de/schema/kunde/1.0<color name="green">&lt;/namespace-uri&gt;</color>
      <color name="green">&lt;/path-namespace&gt;</color>
   <color name="green">&lt;/path-namespaces&gt;</color>
   <color name="green">&lt;context&gt;</color>/k:kunde<color name="green">&lt;/context&gt;</color>
   <color name="green">&lt;collections&gt;</color>
      <color name="green">&lt;collections-and&gt;</color>
         <color name="green">&lt;collection&gt;</color>/kunden<color name="green">&lt;/collection&gt;</color>
      <color name="green">&lt;/collections-and&gt;</color>
   <color name="green">&lt;/collections&gt;</color>
   <color name="green">&lt;rows&gt;</color>
      <color name="green">&lt;row&gt;</color>
         <color name="green">&lt;schema-name&gt;</color>kunden_schema<color name="green">&lt;/schema-name&gt;</color>
         <color name="green">&lt;view-name&gt;</color>kunden_view<color name="green">&lt;/view-name&gt;</color>
         <color name="green">&lt;columns&gt;</color>
            <color name="green">&lt;column&gt;</color>
               <color name="green">&lt;name&gt;</color>id<color name="green">&lt;/name&gt;</color>
               <color name="green">&lt;scalar-type&gt;</color>string<color name="green">&lt;/scalar-type&gt;</color>
               <color name="green">&lt;val&gt;</color>k:id<color name="green">&lt;/val&gt;</color>
               <color name="green">&lt;nullable&gt;</color>true<color name="green">&lt;/nullable&gt;</color>
            <color name="green">&lt;/column&gt;</color>
            <color name="green">&lt;column&gt;</color>
               <color name="green">&lt;name&gt;</color>datum<color name="green">&lt;/name&gt;</color>
               <color name="green">&lt;scalar-type&gt;</color>string<color name="green">&lt;/scalar-type&gt;</color>
               <color name="green">&lt;val&gt;</color>k:datum<color name="green">&lt;/val&gt;</color>
               <color name="green">&lt;nullable&gt;</color>true<color name="green">&lt;/nullable&gt;</color>
            <color name="green">&lt;/column&gt;</color>
            <color name="green">&lt;column&gt;</color>
               <color name="green">&lt;name&gt;</color>eMail<color name="green">&lt;/name&gt;</color>
               <color name="green">&lt;scalar-type&gt;</color>string<color name="green">&lt;/scalar-type&gt;</color>
               <color name="green">&lt;val&gt;</color>k:eMail<color name="green">&lt;/val&gt;</color>
               <color name="green">&lt;nullable&gt;</color>true<color name="green">&lt;/nullable&gt;</color>
            <color name="green">&lt;/column&gt;</color>
         <color name="green">&lt;/columns&gt;</color>
      <color name="green">&lt;/row&gt;</color>
   <color name="green">&lt;/rows&gt;</color>
<color name="green">&lt;/template&gt;</color>
return(
  <color name="blue">tde:template-insert</color>(concat('/templates/', <color name="red">$sql-view-name</color>), 
                      <color name="red">$sql-view</color>, <color name="blue">xdmp:default-permissions</color>())
)</verbatim>
                  <p>und analog für die Bestellungen:</p>
                  <verbatim>[...]
   <color name="green">&lt;rows&gt;</color>
      <color name="green">&lt;row&gt;</color>
         <color name="green">&lt;schema-name&gt;</color>bestellungen_schema<color name="green">&lt;/schema-name&gt;</color>
         <color name="green">&lt;view-name&gt;</color>bestellungen_view<color name="green">&lt;/view-name&gt;</color>
         <color name="green">&lt;columns&gt;</color>
            <color name="green">&lt;column&gt;</color>
               <color name="green">&lt;name&gt;</color>id<color name="green">&lt;/name&gt;</color>
               <color name="green">&lt;scalar-type&gt;</color>string<color name="green">&lt;/scalar-type&gt;</color>
               <color name="green">&lt;val&gt;</color>b:id<color name="green">&lt;/val&gt;</color>
            <color name="green">&lt;/column&gt;</color>
            <color name="green">&lt;column&gt;</color>
               <color name="green">&lt;name&gt;</color>datum<color name="green">&lt;/name&gt;</color>
               <color name="green">&lt;scalar-type&gt;</color>string<color name="green">&lt;/scalar-type&gt;</color>
               <color name="green">&lt;val&gt;</color>b:datum<color name="green">&lt;/val&gt;</color>
            <color name="green">&lt;/column&gt;</color>
            <color name="green">&lt;column&gt;</color>
               <color name="green">&lt;name&gt;</color>preis<color name="green">&lt;/name&gt;</color>
               <color name="green">&lt;scalar-type&gt;</color>string<color name="green">&lt;/scalar-type&gt;</color>
               <color name="green">&lt;val&gt;</color>b:preis<color name="green">&lt;/val&gt;</color>
            <color name="green">&lt;/column&gt;</color>
            <color name="green">&lt;column&gt;</color>
               <color name="green">&lt;name&gt;</color>kunde_id<color name="green">&lt;/name&gt;</color>
               <color name="green">&lt;scalar-type&gt;</color>string<color name="green">&lt;/scalar-type&gt;</color>
               <color name="green">&lt;val&gt;</color>b:kunde-id<color name="green">&lt;/val&gt;</color>
            <color name="green">&lt;/column&gt;</color>
         <color name="green">&lt;/columns&gt;</color>
      <color name="green">&lt;/row&gt;</color>
[...]</verbatim>
                  <p>In XQuery eingebunden könnte man dann die definierten SQL Views mit dem folgenden Befehl abfragen:</p>
                  <verbatim><color name="blue">xdmp:sql</color>("SELECT name, datum, preis FROM kunden_view k 
          INNER JOIN bestellungen_view b ON k.id = b.kunde_id")</verbatim>
                  <p>Folgende ist das komplette Beispiel für eine MarkLogic XQuery Konsolensitzung abgebildet ...</p>
                  <verbatim>xquery version "1.0-ml";

<color name="brown">declare </color><color name="brown">namespace </color>k = 'http://www.tekturcms.de/kunden';
<color name="brown">declare </color><color name="brown">namespace </color>b = 'http://www.tekturcms.de/bestellungen';

import <color name="brown">module </color><color name="brown">namespace </color>tde = "http://marklogic.com/xdmp/tde" at "/MarkLogic/tde.xqy";

<color name="brown">declare </color><color name="brown">function </color><color name="blue">local:loadKunde</color>(<color name="red">$id</color>, <color name="red">$name</color>, <color name="red">$eMail</color>)
{
  <color name="brown">let </color><color name="red">$root</color> :=
  <color name="green">&lt;k:kunde&gt;</color>
    <color name="green">&lt;k:id&gt;</color>{ <color name="red">$id</color> }<color name="green">&lt;/k:id&gt;</color>
    <color name="green">&lt;k:name&gt;</color>{ <color name="red">$name</color> }<color name="green">&lt;/k:name&gt;</color>
    <color name="green">&lt;k:eMail&gt;</color>{ <color name="red">$eMail</color> }<color name="green">&lt;/k:eMail&gt;</color>
  <color name="green">&lt;/k:kunde&gt;</color>,
  <color name="red">$options</color> :=
  <color name="green">&lt;options</color> xmlns="xdmp:document-insert"<color name="green">&gt;</color>  
    <color name="green">&lt;permissions&gt;</color>{ <color name="blue">xdmp:default-permissions</color>() }<color name="green">&lt;/permissions&gt;</color>
    <color name="green">&lt;collections&gt;</color>
      <color name="green">&lt;collection&gt;</color>/kunden<color name="green">&lt;/collection&gt;</color>
    <color name="green">&lt;/collections&gt;</color>
  <color name="green">&lt;/options&gt;</color>,
  <color name="red">$fname</color> := concat('/kunden/',<color name="red">$id</color>,".xml")
  <color name="brown">return </color><color name="blue">xdmp:document-insert</color>(<color name="red">$fname</color>,<color name="red">$root</color>,<color name="red">$options</color>)
};

<color name="brown">declare </color><color name="brown">function </color><color name="blue">local:loadBestellung</color>(<color name="red">$id</color>, <color name="red">$datum</color>, <color name="red">$preis</color>, <color name="red">$kunde-id</color>)
{
  <color name="brown">let </color><color name="red">$root</color> :=
  <color name="green">&lt;b:bestellung&gt;</color>
    <color name="green">&lt;b:id&gt;</color>{ <color name="red">$id</color> }<color name="green">&lt;/b:id&gt;</color>
    <color name="green">&lt;b:datum&gt;</color>{ <color name="red">$datum</color> }<color name="green">&lt;/b:datum&gt;</color>
    <color name="green">&lt;b:preis&gt;</color>{ <color name="red">$preis</color> }<color name="green">&lt;/b:preis&gt;</color>
    <color name="green">&lt;b:kunde-id&gt;</color>{ <color name="red">$kunde-id</color> }<color name="green">&lt;/b:kunde-id&gt;</color>
  <color name="green">&lt;/b:bestellung&gt;</color>,
  <color name="red">$options</color> :=
  <color name="green">&lt;options</color> xmlns="xdmp:document-insert"<color name="green">&gt;</color>  
    <color name="green">&lt;permissions&gt;</color>{ <color name="blue">xdmp:default-permissions</color>() }<color name="green">&lt;/permissions&gt;</color>
    <color name="green">&lt;collections&gt;</color>
      <color name="green">&lt;collection&gt;</color>/bestellungen<color name="green">&lt;/collection&gt;</color>
    <color name="green">&lt;/collections&gt;</color>
  <color name="green">&lt;/options&gt;</color>,
  <color name="red">$fname</color> := concat('/bestellungen/',<color name="red">$id</color>,".xml")
  <color name="brown">return </color><color name="blue">xdmp:document-insert</color>(<color name="red">$fname</color>,<color name="red">$root</color>,<color name="red">$options</color>)
};

<color name="brown">declare </color><color name="brown">function </color><color name="blue">local:insertKundenSchema</color>()
{
  <color name="brown">let </color><color name="red">$sql-view-name</color> := 'kunden-view.xml',
      <color name="red">$sql-view</color> := <color name="green">&lt;template</color> xmlns="http://marklogic.com/xdmp/tde"<color name="green">&gt;</color>
    <color name="green">&lt;path-namespaces&gt;</color>
      <color name="green">&lt;path-namespace&gt;</color>
        <color name="green">&lt;prefix&gt;</color>k<color name="green">&lt;/prefix&gt;</color>
        <color name="green">&lt;namespace-uri&gt;</color>http://www.tekturcms.de/kunden<color name="green">&lt;/namespace-uri&gt;</color>
       <color name="green">&lt;/path-namespace&gt;</color>
    <color name="green">&lt;/path-namespaces&gt;</color>
    <color name="green">&lt;context&gt;</color>/k:kunde<color name="green">&lt;/context&gt;</color>
     <color name="green">&lt;collections&gt;</color>
       <color name="green">&lt;collections-and&gt;</color>
         <color name="green">&lt;collection&gt;</color>/kunden<color name="green">&lt;/collection&gt;</color>
      <color name="green">&lt;/collections-and&gt;</color>
     <color name="green">&lt;/collections&gt;</color>
     <color name="green">&lt;rows&gt;</color>
       <color name="green">&lt;row&gt;</color>
         <color name="green">&lt;schema-name&gt;</color>kunden_schema<color name="green">&lt;/schema-name&gt;</color>
         <color name="green">&lt;view-name&gt;</color>kunden_view<color name="green">&lt;/view-name&gt;</color>
         <color name="green">&lt;columns&gt;</color>
            <color name="green">&lt;column&gt;</color>
               <color name="green">&lt;name&gt;</color>id<color name="green">&lt;/name&gt;</color>
               <color name="green">&lt;scalar-type&gt;</color>string<color name="green">&lt;/scalar-type&gt;</color>
               <color name="green">&lt;val&gt;</color>k:id<color name="green">&lt;/val&gt;</color>
            <color name="green">&lt;/column&gt;</color>
            <color name="green">&lt;column&gt;</color>
               <color name="green">&lt;name&gt;</color>name<color name="green">&lt;/name&gt;</color>
               <color name="green">&lt;scalar-type&gt;</color>string<color name="green">&lt;/scalar-type&gt;</color>
               <color name="green">&lt;val&gt;</color>k:name<color name="green">&lt;/val&gt;</color>
            <color name="green">&lt;/column&gt;</color>
          <color name="green">&lt;column&gt;</color>
             <color name="green">&lt;name&gt;</color>eMail<color name="green">&lt;/name&gt;</color>
             <color name="green">&lt;scalar-type&gt;</color>string<color name="green">&lt;/scalar-type&gt;</color>
             <color name="green">&lt;val&gt;</color>k:eMail<color name="green">&lt;/val&gt;</color>
          <color name="green">&lt;/column&gt;</color>
        <color name="green">&lt;/columns&gt;</color>
      <color name="green">&lt;/row&gt;</color>
    <color name="green">&lt;/rows&gt;</color>
  <color name="green">&lt;/template&gt;</color>
  return
    <color name="blue">tde:template-insert</color>(concat('/templates/', 
                        <color name="red">$sql-view-name</color>), <color name="red">$sql-view</color>, <color name="blue">xdmp:default-permissions</color>())
};

<color name="brown">declare </color><color name="brown">function </color><color name="blue">local:insertBestellungenSchema</color>()
{
  <color name="brown">let </color><color name="red">$sql-view-name</color> := 'bestellungen-view.xml',
      <color name="red">$sql-view</color> := <color name="green">&lt;template</color> xmlns="http://marklogic.com/xdmp/tde"<color name="green">&gt;</color>
    <color name="green">&lt;path-namespaces&gt;</color>
      <color name="green">&lt;path-namespace&gt;</color>
        <color name="green">&lt;prefix&gt;</color>b<color name="green">&lt;/prefix&gt;</color>
        <color name="green">&lt;namespace-uri&gt;</color>http://www.tekturcms.de/bestellungen<color name="green">&lt;/namespace-uri&gt;</color>
       <color name="green">&lt;/path-namespace&gt;</color>
    <color name="green">&lt;/path-namespaces&gt;</color>
    <color name="green">&lt;context&gt;</color>/b:bestellung<color name="green">&lt;/context&gt;</color>
     <color name="green">&lt;collections&gt;</color>
       <color name="green">&lt;collections-and&gt;</color>
         <color name="green">&lt;collection&gt;</color>/bestellungen<color name="green">&lt;/collection&gt;</color>
      <color name="green">&lt;/collections-and&gt;</color>
     <color name="green">&lt;/collections&gt;</color>
     <color name="green">&lt;rows&gt;</color>
       <color name="green">&lt;row&gt;</color>
         <color name="green">&lt;schema-name&gt;</color>bestellungen_schema<color name="green">&lt;/schema-name&gt;</color>
         <color name="green">&lt;view-name&gt;</color>bestellungen_view<color name="green">&lt;/view-name&gt;</color>
         <color name="green">&lt;columns&gt;</color>
            <color name="green">&lt;column&gt;</color>
               <color name="green">&lt;name&gt;</color>id<color name="green">&lt;/name&gt;</color>
               <color name="green">&lt;scalar-type&gt;</color>string<color name="green">&lt;/scalar-type&gt;</color>
               <color name="green">&lt;val&gt;</color>b:id<color name="green">&lt;/val&gt;</color>
            <color name="green">&lt;/column&gt;</color>
            <color name="green">&lt;column&gt;</color>
               <color name="green">&lt;name&gt;</color>datum<color name="green">&lt;/name&gt;</color>
               <color name="green">&lt;scalar-type&gt;</color>string<color name="green">&lt;/scalar-type&gt;</color>
               <color name="green">&lt;val&gt;</color>b:datum<color name="green">&lt;/val&gt;</color>
            <color name="green">&lt;/column&gt;</color>
          <color name="green">&lt;column&gt;</color>
             <color name="green">&lt;name&gt;</color>preis<color name="green">&lt;/name&gt;</color>
             <color name="green">&lt;scalar-type&gt;</color>string<color name="green">&lt;/scalar-type&gt;</color>
             <color name="green">&lt;val&gt;</color>b:preis<color name="green">&lt;/val&gt;</color>
          <color name="green">&lt;/column&gt;</color>
          <color name="green">&lt;column&gt;</color>
             <color name="green">&lt;name&gt;</color>kunde_id<color name="green">&lt;/name&gt;</color>
             <color name="green">&lt;scalar-type&gt;</color>string<color name="green">&lt;/scalar-type&gt;</color>
             <color name="green">&lt;val&gt;</color>b:kunde-id<color name="green">&lt;/val&gt;</color>
          <color name="green">&lt;/column&gt;</color>
        <color name="green">&lt;/columns&gt;</color>
      <color name="green">&lt;/row&gt;</color>
    <color name="green">&lt;/rows&gt;</color>
  <color name="green">&lt;/template&gt;</color>
  return
    <color name="blue">tde:template-insert</color>(concat('/templates/', 
                        <color name="red">$sql-view-name</color>), <color name="red">$sql-view</color>, <color name="blue">xdmp:default-permissions</color>())
};

<color name="blue">
local:loadKunde</color>("1","Alex","tekturcms@gmail.com"),
<color name="blue">
local:loadKunde</color>("2","Horst","horst@horst.de"),
<color name="blue">
local:loadKunde</color>("3","Gundula","gundl@gundula.de"),
<color name="blue">
local:loadBestellung</color>("1","02.01.2019","99.90","2"),
<color name="blue">
local:loadBestellung</color>("2","03.01.2019","68.90","1"),
<color name="blue">
local:insertKundenSchema</color>(),
<color name="blue">
local:insertBestellungenSchema</color>(),
<color name="blue">
xdmp:sql</color>("SELECT name, datum, preis FROM kunden_view k INNER JOIN 
          bestellungen_view b ON k.id = b.kunde_id")</verbatim>
                  <p>... mit einer schönen tabellarischen Ausgabe im unteren Panel der Query Konsole - oder als JSON:</p>
                  <verbatim>[
  [
    "k.name", 
    "b.datum", 
    "b.preis"
  ], 
  [
    "Alex", 
    "03.01.2019", 
    "68.90"
  ], 
  [
    "Horst", 
    "02.01.2019", 
    "99.90"
  ]
]</verbatim>
               
            
         </chapter>
         <chapter hyphenation="yes" chapterpage="no" id="ef2b4070-c3cf-4d73-968e-e25f6dc1eef0"
                  ismodule="no">
            
               <title>
                  <title id="ba9dfb96-d3dd-49c8-9008-8476c0e59728">Bi-Temporale Dokumente</title>
               </title>
               
                  <p>Wenn wir zwischen der Zeit in der das Dokument, bspw. ein Vetrag 
in der DB angelegt wird, und der Zeit in der ein Vetrag zwischen zwei 
Vetragspartnern abgeschlossen wird unterscheiden, dann betrachten
wir zwei Zeitachsen.</p>
                  <ul>
                     <li>
                        <p>die gültige Zeit (Valid Time)</p>
                     </li>
                     <li>
                        <p>die Systemzeit (System Time)</p>
                     </li>
                  </ul>
                  <p>Für die Vetragspartner ist nur die gültige Zeit relevant. Das Zeitfenster
zwischen gültiger Zeit und Systemzeit ist jedoch in manchen Fällen
ausschlaggebend.</p>
                  <p>
                     <i id="e607c6b2-4d9a-4652-b8d8-26fc098c3bd7d6e16">Bsp: Kürzlich wurde
meine Geldbörse mit meinem Perso geklaut. Beim Austellen eines vorläufigen
Ausweises wurde ich schriftlich darauf hingewiesen, dass nun mein Perso
bei Interpol zur Fahndung ausgeschrieben ist.</i>
                  </p>
                  <p>
                     <i id="96689113-3ef6-49b3-9c2c-dab8e0489a27d6e19">Kurze Zeit später fand ein netter Herr die Geldbörse (ohne Geld aber 
mit allen Papieren) in seinem Garten. Bei einer anschliessenden Busfahrt mit einem
Fernbus, wurde ich bei einer Zollkontrolle festgehalten, da das System der Polizei noch nicht aktualisiert war.</i>
                  </p>
                  <p>Ich nehme an, dass nach meiner Unschuldsbekundung der Vorgang auch
auf Seiten des Polizeicomputers aktualisiert wurde. Nun könnte man zwei Fragen
stellen:</p>
                  <procedure type="ol">
                     <step>
                        <action>
                           <p>Ist das Festhalten seitens der Zollbeamten rechtens?</p>
                        </action>
                     </step>
                     <step>
                        <action>
                           <p>Habe ich mich durch ein verspätetes Anzeigen des Funds schuldig gemacht?</p>
                        </action>
                     </step>
                  </procedure>
                  <note>
                     <consequence>
                        <p>Beachte, dass man diese Fragen auch noch nach 10 Jahren stellen
könnte und das - bei meinem Pech in diesen Angelegenheiten - so ein Vorfall auch noch öfters passieren könnte...</p>
                     </consequence>
                  </note>
                  <p>Um diese Fragen zu beantworten, müsste unsere Datenbank in der Lage sein,
eine <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                    address="https://en.wikipedia.org/wiki/Temporal_database">bitemporale Query</url> auszuführen. Zunächst registerieren wir den Vorgang
des Persoverlustes in unserer Marklogic Datenbank:</p>
                  <note>
                     <consequence>
                        <p>Da wir hier auf einer XML Datenbank arbeiten, sprechen wir von einem Dokument,
wenn wir einen Datensatz meinen. </p>
                        <p>Der Datensatz bzw. das Dokument wird nicht aktualisiert, sondern stattdessen das Dokument mit den aktualisierten Daten in einer neuen Version angelegt. </p>
                        <p>Auf diese Weise bleibt die Änderungshistorie erhalten.</p>
                     </consequence>
                  </note>
                  <verbatim>xquery version "1.0-ml";
import <color name="brown">module </color><color name="brown">namespace </color>temporal = 
       "http://marklogic.com/xdmp/temporal" at "/MarkLogic/temporal.xqy";   
<color name="brown">let </color><color name="red">$root</color> :=    
  <color name="green">&lt;vorgang&gt;</color>     
    <color name="green">&lt;perso-id&gt;</color>XYZ<color name="green">&lt;/perso-id&gt;</color>    
    <color name="green">&lt;name&gt;</color>Alex Düsel<color name="green">&lt;/name&gt;</color>   
    <color name="green">&lt;status&gt;</color>gestohlen<color name="green">&lt;/status&gt;</color>
  <color name="green">&lt;/vorgang&gt;</color>
<color name="brown">let </color><color name="red">$options</color> :=   
  <color name="green">&lt;options</color> xmlns="xdmp:document-insert"<color name="green">&gt;</color>     
    <color name="green">&lt;metadata&gt;</color>        
      <color name="green">&lt;map:map</color> xmlns:map="http://marklogic.com/xdmp/map"<color name="green">&gt;</color>          
        <color name="green">&lt;map:entry</color> key="validStart"<color name="green">&gt;</color>            
	  <color name="green">&lt;map:value&gt;</color>2019-02-01T08:23:11<color name="green">&lt;/map:value&gt;</color>          
	<color name="green">&lt;/map:entry&gt;</color>          
	<color name="green">&lt;map:entry</color> key="validEnd"<color name="green">&gt;</color>            
	  <color name="green">&lt;map:value&gt;</color>9999-12-31T11:59:59Z<color name="green">&lt;/map:value&gt;</color>          
	<color name="green">&lt;/map:entry&gt;</color>         
      <color name="green">&lt;/map:map&gt;</color>    
    <color name="green">&lt;/metadata&gt;</color>  

<color name="brown">return </color> <color name="blue">temporal:document-insert</color>("/perso-verluste", 
                                 "duesel_alex_270774.xml", 
                                 <color name="red">$root</color>, <color name="red">$options</color>)</verbatim>
                  <p>Unser Enddatum liegt in ferner Zukunft sicherzustellen, dass der Vorgang auf unbestimmte Zeit
im System bleibt.</p>
                  <p>Drei Tage später hatte ich meinen Ausweis wieder und der Vorgang wurde vier Tage später,
mit dem Status "gefunden" im Polizeicomputer aktualisiert:</p>
                  <verbatim>xquery version "1.0-ml";
import <color name="brown">module </color><color name="brown">namespace </color>temporal = 
       "http://marklogic.com/xdmp/temporal" at "/MarkLogic/temporal.xqy";   
<color name="brown">let </color><color name="red">$root</color> :=    
  <color name="green">&lt;vorgang&gt;</color>     
    <color name="green">&lt;perso-id&gt;</color>XYZ<color name="green">&lt;/perso-id&gt;</color>    
    <color name="green">&lt;name&gt;</color>Alex Düsel<color name="green">&lt;/name&gt;</color>   
    <color name="green">&lt;status&gt;</color><b>gefunden</b><color name="green">&lt;/status&gt;</color>
  <color name="green">&lt;/vorgang&gt;</color>
<color name="brown">let </color><color name="red">$options</color> :=   
  <color name="green">&lt;options</color> xmlns="xdmp:document-insert"<color name="green">&gt;</color>     
    <color name="green">&lt;metadata&gt;</color>        
      <color name="green">&lt;map:map</color> xmlns:map="http://marklogic.com/xdmp/map"<color name="green">&gt;</color>          
        <color name="green">&lt;map:entry</color> key="validStart"<color name="green">&gt;</color>            
	  <color name="green">&lt;map:value&gt;</color>2019-02-06T08:00:00<color name="green">&lt;map:value&gt;</color>          
	<color name="green">&lt;/map:entry&gt;</color>          
	<color name="green">&lt;map:entry</color> key="validEnd"<color name="green">&gt;</color>            
	  <color name="green">&lt;map:value&gt;</color>9999-12-31T11:59:59Z<color name="green">&lt;/map:value&gt;</color>          
	<color name="green">&lt;/map:entry&gt;</color>         
      <color name="green">&lt;/map:map&gt;</color>    
    <color name="green">&lt;/metadata&gt;</color>  

<color name="brown">return </color> <color name="blue">temporal:document-insert</color>("/perso-verluste", 
                                 "duesel_alex_270774.xml", 
                                 <color name="red">$root</color>, <color name="red">$options</color>)</verbatim>
                  <p>Nach der Aktualisierung enthält unsere Datenbank logisch gesehen drei Dokumente zu diesem Vorgang, 
die über eine Query gesucht werden können:</p>
                  <procedure type="ol">
                     <step>
                        <action>
                           <p>Das Originaldokument, es ist vom 1.2.2019 bis zum 5.2.2019 im System aktiv</p>
                        </action>
                     </step>
                     <step>
                        <action>
                           <p>Die Aktualisierung, sie ist ab dem 6.2.2019 aktiv</p>
                        </action>
                     </step>
                     <step>
                        <action>
                           <p>Ein "Split"-Dokument, das aus der verspäteten Aktualisierung resultiert. Es ist ab dem 6.2.2019 im System aktiv, 
und zeigt den Zeitraum über einen Tag, vom 4.2.2019 bis 5.2.2019 - in dem ich ohne Perso registriert war, ihn aber tatsächlich
schon wieder hatte.</p>
                        </action>
                     </step>
                  </procedure>
                  <p>Im Gegensatz zu einer herkömmlichen Datenhaltung, bei der ein Datensatz aktualisiert wird - ggf. noch eine neue
Version angelegt wird - wird beim Dokument-basierten Ansatz mit bi-temporaler Datenhaltung jede Transaktion separat
abgespeichert. </p>
                  <p>Das ist vergleichbar mit einer Simulation des tatsächlichen Papierverkehrs bei buchhalterischen Tätigkeiten.</p>
                  <p>Die Abfrage so einer Datenbank ist dadurch nicht einfacher. Drei Queries, die jeweils eines dieser drei
Dokumente zurückgeben, könnten bspw. so aussehen:</p>
                  <p>
               <subtitle xmlns:tektur="http://www.stylesheet-entwicklung.de">Rückgabe des Originals</subtitle>
            </p>
                  <verbatim>xquery version "1.0-ml";<color name="blue">
cts:search</color>(<color name="blue">fn:doc</color>(), <color name="blue">cts:period-range-query</color>(
  "system",     
  "ISO_CONTAINS",     
  <color name="blue">cts:period</color>(<color name="blue">xs:dateTime</color>("2019-02-02T00:00:00"),                
             <color name="blue">xs:dateTime</color>("2019-02-03T23:59:59")) )</verbatim>
                  <p>Hier wird geprüft, ob ein Dokument im System aktiv war, dass den Zeitraum vom 2.3. bis zum 3.3. umfasste (<code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>ISO_CONTAINS</nb>
               </code>). Diese Query ist erfolgreich und gibt das Original-Dokument des Vorgangs zurück: In diesem Zeitraum war ich also mit gestohlenem Perso registriert.</p>
                  <p>
               <subtitle xmlns:tektur="http://www.stylesheet-entwicklung.de">Rückgabe des Split-Dokuments</subtitle>
            </p>
                  <verbatim>xquery version "1.0-ml";<color name="blue">
cts:search</color>(<color name="blue">fn:doc</color>(), <color name="blue">cts:period-range-query</color>(
   "valid",
   "ALN_FINISHES",
   <color name="blue">cts:period</color>(<color name="blue">xs:dateTime</color>("2019-02-06T08:00:00"),
              <color name="blue">xs:dateTime</color>("2019-02-06T08:00:00")) ))</verbatim>
                  <p>Bei dieser Query wird geprüft, ob es ein Dokument gibt, dass zu einem bestimmten Datum auf inaktiv gesetzt wurde (<code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>ALN_FINISHES</nb>
               </code>) - Das Split-Dokument wird automatisch auf inaktiv gesetzt, wenn die neue Version angelegt wird. Unser Suchdatum wäre also folgendes <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>2019-02-06T08:00:00</nb>
               </code>.</p>
                  <p>
               <subtitle xmlns:tektur="http://www.stylesheet-entwicklung.de">Rückgabe von Split und neuer Version</subtitle>
            </p>
                  <verbatim>xquery version "1.0-ml";<color name="blue">
cts:search</color>(<color name="blue">fn:doc</color>(), <color name="blue">cts:period-range-query</color>(
   "system",
   "ALN_AFTER",
   <color name="blue">cts:period</color>(<color name="blue">xs:dateTime</color>("2019-02-05T11:00:00"),
              <color name="blue">xs:dateTime</color>("2019-02-05T11:20:00")) ))</verbatim>
                  <p>Hier wird geprüft ob es Dokumente gibt, die nach einer bestimmten Zeitspanne im System aktiv waren. Man beachte hier, dass eine Periode angegeben ist, obwohl nur ein Datum notwendig wäre. Der Vergleichsoperator hierzu heisst <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>ALN_AFTER</nb>
               </code>.</p>
                  <p>
               <subtitle xmlns:tektur="http://www.stylesheet-entwicklung.de">Rückgabe von aktueller Version</subtitle>
            </p>
                  <verbatim>xquery version "1.0-ml";<color name="blue">
cts:search</color>(<color name="blue">fn:doc</color>(), <color name="blue">cts:period-compare-query</color>(
   "system",
   "ISO_CONTAINS",
   "valid" ))</verbatim>
                  <p>Die aktuelle Version kann in Erfahrung gebracht werden, indem geprüft wird, welche gültigen Dokumente innerhalb der Systemzeitspanne liegen. Das kann nur die aktuelle Version sein. Frühere gültige Versionen und Split-Dokumente wären vor der Systemzeit-Spanne.</p>
                  <p>Die letzte Version eines Dokuments kann aber auch einfach über ein <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                  <nb>latest</nb>
               </code> flag in Erfahrung gebracht werden:</p>
                  <verbatim>xquery version "1.0-ml";<color name="blue">
cts:search</color>(<color name="blue">fn:doc</color>(), <color name="blue">cts:and-query</color>((
    <color name="blue">cts:collection-query</color>(("koolorder.xml")),
    <color name="blue">cts:collection-query</color>(("latest")))))</verbatim>
                  <p>
               <subtitle xmlns:tektur="http://www.stylesheet-entwicklung.de">Weiterführende Links</subtitle>
            </p>
                  <ul>
                     <li>
                        <p>
                     <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                          address="https://docs.marklogic.com/guide/temporal">Temporal Developer's Guide auf den MarkLogic Doku-Seiten</url>
                  </p>
                     </li>
                     <li>
                        <p>
                     <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                          address="https://www.marklogic.com/blog/bitemporal/">A Deep Dive into Bitemporal</url>
                  </p>
                     </li>
                     <li>
                        <p>
                     <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                          address="https://www.heise.de/developer/artikel/Temporale-Datenhaltung-in-der-Praxis-mit-Java-2100268.html?seite=all">Temporale Datenhaltung in der Praxis mit Java</url>
                  </p>
                     </li>
                  </ul>
               
            
            <chapter hyphenation="yes" chapterpage="no" id="7c58baac-7b83-41b9-adf6-12f63539cbb6"
                     ismodule="no">
               
                  <title>
                     <title id="a1776d29-3de4-4aeb-9f82-1718bfdb333e">Anlegen des Testszenarios auf der ML Konsole</title>
                  </title>
                  
                     <p>Die Codefragmente aus dem vorherigen Kapitel sind folgend für eine ML Konsolensitzung aufbereitet:</p>
                     <ul>
                        <li>
                           <p>Anlegen der temporalen Properties: <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                           <nb>validStart</nb>
                        </code>, <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                           <nb>validEnd</nb>
                        </code>, <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                           <nb>systemStart</nb>
                        </code>, <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                           <nb>systemEnd</nb>
                        </code>
                     </p>
                        </li>
                        <li>
                           <p>Anlegen der Indizes zum Suchen über Zeitbereiche: <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                           <nb>database-range-field-index("dateTime", "systemStart",...</nb>
                        </code>
                     </p>
                        </li>
                        <li>
                           <p>Anlegen der zwei Zeitachsen <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                           <nb>system</nb>
                        </code> und <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                           <nb>valid</nb>
                        </code>
                     </p>
                        </li>
                        <li>
                           <p>Anlegen der temporalen Collection <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                           <nb>/perso-verluste</nb>
                        </code>
                     </p>
                        </li>
                        <li>
                           <p>Anlegen des Originals am 1.2.2019</p>
                        </li>
                        <li>
                           <p>Aktualisierung am 6.2.2019</p>
                        </li>
                     </ul>
                     <verbatim>xquery version "1.0-ml";

import <color name="brown">module </color><color name="brown">namespace </color>admin = 
  "http://marklogic.com/xdmp/admin" at "/MarkLogic/admin.xqy";
import <color name="brown">module </color><color name="brown">namespace </color>temporal = 
  "http://marklogic.com/xdmp/temporal" at "/MarkLogic/temporal.xqy";

<color name="brown">declare </color><color name="brown">namespace </color>local = 'local:';
<color name="brown">declare </color><color name="brown">variable </color><color name="red">$db</color> := "alex-test";

<color name="brown">declare </color><color name="brown">function </color><color name="blue">local:create-temporal-fields</color>()
{
  <color name="brown">let </color><color name="red">$config</color> := <color name="blue">admin:get-configuration</color>(),
      <color name="red">$dbid</color> := <color name="blue">xdmp:database</color>(<color name="red">$db</color>)
  <color name="brown">return </color>
    try {
      <color name="blue">admin:save-configuration</color>(
        <color name="blue">admin:database-add-field</color>(<color name="red">$config</color>, <color name="red">$dbid</color>, 
        <color name="blue">admin:database-metadata-field</color>("validStart"))),
      <color name="blue">admin:save-configuration</color>(
        <color name="blue">admin:database-add-field</color>(<color name="red">$config</color>, <color name="red">$dbid</color>, 
        <color name="blue">admin:database-metadata-field</color>("validEnd"))),
      <color name="blue">admin:save-configuration</color>(
        <color name="blue">admin:database-add-field</color>(<color name="red">$config</color>, <color name="red">$dbid</color>, 
        <color name="blue">admin:database-metadata-field</color>("systemStart"))),
      <color name="blue">admin:save-configuration</color>(
        <color name="blue">admin:database-add-field</color>(<color name="red">$config</color>, <color name="red">$dbid</color>, 
        <color name="blue">admin:database-metadata-field</color>("systemEnd")))
    } catch (<color name="red">$err</color>) {}
};

<color name="brown">declare </color><color name="brown">function </color><color name="blue">local:create-range-index-fields</color>() 
{
  <color name="brown">let </color><color name="red">$config</color> := <color name="blue">admin:get-configuration</color>(),
      <color name="red">$dbid</color> := <color name="blue">xdmp:database</color>(<color name="red">$db</color>)
  return
    try {
      <color name="blue">admin:save-configuration</color>(
        <color name="blue">admin:database-add-range-field-index</color>(<color name="red">$config</color>, <color name="red">$dbid</color>, 
        <color name="blue">admin:database-range-field-index</color>("dateTime", "validStart", "", <color name="blue">fn:true</color>()))),
      <color name="blue">admin:save-configuration</color>(
        <color name="blue">admin:database-add-range-field-index</color>(<color name="red">$config</color>, <color name="red">$dbid</color>, 
        <color name="blue">admin:database-range-field-index</color>("dateTime", "validEnd", "", <color name="blue">fn:true</color>()))),
      <color name="blue">admin:save-configuration</color>(
        <color name="blue">admin:database-add-range-field-index</color>(<color name="red">$config</color>, <color name="red">$dbid</color>, 
        <color name="blue">admin:database-range-field-index</color>("dateTime", "systemStart", "", <color name="blue">fn:true</color>()))),
      <color name="blue">admin:save-configuration</color>(
        <color name="blue">admin:database-add-range-field-index</color>(<color name="red">$config</color>, <color name="red">$dbid</color>, 
        <color name="blue">admin:database-range-field-index</color>("dateTime", "systemEnd", "", <color name="blue">fn:true</color>())))
    } catch (<color name="red">$err</color>) {}  
};

<color name="brown">declare </color><color name="brown">function </color><color name="blue">local:create-axes</color>()
{
  try {
    <color name="brown">let </color><color name="red">$t</color>1 := <color name="blue">temporal:axis-create</color>(
          "valid",
          <color name="blue">cts:field-reference</color>("validStart", "type=dateTime"),
          <color name="blue">cts:field-reference</color>("validEnd", "type=dateTime")),
        <color name="red">$t</color>2 := <color name="blue">temporal:axis-create</color>(
          "system",
          <color name="blue">cts:field-reference</color>("systemStart", "type=dateTime"),
          <color name="blue">cts:field-reference</color>("systemEnd", "type=dateTime"))
     <color name="brown">return </color>()
   } catch (<color name="red">$err</color>) {}
};

<color name="brown">declare </color><color name="brown">function </color><color name="blue">local:create-temporal-collection</color>() 
{
  try {
    <color name="brown">let </color><color name="red">$t</color>:= <color name="blue">temporal:collection-create</color>("/perso-verluste", "system", "valid")
    <color name="brown">return </color>()
  } catch (<color name="red">$err</color>) {}
};

<color name="brown">declare </color><color name="brown">function </color><color name="blue">local:insert-original</color>()
{
  <color name="brown">let </color><color name="red">$root</color> := 
    <color name="green">&lt;vorgang&gt;</color>     
      <color name="green">&lt;perso-id&gt;</color>XYZ<color name="green">&lt;/perso-id&gt;</color>    
      <color name="green">&lt;name&gt;</color>Alex Düsel<color name="green">&lt;/name&gt;</color>   
      <color name="green">&lt;status&gt;</color>gestohlen<color name="green">&lt;/status&gt;</color>
    <color name="green">&lt;/vorgang&gt;</color>,
     <color name="red">$options</color> :=   
    <color name="green">&lt;options</color> xmlns="xdmp:document-insert"<color name="green">&gt;</color>     
      <color name="green">&lt;metadata&gt;</color>        
        <color name="green">&lt;map:map</color> xmlns:map="http://marklogic.com/xdmp/map"<color name="green">&gt;</color>          
          <color name="green">&lt;map:entry</color> key="validStart"<color name="green">&gt;</color>            
	          <color name="green">&lt;map:value&gt;</color>2019-02-01T08:23:11<color name="green">&lt;/map:value&gt;</color>          
	        <color name="green">&lt;/map:entry&gt;</color>          
	        <color name="green">&lt;map:entry</color> key="validEnd"<color name="green">&gt;</color>            
	          <color name="green">&lt;map:value&gt;</color>9999-12-31T11:59:59Z<color name="green">&lt;/map:value&gt;</color>          
	        <color name="green">&lt;/map:entry&gt;</color>         
         <color name="green">&lt;/map:map&gt;</color>    
      <color name="green">&lt;/metadata&gt;</color>  
    <color name="green">&lt;/options&gt;</color>
  <color name="brown">return </color> <color name="blue">temporal:document-insert</color>("/perso-verluste", 
                                   "duesel_alex_270774.xml", 
                                   <color name="red">$root</color>, <color name="red">$options</color>)
};

<color name="brown">declare </color><color name="brown">function </color><color name="blue">local:insert-update</color>()
{
  <color name="brown">let </color><color name="red">$root</color> :=    
    <color name="green">&lt;vorgang&gt;</color>     
      <color name="green">&lt;perso-id&gt;</color>XYZ<color name="green">&lt;/perso-id&gt;</color>    
      <color name="green">&lt;name&gt;</color>Alex Düsel<color name="green">&lt;/name&gt;</color>   
      <color name="green">&lt;status&gt;</color>gefunden<color name="green">&lt;/status&gt;</color>
    <color name="green">&lt;/vorgang&gt;</color>,
    <color name="red">$options</color> :=   
    <color name="green">&lt;options</color> xmlns="xdmp:document-insert"<color name="green">&gt;</color>     
      <color name="green">&lt;metadata&gt;</color>        
        <color name="green">&lt;map:map</color> xmlns:map="http://marklogic.com/xdmp/map"<color name="green">&gt;</color>          
          <color name="green">&lt;map:entry</color> key="validStart"<color name="green">&gt;</color>            
	          <color name="green">&lt;map:value&gt;</color>2019-02-06T08:00:00<color name="green">&lt;/map:value&gt;</color>          
	        <color name="green">&lt;/map:entry&gt;</color>          
	        <color name="green">&lt;map:entry</color> key="validEnd"<color name="green">&gt;</color>            
	          <color name="green">&lt;map:value&gt;</color>9999-12-31T11:59:59Z<color name="green">&lt;/map:value&gt;</color>          
	        <color name="green">&lt;/map:entry&gt;</color>         
         <color name="green">&lt;/map:map&gt;</color>    
      <color name="green">&lt;/metadata&gt;</color>  
    <color name="green">&lt;/options&gt;</color>
  <color name="brown">return </color> <color name="blue">temporal:document-insert</color>("/perso-verluste", 
                                   "duesel_alex_270774.xml", 
                                   <color name="red">$root</color>, <color name="red">$options</color>)
};

( <color name="blue">xdmp:invoke-function</color>(local:create-temporal-fields#0),
  <color name="blue">xdmp:invoke-function</color>(local:create-range-index-fields#0),
  <color name="blue">xdmp:invoke-function</color>(local:create-axes#0),
  <color name="blue">xdmp:invoke-function</color>(local:create-temporal-collection#0),
  <color name="blue">xdmp:invoke-function</color>(local:insert-original#0),
  <color name="blue">xdmp:invoke-function</color>(local:insert-update#0))</verbatim>
                     <note>
                        <consequence>
                           <p>Beachtenswert ist hier,</p>
                           <procedure type="ol">
                              <step>
                                 <action>
                                    <p>dass die einzelnen Schritte als Funktion über <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                                    <nb>xdmp:invoke-function</nb>
                                 </code> aufgerufen werden. Dieses Konstrukt wird normalerweise benutzt um eine Funktion <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                                      address="https://de.wikipedia.org/wiki/Anonyme_Funktion">anonym</url> zu deklarieren und als Transaktion aufzurufen. Marklogic bietet <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                                      address="https://docs.marklogic.com/guide/app-dev/transactions">weitere Möglichkeiten</url> transaktional zu arbeiten.</p>
                                 </action>
                              </step>
                              <step>
                                 <action>
                                    <p>Um die 5 Tage zwiachen Verlustmeldung und Wiederauffinden zu simulieren, wurde zwischem dem Anlegen der Dokumente ein <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                                    <nb>xdmp:sleep</nb>
                                 </code> Statement eingefügt.</p>
                                 </action>
                              </step>
                           </procedure>
                        </consequence>
                     </note>
                     <p>Lassen wir diese Query auf einer frischen Datenbank laufen, so erhalten wir die folgendes Ergebnis:</p>
                     <figure pdfwidth="page">
                        <desc id="5147b2e9-3422-401c-920f-997b9f592d46d6e40">Nach der Ausführung obiger Query gibt es in der DB drei Dokumente, das Orginal, das Split-Dokument und die Aktualisierung. Das Split-Dokuments und das Originals sind als Vorgänger mit Suffix gekennzeichnet.</desc>
                        <img src="./client/data/7c58baac-7b83-41b9-adf6-12f63539cbb6/temporal-documents.png"/>
                     </figure>
                  
               
            </chapter>
            <chapter hyphenation="yes" chapterpage="no" id="62faa067-ecd5-4053-8388-e7e151f04542"
                     ismodule="no">
               
                  <title>
                     <title id="877dafce-2dfe-4a6f-9483-cfe566858b83">Ausführen einiger Beispiel-Queries</title>
                  </title>
                  
                     <p>Wie im vorherigen Kapitel beschrieben, muss in der Konsolensitzung zwischen Anlegen der Originalversion und der Aktualisierung eine Verzögerung eingebaut werden, um irgendwie das "Zeitloch" zu simulieren, in dem - wenn wir bei dem vorherigen Beispiel bleiben -  der Personalausweis als Verlust gemeldet war, aber tatsächlich schon wieder in meinem Besitz war.</p>
                     <p>Ohne jetzt groß <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>validStart</nb>
                  </code> und <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>validEnd</nb>
                  </code> anzupassen, habe ich das Beispiel mit einer Verzögerung von 50 Sekunden lassen:</p>
                     <verbatim>( <color name="blue">xdmp:invoke-function</color>(local:create-temporal-fields#0),
  <color name="blue">xdmp:invoke-function</color>(local:create-range-index-fields#0),
  <color name="blue">xdmp:invoke-function</color>(local:create-axes#0),
  <color name="blue">xdmp:invoke-function</color>(local:create-temporal-collection#0),
  <color name="blue">xdmp:invoke-function</color>(local:insert-original#0),
  <b><color name="blue">xdmp:sleep</color>(50000),</b>
  <color name="blue">xdmp:invoke-function</color>(local:insert-update#0))</verbatim>
                     <p>Und bekomme folgendes Ergebnis:</p>
                     <table pdfwidth="page" id="c4bd0531-72dc-4551-9712-58a21abef158d6e12" pgwide="1"
                      frame="all"
                      scale="50"
                      status="changed">
                        <desc id="8e8cca9e-d53d-42f0-879c-8d992b402763d6e16">Diese Daten wurde aus der Exploreransicht der Konsolensitzung entnommen. </desc>
                        <tgroup id="adec2654-1ba0-479c-a8f8-b4c2a3d8d10cd6e18" cols="5">
                           <colspec id="516f50a0-b221-419d-b2d6-09c0cc26d341d6e19" colwidth="0.1755868544600939*"
                              colname="col0"/>
                           <colspec id="7df46056-37a7-40a1-9cf2-32ed3da8e445d6e20" colwidth="0.20657276995305165*"
                              colname="col1"/>
                           <colspec id="cfa176cf-2c4e-422c-bbf6-263b889e6542d6e21" colwidth="0.2084507042253521*"
                              colname="col2"/>
                           <colspec id="63a9b8ae-ef6d-4707-b250-d1d6fb6a13e2d6e22" colwidth="0.19812206572769953*"
                              colname="col3"/>
                           <colspec id="3c77a56e-6b50-4f64-9aa5-5309aeb1b00cd6e23" colwidth="0.2112676056338028*"
                              colname="col4"/>
                           <thead id="ab086331-5232-43ea-a396-539c84043411d6e24">
                              <row id="c703b676-ceea-4337-8bc3-0be503d9eff0d6e25">
                                 <entry id="a38c831e-2b41-43fc-841f-2541260f4362d6e26" colname="col0" width="187px">
                                    <p>Document</p>
                                 </entry>
                                 <entry id="a798d863-da02-4ce1-9318-b6b28cc38156d6e29" colname="col1" width="220px">
                                    <p>validStart</p>
                                 </entry>
                                 <entry id="924879d8-9aa8-4248-b749-547e4fc7262ad6e32" colname="col2" width="222px">
                                    <p>validEnd</p>
                                 </entry>
                                 <entry id="367201cd-7123-4686-94f5-8667a546e1aed6e35" colname="col3" width="211px">
                                    <p>systemStart</p>
                                 </entry>
                                 <entry id="7be5e796-36a8-4902-8edd-be417d386360d6e38" colname="col4" width="225px">
                                    <p>systemEnd</p>
                                 </entry>
                              </row>
                           </thead>
                           <tbody id="48f8662f-0205-4a49-9839-8df16e624f8cd6e41">
                              <row id="cb9da5ab-4ded-44f3-aae7-88c9c650c9cad6e42">
                                 <entry id="52a166f9-c411-49b9-b6f9-87eddba135d9d6e43" colname="col0" width="187px">
                                    <p>duesel_alex_270774.2462380991258156208.xml</p>
                                 </entry>
                                 <entry id="0e568e16-fe65-49bf-b44c-51220db80abbd6e46" colname="col1" width="220px">
                                    <p>2019-03-19T14:17:00</p>
                                 </entry>
                                 <entry id="8fcdd883-5f3f-4462-a4d5-594537b5a3ddd6e49" colname="col2" width="222px">
                                    <p>
                                       <b>unendlich</b>
                                    </p>
                                 </entry>
                                 <entry id="b1d0fd29-4485-46ad-9789-766bea1a93c1d6e53" colname="col3" width="211px">
                                    <p>2019-03-19T13:18:28</p>
                                 </entry>
                                 <entry id="91a9cf5b-d17c-41be-b747-04669777faa0d6e56" colname="col4" width="225px">
                                    <p>2019-03-19T13:19:18</p>
                                 </entry>
                              </row>
                              <row id="ba857e5f-8079-4abb-a958-32eeb9be117fd6e59">
                                 <entry id="215d8f42-8e8f-4f3d-be01-817415e4ed25d6e60" colname="col0" width="187px">
                                    <p>duesel_alex_270774.819911042637597172.xml</p>
                                 </entry>
                                 <entry id="334978f7-c122-4c7c-aec0-19f4c406f547d6e63" colname="col1" width="220px">
                                    <p>2019-03-19T14:17:00</p>
                                 </entry>
                                 <entry id="ec4ac83b-2f17-42a2-9281-1c65af95536cd6e66" colname="col2" width="222px">
                                    <p>2019-03-19T14:18:00</p>
                                 </entry>
                                 <entry id="45975819-503b-4505-a411-d0a88e810563d6e69" colname="col3" width="211px">
                                    <p>2019-03-19T13:19:18</p>
                                 </entry>
                                 <entry id="93460c01-00fc-411d-b548-cbab125c6150d6e72" colname="col4" width="225px">
                                    <p>
                                       <b>unendlich</b>
                                    </p>
                                 </entry>
                              </row>
                              <row id="6e6980c7-5e8e-4c96-b5ba-05037bf540c8d6e76">
                                 <entry id="c5aa1f64-8049-4604-aa7d-2b33e729e72fd6e77" colname="col0" width="187px">
                                    <p>duesel_alex_270774.xml</p>
                                 </entry>
                                 <entry id="8725032e-d846-4bec-8225-0fb5c0ae5e4ed6e80" colname="col1" width="220px">
                                    <p>2019-03-19T14:18:00</p>
                                 </entry>
                                 <entry id="ee51ec45-cdc3-491a-9cee-ac03bdcbe570d6e83" colname="col2" width="222px">
                                    <p>
                                       <b>unendlich</b>
                                    </p>
                                 </entry>
                                 <entry id="dd806e49-47d1-4e96-a119-22ad01339defd6e87" colname="col3" width="211px">
                                    <p>2019-03-19T13:19:18</p>
                                 </entry>
                                 <entry id="c4ed66d7-2c2e-4ffe-b831-5ad172a41df4d6e90" colname="col4" width="225px">
                                    <p>
                                       <b>unendlich</b>
                                    </p>
                                 </entry>
                              </row>
                           </tbody>
                        </tgroup>
                     </table>
                     <p/>
                     <p>Wie man sieht, müsste sich jetzt das Zeitloch von 50 Sekunden der Systemzeiten innerhalb der gültigen Zeiten befinden, um das Beispiel mit dem verlorenen Ausweis zumindest für die Zeitspanne von 50 Sekunden simulieren zu können. </p>
                     <p>Das korrekte Setup bleibt an dieser Stelle dem geneigten Leser selbst überlassen.</p>
                     <p>Zwei Queries, die die Werte in der Tabelle illustriere sind bspw. folgende:</p>
                     <figure pdfwidth="page">
                        <desc id="d1dc83a3-b951-44f1-bf70-e02d7bdc8e75d6e101">Bei dieser Query werden alle Dokumente gesucht, deren gültiger Zeitraum, den Zeitraum zwischen 14:17 Uhr und 14:18 Uhr umfasst. Das sind das Split-Dokument und das Original-Dokument. Beide mit dem Status "gestolen", da erst um 14:18 Uhr der Fund bekannt gegeben wurde.</desc>
                        <img src="./client/data/62faa067-ecd5-4053-8388-e7e151f04542/result1.png"/>
                     </figure>
                     <figure pdfwidth="page">
                        <desc id="9ea26146-dd61-40a8-aa39-a0f51e71ad92d6e105">Verändert man den Zeitraum nach 18:00 Uhr, so wird das Original - wie erwartet - durch das Update verdrängt.</desc>
                        <img src="./client/data/62faa067-ecd5-4053-8388-e7e151f04542/result2.png"/>
                     </figure>
                     <figure pdfwidth="page">
                        <desc id="d1432d45-67a8-4d05-84a2-c51dafb76443d6e109">Die aktuelle Version des temporal verwalteten Dokuments ist in der Collection "<i id="5fb358f2-9a8a-48ce-b92e-2732bb8a695dd6e111">latest</i>" gespeichert.</desc>
                        <img src="./client/data/62faa067-ecd5-4053-8388-e7e151f04542/result_3.png"/>
                     </figure>
                     <p>Wie man sie kann man - ausreichend Lösungsphantasie vorausgesetzt - einiges mit diesen Queries anstellen. Hilfreich ist sicherlich auch die umfangreiche Liste der Vergleichsoperatoren, die MarkLogic zum Vergleichen von Zeiträumen bereitstellt: <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                       address="https://docs.marklogic.com/guide/temporal/searching#id_92200">ISO Operator</url> und <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                       address="https://docs.marklogic.com/guide/temporal/searching#id_98704">ALLEN Operators</url>.</p>
                  
               
            </chapter>
         </chapter>
      </chapter>
      <chapter hyphenation="yes" chapterpage="no" id="b3eba8f1-fb04-4ab5-ac92-5f52c80d1936"
               ismodule="no">
         
            <title>
               <title id="05ed1e37-8006-4bb7-ba6a-7c143ff22106">Testing</title>
            </title>
            
               <p>In diese Kapitel werden einige ausgewählte Themen zum Testing von XSLT und XQuery Programmen dargestellt. Dabei geht es weder um Vollständigkeit noch um die beste/eleganteste Lösung, sondern eher um die Vorstellung eines Anwendungsszenarios mit einem potentiellen Lösungsansatz.</p>
            
         
         <chapter hyphenation="yes" chapterpage="no" id="6fd7b270-9d1f-4f8e-996f-13b5862956a9"
                  ismodule="no">
            
               <title>
                  <title id="a693fc99-5e16-4788-95a0-958870aa845a">Validierung mit Schematron</title>
               </title>
               
                  <p>Um die Korrektheit einer XML Instanz zu prüfen, gib es verschiedene Schemata, wie XSD, RNG oder DTD, welche der Parser beim Aufbau des DOM Baums heranzieht. Eine Validierung mit Apache Xerces könnte beispielsweise als Java Code folgendermaßen angestossen werden:</p>
                  <verbatim>URL schemaFile = new URL("http://host:port/filename.xsd");
Source xmlFile = new StreamSource(new File("web.xml"));
SchemaFactory schemaFactory = SchemaFactory
    .newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
try {
  Schema schema = schemaFactory.newSchema(schemaFile);
  Validator validator = schema.newValidator();
  validator.validate(xmlFile);
  System.out.println(xmlFile.getSystemId() + " is valid");
} catch (SAXException e) {
  System.out.println(xmlFile.getSystemId() + " is NOT valid reason:" + e);
} catch (IOException e) {</verbatim>
                  <p>Schema Dateien können aber auch in XML Editoren eingebunden werden, um schon während der Eingabe der XML Instanz die Korrektheit zu überprüfen. </p>
                  <p>Das geht einerseits über die Angabe des Doctypes in der XML Instanz, anderseits bieten auch alle Editoren die Möglichkeit ein bestimmtes Schema explizit auszuwählen, um gegen dieses auf Anforderung zu validieren.</p>
                  <p>Gilt es komplexere Businessregeln zu überprüfen, die über Syntax-, Konsistenz- und einfache Korrektheitschecks hinausgehen, empfiehlt sich eine Validierung mit Schematron Regeln.</p>
                  <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                     id="a99e14e5-6fc7-44a9-9692-cdf9799bf8bcd6e14">
                     
                        <title>
                           <title id="c802dd14-5953-4c24-8637-f7552d107e57d6e13">Schematron ist XSLT</title>
                        </title>
                        <p>Bei einer Schematron Validierung wird eine XML Instanz mit Hilfe eines automatisch generierten XSLT Stylesheets überprüft. Dieses kontextabhängige Stylesheet wird aus einer in der Schematron Syntax vom Autor verfassten Regelbasis, die wiederum in XML vorliegt, über ein zweites XSLT Stylesheet generiert - Dieses zweite XSLT Stylesheet ist sozusagen das eigentliche Schematron Programm. </p>
                        <p>Das folgende Diagramm veranschaulicht die Vorgehensweise anhand eines Filter-Szenarios, bei dem ein XML Dokument mit einigen ungültigen Passagen in eine gefilterte Darstellung überführt wird.</p>
                        <figure pdfwidth="page">
                           <subtitle>Schematron Validierung mit Filter</subtitle>
                           <desc id="d65d8a95-ace6-4cbd-9511-7c1401841a92d6e25">Einfacher Batch-Prozess zur Validierung mit Schematron und anschliessendem Filtern der Ergebnisse</desc>
                           <img src="./client/data/6fd7b270-9d1f-4f8e-996f-13b5862956a9/schematron.svg"/>
                        </figure>
                        <p>Zu finden ist das <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                       address="https://github.com/Schematron/schematron">Schematron Repo auf Github</url>. Dieses Repo ist etwas unübersichtlich. Der relevante Teil des Sourcecodes befindet sich unter: <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>schematron/code</nb>
                  </code>
               </p>
                     
                  </chapter>
                  <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                     id="2b2ab092-e67f-4ed4-bbed-89270aead234d6e30">
                     
                        <title>
                           <title id="0cc5ca05-4506-44eb-981b-f74a156e6da0d6e20">CLI Verwendung</title>
                        </title>
                        <p>Um die Schematron XSLT Skripte in eine eigene XSLT Anwendung per Kommandozeile einzubinden, könnte man folgendermassen vorgehen: </p>
                        <ul>
                           <li>
                              <p>Im eigenen GIT Projekt das Schematron Projekt als Submodule referenzieren.</p>
                           </li>
                           <li>
                              <p>Eine Regelbasis anlegen, beispielsweise <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                           <nb>$project_name.sch</nb>
                        </code>.</p>
                           </li>
                           <li>
                              <p>Zwei Batch-Skripte anlegen, beispielsweise <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                           <nb>generate_schema.sh</nb>
                        </code> und <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                           <nb>validate.sh</nb>
                        </code>.</p>
                           </li>
                        </ul>
                        <p>Mittels des Skripts <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>generate_schema.sh</nb>
                  </code> wird aus der Schematron Regelbasis das Schematron XSLT Stylesheet generiert. Der Inhalt dieser Batchdatei könnte zum Beispiel so aussehen:</p>
                        <verbatim>saxon <color name="red">$script</color>_dir/<color name="red">$project</color>_name_validation.sch <color name="red">$script</color>_dir/schematron/iso_dsdl_include.xsl
 | \ saxon -s:- <color name="red">$script</color>_dir/schematron/iso_abstract_expand.xsl | \
saxon -s:- <color name="red">$script</color>_dir/schematron/iso_svrl_for_xslt2.xsl \
  <b>generate-fired-rule</b>=false &gt; <color name="red">$script</color>_dir/<color name="red">$project</color>_name_validation.xsl</verbatim>
                        <p>Der Prozess zum Erzeugen des projektspezifischen Validerungs-XSLT-Skripts ist dreistufig und wird über die folgenden XSLT Schritte abgearbeitet.</p>
                        <ul>
                           <li>
                              <p>iso_dsdl_include.xsl</p>
                           </li>
                           <li>
                              <p>iso_abstract_expand.xsl</p>
                           </li>
                           <li>
                              <p>iso_svrl_for_xslt2.xsl</p>
                           </li>
                        </ul>
                        <p>Herauszufinden, was in diesen Skripten passiert, sei dem geneigten Leser selbst überlassen. Uns interessiert an dieser Stelle nur das Resultat, nämlich das XSLT Stylesheet <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>$project_name_validation.xsl</nb>
                  </code>.</p>
                        <p>Dieses Skript wird in der Batchdatei <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>validate.sh</nb>
                  </code> aufgerufen:</p>
                        <verbatim>saxon <color name="red">$xml</color>_instance_to_check.xml <color name="red">$script</color>_dir/<color name="red">$project</color>_name_validation.xsl \
  &gt; <color name="red">$validation-result</color>.xml</verbatim>
                        <p>Die Ausgabe dieses Prüfprozesses ist eine XML Datei mit den Fehlern in der Eingabe-XML-Instanz, die weiterverarbeitet werden kann, beispielsweise als Filterkriterium für einen nachfolgenden Prozessschritt. Ihr Inhalt dieser Datei sieht z.B. wie folgt aus:</p>
                        <verbatim><color name="green">&lt;svrl:schematron-output</color> xmlns:svrl="http://purl.oclc.org/dsdl/svrl" [...]
  &lt;svrl:active-pattern document="file:/Users/alex/xml_instance_to_check.xml" 
   id="default" name="default"<color name="green">/&gt;</color>
  <color name="green">&lt;svrl:failed-assert</color> test="count(key('unique-ids', current()))=1"<color name="green">&gt;</color>
    <color name="green">&lt;svrl:text&gt;</color>ID is not unique!<color name="green">&lt;/svrl:text&gt;</color>
    <color name="green">&lt;svrl:diagnostic-reference</color> diagnostic="default"<color name="green">&gt;</color>
      <color name="green">&lt;bk:id</color> xmlns:bk="http://tekturcms/namespaces/book"<color name="green">&gt;</color>1234-5678-9<color name="green">&lt;/my:id&gt;</color>
    <color name="green">&lt;/svrl:diagnostic-reference&gt;</color>
  <color name="green">&lt;/svrl:failed-assert&gt;</color>
  [...]</verbatim>
                        <p>Neben den <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>svrl:failed-assert</nb>
                  </code> Elementen, die angeben, was bei der überprüften XML-Instanz fehlgeschlagen ist, gibt es auch die Möglichkeit sich positive Ergebnisse anzeigen zu lassen - über das Element <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>svrl:successful-report</nb>
                  </code>.</p>
                        <p>Konkret bedeutet das obige XML Schnipsel, dass unsere <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>id</nb>
                  </code> mit dem Wert <code xmlns:tektur="http://www.stylesheet-entwicklung.de">
                     <nb>1234-5688-9</nb>
                  </code> im geprüften XML Dokument nicht eindeutig ist. Die Schematron Regelbasis, die wir zur Überprüfung angegebenen haben, sieht so aus:</p>
                        <verbatim><color name="green">&lt;schema</color> xmlns:sch="http://purl.oclc.org/dsdl/schematron" [...]
  &lt;xsl:key name="unique-ids" match="bk:id" use="."<color name="green">/&gt;</color>
  &lt;sch:<color name="brown">let </color>name="date-regex" value="'^((19|2[0-9])[0-9]{2})-(0[1-9]|1[012])
                                     -(0[1-9]|[12][0-9]|3[01])$'"/&gt;
  <color name="green">&lt;sch:pattern</color> id="default"<color name="green">&gt;</color>
    <color name="green">&lt;sch:rule</color> context="book"<color name="green">&gt;</color>
      <color name="green">&lt;sch:assert</color> id="check-book-id" role="error" test="count(key('unique-ids', bk:id))=1" 
                  diagnostics="default"<color name="green">&gt;</color>ID is not unique!<color name="green">&lt;/sch:assert&gt;</color>
      <color name="green">&lt;sch:assert</color> id="check-book-published" role="error" 
                  test="matches(bk:published,$date-regex)
    &lt;/sch:rule<color name="green">&gt;</color>
    [...]
  <color name="green">&lt;/sch:pattern&gt;</color>
  <color name="green">&lt;sch:diagnostics&gt;</color>
    <color name="green">&lt;sch:diagnostic</color> id="default"<color name="green">&gt;</color>
      <color name="green">&lt;xsl:element</color> name="bk:id"<color name="green">&gt;</color>
        <color name="green">&lt;xsl:value-of</color> select="bk:id"<color name="green">/&gt;</color>
      <color name="green">&lt;/xsl:element&gt;</color>
    <color name="green">&lt;/sch:diagnostic&gt;</color>
  <color name="green">&lt;/sch:diagnostics&gt;</color></verbatim>
                        <p>Neben der "successful" und "failed" Regeln ist auch die Deklaration von Funktionen und Variablen im Body der Regelbasis erlaubt. Dies ermöglicht komplexe Bedingungen, bespw. durch das Nachschlagen in einer Lookup-Tabelle abzuprüfen. </p>
                     
                  </chapter>
               
            
         </chapter>
         <chapter hyphenation="yes" chapterpage="no" id="cc183707-5352-4c9c-9c31-68047a882d0f"
                  ismodule="no">
            
               <title>
                  <title id="9b1e7086-25cc-4bdf-ba77-6adfb503603b">Erste Schritte mit Xspec</title>
               </title>
               
                  <p>XSpec ist ein <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                    address="https://github.com/xspec">Test-Framework</url> für XSLT, XQuery und Schematron. 
Um beispielsweise komplexe Schematron Regeln zu testen, hinterlegt man in einem <b>Test-Szenario</b> 
Erwartungswerte für positive und negative Testfälle in Form von XML Schnippseln.</p>
                  <verbatim><color name="green">&lt;test-szenario&gt;</color>
  <color name="green">&lt;testfall&gt;</color>
    <color name="green">&lt;personen&gt;</color>
      <color name="green">&lt;person&gt;</color>
        <color name="green">&lt;vorname&gt;</color>Horst<color name="green">&lt;/vorname&gt;</color>
        <color name="green">&lt;nachname&gt;</color>Schlämmer<color name="green">&lt;/nachname&gt;</color>
        <color name="green">&lt;gewicht&gt;</color>100<color name="green">&lt;/gewicht&gt;</color>
      <color name="green">&lt;/person&gt;</color>
      <color name="green">&lt;person&gt;</color>
        <color name="green">&lt;vorname&gt;</color>Gundula<color name="green">&lt;/vorname&gt;</color>
        <color name="green">&lt;nachname&gt;</color><color name="green">&lt;/nachname&gt;</color>
        <color name="green">&lt;gewicht&gt;</color>60<color name="green">&lt;/gewicht&gt;</color>
      <color name="green">&lt;/person&gt;</color>
    <color name="green">&lt;/personen&gt;</color>
  <color name="green">&lt;/testfall&gt;</color>
<color name="green">&lt;/test-szenario&gt;</color></verbatim>
                  <p>in einer XSpec Datei *. werden <b>Assert- und Not-Assert-Methoden</b> deklariert:</p>
                  <verbatim><color name="green">&lt;x:description</color> xslt-version="2.0" xmlns:x="http://www.jenitennison.com/xslt/xspec" 
               schematron="test.sch"<color name="green">&gt;</color>
  <color name="green">&lt;x:scenario</color> label="ALL"<color name="green">&gt;</color>
    <color name="green">&lt;x:context</color> href="test.xml"<color name="green">/&gt;</color>
    <color name="green">&lt;x:expect-not-assert</color> id="person-nachname-rule" location="//person[1]/nachname"<color name="green">/&gt;</color>
    <color name="green">&lt;x:expect-assert</color> id="person-nachname-rule" location="//person[2]/nachname"<color name="green">/&gt;</color>
  <color name="green">&lt;/x:scenario&gt;</color>
<color name="green">&lt;/x:description&gt;</color></verbatim>
                  <p>Grds. bdeutet ein Assert, dass das Mapping zwischen tatsächlichem Wert und Erwartungswert des
Testfalls positiv erfüllt ist. Beim Not-Assert ist das Gegenteil der Fall. Im obigen Beispiel
reichen zwei Regeln, um den Testfall vollständig abzudecken.</p>
                  <p>Wenn man Schematron Regeln mit Hilfe von XSpec testen will, dann muss man ein bisschen um 
die Ecke denken. Denn auch diese Regeln werden mittels Assert und Not-Assert modelliert.</p>
                  <verbatim><color name="green">&lt;sch:schema</color> xmlns:sch="http://purl.oclc.org/dsdl/schematron" 
            xmlns:xsl="http://www.w3.org/1999/XSL/Transform" queryBinding="xslt2"<color name="green">&gt;</color>
  <color name="green">&lt;sch:pattern</color> id="main"<color name="green">&gt;</color>
    <color name="green">&lt;sch:rule</color> context="nachname"<color name="green">&gt;</color>
      <color name="green">&lt;sch:assert</color> id="person-nachname-rule" role="error" test="normalize-space(.)"<color name="green">&gt;</color>
        Der Nachname der Person mit ID: <color name="green">&lt;sch:value-of</color> select="@id"<color name="green">/&gt;</color> fehlt! 
      <color name="green">&lt;/sch:assert&gt;</color>
    <color name="green">&lt;/sch:rule&gt;</color>
  <color name="green">&lt;/sch:pattern&gt;</color>
<color name="green">&lt;/sch:schema&gt;</color></verbatim>
                  <p>In der Schematron-Regel wird zugesichert (Assert), dass jede Person einen Nachnamen hat.</p>
                  <p>Hat sie keinen Nachnamen so wird der Bericht zum Fehlerfall in die Schematron Ergebnisdatei
geschrieben. Diese Datei wertet nun Xspec aus.</p>
                  <note>
                     <consequence>
                        <p>Erscheint ein Fehler (= das Feld <b>nachname</b> ist leer), so greift bei Xspec die Assert-Regel! Das ist die umgekehrte Logik zu den Schematron Regeln.</p>
                     </consequence>
                  </note>
                  <p>Als Eselsbrücke kann man
ein Assert in der Xspec Datei gleichsetzen mit <b>Appear</b> und ein Not-Assert mit
<b>Not-Appear</b>. </p>
                  <p>Ein Assert sichert also zu, dass sich ein Fehlerbericht in der
Schematron Ergebnisdatei zum Testfall befindet. Ein Not-Assert sichert zu, dass
sich kein Fehlerbericht befindet. </p>
                  <p> Wie man sich leicht vorstellen kann, sind Assert-Regeln in diesem Fall leicht zu finden,
dazu muss man nur die Schematron Testregeln ins Leere zeigen lassen. Alles ist grün
und alles ist gut - dem Augenschein nach.</p>
               
            
         </chapter>
      </chapter>
   </chapter>
   <chapter hyphenation="yes" chapterpage="no" id="f606e9c6-3d46-48f3-8de4-46e13dc7d055"
            ismodule="no">
      
         <title>
            <title id="e4c14d2b-d2df-4a76-ac0c-4ecebfe223ae">Zusätzliches Know-How</title>
         </title>
         
            <p>Unsortierte Notizen, die für jeden XSLT-Programmierer interessant sein könnten.</p>
            <p/>
         
      
      <chapter hyphenation="yes" chapterpage="no" id="7dbb15ce-bbc5-4d91-b977-ed7e8117730e"
               ismodule="no">
         
            <title>
               <title id="5d677796-4ebf-49b1-85ba-45315312a0e4">GIT Einmaleins </title>
            </title>
            
               <p>Im Fachbereich Technische Dokumentation wird neue Technologie ein bisschen langsamer adaptiert, als in anderen Disziplinen der IT - schliesslich muss ja erst alles dokumentiert werden ...</p>
               <p>Bei Versionsverwaltungssystemen ist das nicht anders. Doch inzwischen hat auch GIT in manchen Entwicklerbüros Einzug gehalten und verdrängt Subversion.</p>
               <p>Ein Grund an dieser Stelle einmal zumindest die wichtigsten Befehle aufzulisten - Note to self:</p>
               <verbatim>GIT COMMANDS

CLONE
=====
git clone https://github.com/libgit2/libgit2
SIMPLE
======
git init
git add *
git commit -m "Form validation added”
[changes]
git add [changed files] or git commit -a
git diff —cached
git branch experimental
git checkout experimental
git commit -a -m "only<color name="brown"> in </color>the experimental branch”
git checkout master
git merge experimental
git branch -d experimental

COLLABORATION
=============
push new branch git push -u origin newLocalBranch
bob$ git clone /home/alice/project myrepo
(edit files)
bob$ git commit -a
alice$ cd /home/alice/project
alice$ git pull /home/bob/myrepo master  (fetch &amp; merge)
(fetch and not merge)
alice$ git fetch /home/bob/myrepo master
alice$ git log -p HEAD..FETCH_HEAD
(visualization only)
gitk HEAD..FETCH_HEAD
gitk HEAD…FETCH_HEAD
—
git log
git show ea14 (firs chars is enough)
git grep "headline_font_size” v2.5

PULL REQUESTS
=============
(checkout branch)
git pull origin simple-examples
(changes)
git push origin simple-examples
Create a pull request using the form on the Github page and assign it to a Reviewer

MERGE CONFLICTS
===============
git pull origin master
=&gt; merga conflicts

TROUBLE SHOOTING
=================
git reset --hard origin/master
git tree
git status
git checkout 118886ee3f06738b53f089433078d35f4d70a8f9 vendor/error-report.xsl
git log --diff-filter=D --summary</verbatim>
            
         
      </chapter>
      <chapter hyphenation="yes" chapterpage="no" id="4100d43a-5b71-43ba-a05f-1063fcee8679"
               ismodule="no">
         
            <title>
               <title id="46cfa469-01ec-434d-ab13-e24ce0b06467">XML Editoren </title>
            </title>
            
               <p>Der XSLT Styesheet-Entwickler wird sich  gewöhnlich mit Eingabedaten beschäftigen, die entweder automatisch mittels irgendeines Prozesses erzeugt wurden, oder die durch einen menschlichen Autor mit einem XML Editor eingegeben wurden.</p>
               <p>Aus diesem Grund ist es ganz nützlich, die wichtigsten Editoren zu kennen. Wir unterscheiden zwischen Desktopapplikationen und Webanwendungen. Ausserdem unterscheiden wir noch ob der Editor WYSIWIG (<b>W</b>hat <b>Y</b>ou <b>S</b>ee <b>I</b>s <b>W</b>hat <b>Y</b>ou <b>G</b>et) oder WYSIWYM (<b>W</b>hat <b>Y</b>ou <b>S</b>ee <b>I</b>s <b>W</b>hat <b>Y</b>ou <b>M</b>ean)  unterstützt oder eine Mischung aus beidem darstellt.</p>
               <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                  id="45392571-40bf-42cc-91a8-73db7cc25bced6e52">
                  
                     <title>
                        <title id="346853d6-4d45-42f4-a7b8-77af38d96151d6e9">WYSIWYM Desktop</title>
                     </title>
                     <table type="dl">
                        <tgroup>
                           <colspec colwidth="0.25*"/>
                           <colspec colwidth="0.75*"/>
                           <tbody>
                              <row>
                                 <entry>
                                    <b>Editor</b>
                                 </entry>
                                 <entry>
                                    <b>Beschreibung</b>
                                 </entry>
                              </row>
                              <row>
                                 <entry>
                           <url xmlns:tektur="http://www.stylesheet-entwicklung.de" address="https://xmetal.com/">XMetal</url>
                        </entry>
                                 <entry>
                                    <p>XMetal ist wahrscheinlich der am weitesten verbreitete reine WYSIWYM Editor. Er hat Schnittstellen zu COM und Java und kann daher in eigene CMS integriert werden.</p>
                                 </entry>
                              </row>
                              <row>
                                 <entry>
                           <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                                address="https://www.ptc.com/en/products/service-lifecycle-management/arbortext/editor">Arbortext XML Editor</url>
                        </entry>
                                 <entry>
                                    <p>Arbortext XML Editor, früher bekannt als EPIC ist sehr betagt. Ich hatte damit im Bereich Luftfahrt/Verteidigung zu tun. Bekanntermassen ist sein Tabelleneditor etwas buggy.</p>
                                 </entry>
                              </row>
                           </tbody>
                        </tgroup>
                     </table>
                  
               </chapter>
               <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                  id="31915e1f-7aa0-4ad3-b409-699f176fb8b9d6e73">
                  
                     <title>
                        <title id="4c42f7f1-6d2a-482d-8d84-2c500fb35927d6e74">WYSIWYG Desktop</title>
                     </title>
                     <p>XMetal kann so konfiguriert werden, dass bei einer einfachen DTD der Content Bereich wie Word aussieht. Auch Code Editoren, wie OxygenXML bieten diese Möglichkeit. Das Key-Handling bei dieser Variante zeigt aber schnell, dass die UX noch weit von herkömmlichen Textverarbeitungssystem, wie Word oder OpenOffice entfernt ist.  </p>
                  
               </chapter>
               <chapter hyphenation="yes" chapterpage="no" ismodule="yes"
                  id="b919f7f3-3120-40b9-8c25-d2879cf6fa4fd6e78">
                  
                     <title>
                        <title id="092992f0-ac89-4bd8-bba5-a1d685135135d6e79">WYSIWYM Online</title>
                     </title>
                     <table type="dl">
                        <tgroup>
                           <colspec colwidth="0.25*"/>
                           <colspec colwidth="0.75*"/>
                           <tbody>
                              <row>
                                 <entry>
                                    <b>Editor</b>
                                 </entry>
                                 <entry>
                                    <b>Beschreibung</b>
                                 </entry>
                              </row>
                              <row>
                                 <entry>
                           <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                                address="https://www.oxygenxml.com/oxygen-xml-web-author/app/oxygen.html">Oxygen XML WebAuthor</url>
                        </entry>
                                 <entry>
                                    <p>Dieser Online-Editor verwendet auf der Serverseite dieselbe Logik, wie das Desktop Programm des Herstellers. Das führt dazu, dass bei jedem Tastendruck eine Verbindung zum Server aufgebaut wird, und die Verarbeitung langsam werden kann. Zum Betrieb und bzgl. Customizing ist einschlägiges Java-Know-How erforderlich.</p>
                                 </entry>
                              </row>
                              <row>
                                 <entry>
                           <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                                address="https://www.fontoxml.com/">FontoXML</url>
                        </entry>
                                 <entry>
                                    <p>FontoXML sieht schon fast aus wie Word. Neben der WYSWYG/M Darstellung, kann auch die XML Struktur in einem Seitenpanel angezeigt werden.</p>
                                 </entry>
                              </row>
                              <row>
                                 <entry>
                           <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                                address="http://www.xeditor.com/portal">XEditor</url>
                        </entry>
                                 <entry>
                                    <p>Xeditor benutzt XSLT Transformationen, um aus der Eingabe die Editoransicht zu generieren. Beim Abspeichern wird der umgekehrte Weg bestritten. Das mag zwar auf den ersten Blick etwas holprig erscheinen, wie aber auch Tektur beweist, funktioniert das ganze recht gut und schnell.</p>
                                 </entry>
                              </row>
                              <row>
                                 <entry>
                           <url xmlns:tektur="http://www.stylesheet-entwicklung.de"
                                address="http://xopusfiddle.net/VT7T/3/">Xopus</url>
                        </entry>
                                 <entry>
                                    <p>Xopus ist wohl der älteste web-basierte XML Editor. Ich hatte damit schon 2008 zu tun, als er für ein Redaktionssystem evaluiert wurde. Wir haben uns dann für eine eigene nicht-generische Lösung basierend auf dem Webeditor CKEditor entschieden.</p>
                                 </entry>
                              </row>
                           </tbody>
                        </tgroup>
                     </table>
                     <p>Das Customizing dieser Editoren erfordert einen sehr hohen Aufwand. Es müssen diverse Ressourcen angepasst werden, wie XSLT Skripte, XSD Schemas, CSS und Javascript. Das Schema wird meist über Kommandozeilentools in eine JS Repräsentation überführt. </p>
                     <p>Aus diesem Grund bieten einige Hersteller spezielle Schulungen an, wo man die Bedienung erlernen kann. Aus meiner Sicht ist das Problem "Webbasierter XML Editor" weltweit noch nicht ausreichend gelöst.</p>
                     <p>Die Kosten für den Betrieb rangieren um die 1000 EUR monatl. für ein 20 Benutzer-Setup.</p>
                  
               </chapter>
            
         
      </chapter>
   </chapter>
   <chapter hyphenation="yes" chapterpage="no" id="3dfad2c2-2299-461a-9d80-42237bbb5e89"
            ismodule="no">
      
         <title>
            <title id="fab91e1c-40b2-4fa4-8137-87e27882221d">Glossar</title>
         </title>
         
            <block-title xmlns:xs="http://www.w3.org/2001/XMLSchema"
                   xmlns:fo="http://www.w3.org/1999/XSL/Format"
                   xmlns:xe="http://www.xes.future"
                   style="larger">
         <title>
            <b>C</b>
         </title>
      </block-title>
      <column-wide-element xmlns:xs="http://www.w3.org/2001/XMLSchema"
                           xmlns:fo="http://www.w3.org/1999/XSL/Format"
                           xmlns:xe="http://www.xes.future">
         <table type="dl" id="glossary">
            <tgroup>
               <colspec colwidth="2*"/>
               <colspec colwidth="4*"/>
               <tbody>
                  <row>
                     <entry htmlwidth="30%">
                        <b>Core-Stylesheet</b>
                     </entry>
                     <entry htmlwidth="70%">
                           In einem Stylesheet-Projekt bezeichnet das Core-Stylesheet eine bereits ausgiebig getestete Variante, die mittels Sub-Stylesheet unter Ausnutzung der XSLT Import Präzedenz überschrieben wird.
                        </entry>
                  </row>
               </tbody>
            </tgroup>
         </table>
      </column-wide-element>
      <block-title xmlns:xs="http://www.w3.org/2001/XMLSchema"
                   xmlns:fo="http://www.w3.org/1999/XSL/Format"
                   xmlns:xe="http://www.xes.future"
                   style="larger">
         <title>
            <b>D</b>
         </title>
      </block-title>
      <column-wide-element xmlns:xs="http://www.w3.org/2001/XMLSchema"
                           xmlns:fo="http://www.w3.org/1999/XSL/Format"
                           xmlns:xe="http://www.xes.future">
         <table type="dl">
            <tgroup>
               <colspec colwidth="2*"/>
               <colspec colwidth="4*"/>
               <tbody>
                  <row>
                     <entry htmlwidth="30%">
                        <b>DITA</b>
                     </entry>
                     <entry htmlwidth="70%">
                           DITA ist ein Informationsmodell für die Technische Dokumentation.
                        </entry>
                  </row>
               </tbody>
            </tgroup>
         </table>
      </column-wide-element>
      <block-title xmlns:xs="http://www.w3.org/2001/XMLSchema"
                   xmlns:fo="http://www.w3.org/1999/XSL/Format"
                   xmlns:xe="http://www.xes.future"
                   style="larger">
         <title>
            <b>P</b>
         </title>
      </block-title>
      <column-wide-element xmlns:xs="http://www.w3.org/2001/XMLSchema"
                           xmlns:fo="http://www.w3.org/1999/XSL/Format"
                           xmlns:xe="http://www.xes.future">
         <table type="dl">
            <tgroup>
               <colspec colwidth="2*"/>
               <colspec colwidth="4*"/>
               <tbody>
                  <row>
                     <entry htmlwidth="30%">
                        <b>Parameterisierung</b>
                     </entry>
                     <entry htmlwidth="70%">
                           Bei der Parameterisierung wird ein bestehendes Stylesheet mit Parametern versehen, um für möglichst viele Produktvarianten und Ausgabeformate die gleiche Codebasis wiederverwenden zu können. Dadurch soll Redundanz eingespart werden und der Aufruf vereinfacht werden.
                        </entry>
                  </row>
               </tbody>
            </tgroup>
         </table>
      </column-wide-element>
      <block-title xmlns:xs="http://www.w3.org/2001/XMLSchema"
                   xmlns:fo="http://www.w3.org/1999/XSL/Format"
                   xmlns:xe="http://www.xes.future"
                   style="larger">
         <title>
            <b>S</b>
         </title>
      </block-title>
      <column-wide-element xmlns:xs="http://www.w3.org/2001/XMLSchema"
                           xmlns:fo="http://www.w3.org/1999/XSL/Format"
                           xmlns:xe="http://www.xes.future">
         <table type="dl">
            <tgroup>
               <colspec colwidth="2*"/>
               <colspec colwidth="4*"/>
               <tbody>
                  <row>
                     <entry htmlwidth="30%">
                        <b>Sub-Stylesheet</b>
                     </entry>
                     <entry htmlwidth="70%">
                           Ein Sub-Stylesheet spezialisiert das Core-Stylesheet, damit Redundanz vermieden wird und somit die Wartbarkeit gewährleistet werden kann.
                        </entry>
                  </row>
                  <row>
                     <entry htmlwidth="30%">
                        <b>SGML</b>
                     </entry>
                     <entry htmlwidth="70%">
                           SGML ist der Vorläufer von XML.
                        </entry>
                  </row>
                  <row>
                     <entry htmlwidth="30%">
                        <b>Single Source Publishing</b>
                     </entry>
                     <entry htmlwidth="70%">
                           Beim Single Source Publishing wird aus einer XML Quelle eine Vielzahl von Ausgabeformaten erzeugt
                        </entry>
                  </row>
                  <row>
                     <entry htmlwidth="30%">
                        <b>Structured Content Authoring</b>
                     </entry>
                     <entry htmlwidth="70%">
                           Der Content wird hierbei semantisch mittels XML Tags ausgezeichnet. Bei einem WYSIWYG Ansatz sind die meisten Tags nur optional sichtbar.
                        </entry>
                  </row>
               </tbody>
            </tgroup>
         </table>
      </column-wide-element>
      <block-title xmlns:xs="http://www.w3.org/2001/XMLSchema"
                   xmlns:fo="http://www.w3.org/1999/XSL/Format"
                   xmlns:xe="http://www.xes.future"
                   style="larger">
         <title>
            <b>T</b>
         </title>
      </block-title>
      <column-wide-element xmlns:xs="http://www.w3.org/2001/XMLSchema"
                           xmlns:fo="http://www.w3.org/1999/XSL/Format"
                           xmlns:xe="http://www.xes.future">
         <table type="dl">
            <tgroup>
               <colspec colwidth="2*"/>
               <colspec colwidth="4*"/>
               <tbody>
                  <row>
                     <entry htmlwidth="30%">
                        <b>Topic Based Authoring</b>
                     </entry>
                     <entry htmlwidth="70%">
                           Beim Topic Based Authoring steht nicht das gesamte Buch im Vordergrund, sondern der Inhalt wird in wiederverwendbare Topics aufgeteilt, die dann in verschiedenen Publikationen wiederverwendet werden können. 
                        </entry>
                  </row>
                  <row>
                     <entry htmlwidth="30%">
                        <b>TIOBE Index</b>
                     </entry>
                     <entry htmlwidth="70%">
                           Im TIOBE Index wird jährlich die Beliebtheit von Programmiersprachen erfasst.
                        </entry>
                  </row>
               </tbody>
            </tgroup>
         </table>
      </column-wide-element>
      <block-title xmlns:xs="http://www.w3.org/2001/XMLSchema"
                   xmlns:fo="http://www.w3.org/1999/XSL/Format"
                   xmlns:xe="http://www.xes.future"
                   style="larger">
         <title>
            <b>X</b>
         </title>
      </block-title>
      <column-wide-element xmlns:xs="http://www.w3.org/2001/XMLSchema"
                           xmlns:fo="http://www.w3.org/1999/XSL/Format"
                           xmlns:xe="http://www.xes.future">
         <table type="dl">
            <tgroup>
               <colspec colwidth="2*"/>
               <colspec colwidth="4*"/>
               <tbody>
                  <row>
                     <entry htmlwidth="30%">
                        <b>XML Datenbanken</b>
                     </entry>
                     <entry htmlwidth="70%">
                           XML Datenbanken sind NoSQL Datenbanken, d.h. "Not only SQL" oder auch tatsächlich "No SQL" wird unterstützt. Die Spezialisierung erfolgt auf XML Daten. Wie sich aber zeigt, ist eine relationale Sicht auf die Daten meistens auch notwendig, so dass DB wie Marklogic diese Funktionalität mittels Erweiterungen unterstützt. 
                        </entry>
                  </row>
               </tbody>
            </tgroup>
         </table>
      </column-wide-element>
         
      
   </chapter>
   <chapter hyphenation="yes" chapterpage="no" id="dac12b19-ef37-4e41-b88c-6f0ce7becbb8"
            ismodule="no">
      
         <title>
            <title id="3701e56d-cbbf-4125-bce3-cffcd3b10b4f">Tektur CCMS</title>
         </title>
         
            <p>Tekur CCMS ist ein web-basiertes Component Content Management System und befindet sich noch in der Entwicklung. Blog: <b>www.tekturcms.de</b>
            </p>
            <p>Hier sind einige Random Features:</p>
            <ul>
               <li>
                  <p>Die Inhalte werden nach dem DITA Content Model eingegeben. Die Ausgabe erfolgt über ein automatisches Satzsystem.</p>
               </li>
               <li>
                  <p>Grafiken können für die PDF-Ausgabe seitenbreit, spaltenbreit und in der Marginalie gesetzt werden.</p>
               </li>
               <li>
                  <p>Die Breite der Marginalie ist stufenlos einstellbar; die PDF-Ausgabe ist bzgl. der Formatierung weitestgehend konfigurierbar.</p>
               </li>
               <li>
                  <p>Layoutoptionen bzgl. Papierformat, Bemassung und Schriftgrößen können über einen einfachen Dialog eingestellt werden.</p>
               </li>
               <li>
                  <p>TOC und mehrstufige Register werden automatisch in der PDF-Ausgabe erzeugt.</p>
               </li>
               <li>
                  <p>Die Zellenbreite von CALS Tabellen kann mit der Maus eingestellt werden; Funktionen auf Zellen sind weitestgehend implementiert.</p>
               </li>
               <li>
                  <p>Copy 'n Paste funktioniert Element-weise und topic-übergreifend.</p>
               </li>
               <li>
                  <p>Paras, Listitems und Sections können mit den Pfeilbuttons in der Toolbar nach oben und unten verschoben werden.</p>
               </li>
               <li>
                  <p>Verlinkung auf andere Topics funktioniert über Referenzen und ein Linktext wird automatisch aktualisiert, wenn sich der Topic-Titel ändert.</p>
               </li>
               <li>
                  <p>Die DITA-Map kann u.a. mittels Drag 'n Drop editiert werden; Im Topic Editor gibt es an jeder Stelle ein dynamisches Kontextmenü für weitere Optionen.</p>
               </li>
               <li>
                  <p>Valide DITA Strukturen können exportiert und importiert werden.</p>
               </li>
               <li>
                  <p>Topics, Tasks und Maps können vom Autor an Reviewer und Approver für einen Kommentar- und Freigabeprozess überwiesen werden.</p>
               </li>
            </ul>
         
      
   </chapter>
</document>