<?xml version="1.0" encoding="utf-8"?>
<topic id="51a4584a-9a43-4f8f-ad89-d1c2d88ab6e6">
   <title id="9c13d213-40d3-4e74-b343-23cc42779c6d">Funktionen und Module  </title>
   <body id="55287d31-0b28-41fc-a844-f9f51bdf389d">
      <section id="71bbc078-2119-44e1-886e-55a8c1047c12d7e4">
         <title id="2b09a4f1-af09-482e-b220-bbaa5e4f0897d6e5">Funktionen</title>
         <p id="5de561e1-87c3-4f46-b36e-c5db56d9ae27d6e7">Um bestimmte Abschnitte des XQuery Programm wiederverwendbar zu machen, stehen Funktionsdeklarationen[[xe1:Programmierkonstrukte;xe2:Funktionen]] zur Verfügung. Eine einfache Funktion wäre z.B. diese hier:</p>
         <pre id="6b7427f5-b855-4000-85d9-e23cfaa88f51d7e9" xml:space="preserve">declare function local:wrap-header($json) {
  xdmp:add-response-header("Pragma", "no-cache"),
  xdmp:add-response-header("Cache-Control", "no-cache"),
  xdmp:add-response-header("Expires", "0"),
  xdmp:set-response-content-type('text/json; charset=utf-8'),
  $json
};</pre>
         <p id="285caf33-98eb-4945-acad-961bc509ce0cd6e11">Sie wickelt um einen JSON String eine passende Header Information.</p>
         <p id="df24cc6b-17ff-486d-827c-9cec00d4a33bd6e13">Damit die Funktion eingebunden werden kann, muss ein passender Namespace[[xe1:XML Konstrukte;xe2:Namespaces]] deklariert werden:</p>
         <pre id="b6baa2df-1efa-4478-bafc-4ff0921cbeb4d7e15" xml:space="preserve">declare namespace local = 'local:';</pre>
         <p id="bc7c92a6-2eae-47e2-973b-904415f3fc0ed6e17">Nicht nur bzgl. Wiederverwendbarkeit sind Funktionen praktisch, sondern auch
um ganz elementare Konstrukte, wie [[code:while...do]][[xe1:Programmierkonstrukte;xe2:Schleifen - while..do]] Schleifen, zu realisieren.</p>
         <p id="6ec7b350-f2e7-4922-9e96-9c12fd07957ad6e19">Dazu nutzt man, wie in der funktionalen Programmierung üblich, die Rekursion:</p>
         <pre id="58a1bcc8-1931-4cde-be9d-c9aae7c0ad3bd7e21" xml:space="preserve">declare function local:ist-letzter-wert-in-kette($glied) {
  let $wert := local:komplizierte-berechnung($glied),
    $naechstes-glied := local:komplizierte-berechnung-der-position($glied),
  return
    if ($naechstes-glied and not($wert = 'foobar')) then
      local:durchlaufe-kette($naechstes-glied)
    else
      $wert = 'foobar'
};</pre>
         <p id="844b5256-5000-436c-bca3-c8f1c31f3ffed6e23">In diesem kleinen Schnippsel sind schon einige Besonderheiten von 
XQuery zu sehen. Variablenzuweisungen geschehen mit einem Doppelpunkt,
Vergleiche dagegen nur mit einem einfachen "=". Statements werden mit einem
Komma getrennt.</p>
      </section>
      <section id="cd66bef1-da63-47d7-926f-dfe8444da6f7d7e25">
         <title id="4864a9f8-a94d-458d-b063-087f18dcd9d6d7e26">Funktionsaufrufe im XPath</title>
         <p id="fb308435-c134-4665-86f1-1a9cd2db603bd7e28">Wenn eine Funktion auf einer Kontenmenge operiert, dann kann der Funktionsaufruf auch an einen Pfadselektor gehangen werden, bspw. so:</p>
         <pre id="84d6d251-3c9d-403b-ad71-3a5a7a4951a4d7e30" xml:space="preserve">&lt;xsl:value-of select="sum($current/betrag[xs:decimal(.) gt 0]<b id="6e806b18-4de3-49ee-9de0-8a1974f62605d7e34">/xs:decimal(.)</b>)"/&gt;</pre>
         <p id="3505f31d-614f-498c-a004-1991b63878bbd7e32">Hier werden die [[code:betrag]]-Knoten eines zuvor selektierten Teilbaums, der in der Variablen [[code:$current]] abgespeichert ist, aufsummiert - aber nur wenn der Wert größer als 0 ist. </p>
         <p id="7608a002-6b4b-4450-9373-957c49937bf4d7e39">Der Funktionsaufruf ist hier ein Type-Cast auf einen Dezimalwert, um eine gewisse Rechengenauigkeit zu gewährleisten.</p>
         <p id="a8401228-9794-424f-81c6-c4dface74b24d7e34">Die Filterung auf positive Werte ist dabei noch gewöhnlich formuliert:</p>
         <pre id="75d0c96a-73a4-434b-8244-df297f2cf6ccd7e41" xml:space="preserve">[xs:decimal(.) gt 0]</pre>
         <p id="98c3f316-0613-448e-9bce-079c54e269f8d7e38">[[code:xs:decimal]] nimmt den aktuell ausgwählten Knoten und macht einen Dezimalwert daraus, um ihn mit 0 zu vergleichen. </p>
         <p id="c172e71d-7964-45d3-9779-43fa7b7885c9d7e47">Falls hier an den Typkonstruktor [[code:xs:decimal]] ein nicht-unterstütztes Format übergeben wird, bspw. ein String, dann wird ein <b id="1678156d-999f-4ecc-b895-c45613c239e0d7e49"> fatalen Fehler geworfen und das Programm bricht ab</b>.</p>
         <p id="85a7b857-617a-420b-8947-fd10409308dad7e52">Der Funktionsaufruf kann aber auch als Pfadselektion an einem XPath angebracht werden:</p>
         <pre id="8275e896-8be1-4407-b469-55bad241ff53d7e52" xml:space="preserve">/xs:decimal(.)</pre>
         <p id="4b0b3234-3f68-420a-a066-42e04bbaf22ed7e57">Im Fehlerfall wird <b id="9f9d6ea0-5439-4c81-8744-20c7ed92d4b5d7e59" href="undefined">der fehlerhafte Wert nicht summiert und das Programm läuft weiter</b>.</p>
         <pre id="93eb8a8d-7bf2-44ac-819e-7185ba415638d7e60" xml:space="preserve">$current/betrag[xs:decimal(.) gt 0]</pre>
         <p id="7bfc0476-8d90-40bf-a043-413cb3175030d7e68">Auf herkömmlichen Weg würde man eine Schleife verwenden, die alle Werte auf deren Dezimalwert abbildet:</p>
         <pre id="6bb3ebb4-120c-4407-80c1-80431d429a7dd7e64" xml:space="preserve">sum(for $x in $current/betrag[xs:decimal(.) gt 0]
return xs:decimal($x))</pre>
         <p id="30718f69-dae4-43c6-9979-b267dfcc2cadd7e72">Das ist ein bisschen komplizerter, gewährleistet aber eine bessere Robustheit der Programmierung.</p>
         <hazardstatement id="9cbb16ad-d2d9-4d23-9650-8eb745bef942d7e74" type="notice" status="changed">
            <messagepanel id="a3663415-cf20-4ccc-a8c8-ed5f7d83d3bfd7e69">
               <typeofhazard id="483ab37e-ae89-4b50-b2fe-fbb4bb1fb27ed7e76">Funktionsaufrufe als Pfadselektoren brechen bei einem Fehler in der Funktion - ohne explizite Ausnahmebehandlung - <b id="ac9ec453-ed71-437a-883a-bef994a7cb5ad7e72">nicht</b> ab.</typeofhazard>
               <howtoavoid id="85eca9d4-2dd6-4713-a242-c0e484b6b304d7e78">Falls mehr Robustheit gefordert ist, sollte man über Ergbnisknotenmengen iterieren und Funktionsaufrufe auf herkömmlichem Weg absetzen.</howtoavoid>
            </messagepanel>
         </hazardstatement>
         <p id="61f9cde3-decb-4a58-9d41-a4972de19362d7e76">Betrachten wir folgendes XQuery-Schnippsel:</p>
         <pre id="2eb0e023-5624-40fb-a028-abc23e3084b9d7e79" xml:space="preserve">collection("/abrechnung")[vorgangsnummer[.=(3, 8,9,10)]/xdmp:node-collections(.)
                         [starts-with(., '/buchung')]/xdmp:collection-delete(.)</pre>
         <p id="a42517bd-f933-44fd-bb56-8d495570bb2bd7e80">Hier sind alle Abrechnungen in einer Collection [[code:/abrechnung]] gespeichert. Die Abrechungen mit den Vorgangsnummern [[code:3,8,9]] und [[code:10]] sollen
herausgefischt werden. Diese Abrechungen können auch in verschiedenen Collections verwaltet werden, bspw. mittels eines Collection-Typs
"Buchung". Eine Buchung-Collection sammelt alle Abrechungen, die an einem bestimmten Buchungstag getätigt wurden. Wir gehen jetzt davon aus,
dass alle Abrechungen [[code:3,8,9,10]] an einem bestimmten Buchungstag getätigt wurden - und nur diese. Aus irgendeinem Grund wollen wir diese 
Buchung nun löschen. Das macht genau der obige Einzeiler. Der Filter:</p>
         <pre id="75530ed3-b25b-48af-aa5c-7e219f303834d7e83" xml:space="preserve">collection("/abrechnung")[vorgangsnummer[.=(3, 8,9,10)]</pre>
         <p id="cba99f3f-1cbd-48fc-8c8d-b094dc70a75ed7e85">gibt eine Knotenmenge zurück. Das gefilterte Funktionsergebnis</p>
         <pre id="384d1c49-d631-435d-b658-17d0bad31f45d7e88" xml:space="preserve">xdmp:node-collections(.)[starts-with(., '/buchung')]</pre>
         <p id="ed11205c-8ddb-4c5c-bc38-1c68ba2678d4d7e89">ist auch eine Knotenmenge. Normalerweise bräuchten wir also Schleifen, um über diese Mengen zu iterieren. Das würde irgendwie so aussehen</p>
         <pre id="7119a76b-9f50-4e5a-93b3-a614d7b7d1bfd7e92" xml:space="preserve">let 
  $filtered-collection := collection("/abrechnung")[vorgangsnummer[.=(3, 8,9,10)],
  $collections-to-be-deleted :=
  distinct-values(
    for $x in $collection
       return (
         for $y in xdmp:document-get-collections(fn:document-uri($x))[starts-with(., '/buchung')]
           return 
             $y
       )
    )
return (
      for $culprit in $collections-to-be-deleted
        return xdmp:collection-delete($culprit)
    )</pre>
         <p id="1c69ecfc-78f0-4eeb-9998-e1b9cf680975d7e93">Der Quelltext ist zwar so wesentlich länger, aber auch weniger geübte XPath-Experten erkennen leicht, um was es geht.</p>
      </section>
      <section id="d12caa8d-3da0-43b2-8a90-16e26a570bc7d7e96">
         <title id="dab65cd2-0eb9-4487-99e0-07422d3c3759d6e26">Module</title>
         <p id="2cc3effd-16fe-42c0-9fbd-bfa92cb6d10bd6e28">Um eine XQuery Anwendung zu modularisieren[[xe1:Programmierkonstrukte;xe2:Module]], können einzelne Skripte in
Module ausgelagert werden. Ein Modul, z.B. [[code:common.xqy]], wird dabei über einen eigenen
Namespace deklariert:</p>
         <pre id="5254e8f3-5e1d-4029-b069-2b53dde5279cd7e101" xml:space="preserve">module namespace common = "https://www.tekturcms.de/common";</pre>
         <p id="86f1276d-3550-4da6-887d-58012231ea7cd6e32">Dieses Modul kann dann in anderen Skripten eingebunden werden:</p>
         <pre id="0d0be0cb-d589-48e4-8f51-de1e1f02862cd7e105" xml:space="preserve">import module namespace common = "https://www.tekturcms.de/common" at "common.xqy";</pre>
         <p id="d3d6ab20-364a-45c0-b0fa-e2e4578331bcd6e36">Funktionen und Variablen werden dann mir dem Namespace[[xe1:XML Konstrukte;xe2:Namespaces]] geprefixt aufgerufen:</p>
         <pre id="4d9c8677-3eae-4756-85c7-5856d95d9c2ad7e109" xml:space="preserve">Funktionsaufruf: common:wrap-response-header(...)
Variablenauswertung: $common:collection-books</pre>
      </section>
   </body>
</topic>