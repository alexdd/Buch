<?xml version="1.0" encoding="utf-8"?>
<topic id="decb0547-7110-4d26-a8c7-724913382c6e">
   <title id="9a413805-39b0-45df-944d-7d156ea459ad">Schemata </title>
   <body id="69628ba0-19a7-4f10-8bd0-30561fdaba5a">
      <p id="f9eacd03-f2d9-4dbf-9e54-337d5b70ddf7">XML Daten können sehr komplex werden. Da ihre Eingabe oft durch keine User-Interface Massnahmen
oder sonstigte Regelungen beschränkt ist, sie im Prinzip mit jedem Texteditor
verändert werden können und gewöhnlich über viele Stationen verschickt / verarbeitet werden, 
ist es ratsam deren formale und inhaltliche Korrektheit zu überprüfen.</p>
      <p id="56c98fdb-e4e2-4ee9-8d77-42baa22e6a48d7e6">Dazu wird die gute maschinelle Lesbarkeit der XML Daten von Validierungsengines ausgenützt. Es gibt viele unterschiedliche Schematypen, gegen die validiert werden kann. Das sog. <i id="c29da331-d01d-45b5-b278-51c29cca4565d7e8">Schema</i> ist dann ein Satz von Regeln, der beim Baumdurchlauf abgeglichen wird.</p>
      <p id="cdfa9426-f72a-429a-a572-27a81af916fbd7e8">Angefangen hat wohl alles mit der Dokumenttypdefinition ([[link]]DTD[[fn:https://de.wikipedia.org/wiki/Dokumenttypdefinition*Wikipediaseite zum Thema DTD]])[[xe1:Schemata;xe2:DTD]] die sowohl für XML Daten als auch für den Vorläufer SGML angewendet werden kann.</p>
      <p id="107d7535-9e81-4649-ad78-dc7cae6328ded7e10">Die mangelnde Fähigkeit zur Überprüfung von sematischen Beziehungen mittels DTD, 
hat wohl zu [[link]]<undefined id="205398a5-23b1-43a7-b674-3504e86e92f9d7e12" href="undefined"/>XML Schema[[fn:https://de.wikipedia.org/wiki/XML_Schema*Wikipedia Seite zu XML Schema]] geführt.</p>
      <p id="02448417-3d92-46e7-b617-7c804d3f6406d7e14">XML Schema[[xe1:Schemata;xe2:XML Schema]] ist konsequent mittels XML modelliert und hat dieselbe gute Eigenschaft bzgl. der Maschinenlesbarkeit, 
wie XML an sich. Somit können bei einem Baumdurchlauf auch komplexe Regeln beim Abgleich von 
Datenstruktur und Valdierungsregel maschinell überprüft werden.</p>
      <p id="98286f17-bf86-405e-b989-4d2037abd7c7d7e16">Vllt. hat sich aber gerade dieser Vorteil, 
nämlich die Maschinenlesbarkeit, im Laufe der Zeit als Nachteil herauskristallisiert. Es gibt zwar einige 
sehr gute visuelle Modellierungswerkzeuge, die es erlauben die Regeln als einen Baum grafisch
zu modellieren, sobald aber komplexere Beziehungen modelliert werden sollen, ist man mit diesen Tools
ein bisschen gefangen und man wünscht sich doch wieder die Flexibilität eines Texteditors.</p>
      <p id="00a35f70-d1f1-4fab-8214-c946fdda06b1d7e18">Grafische Werkzeuge sind bspw.:</p>
      <ul id="e9361ae7-312e-4ff2-b3fc-32e8cc6f4411d7e20">
         <li id="52afc53c-257d-4493-87df-a1a7e589f5d4d7e21">
            <p id="8641b3fb-5249-48a6-9ebb-8644e5875676d7e22">Ein Tool, das aussieht wie aus einem anderen Jahrhundert: Der [[link]]Near &amp; Far Designer[[fn:http://www.perfectxml.com/SoftDetails.asp?id=216*Letzte Ressource im Web zum Near &amp; Far Designer DTD Modelling Tool]]</p>
         </li>
         <li id="e718713f-4696-4457-b038-03b0af8a10a3d7e24">
            <p id="8a7ff22a-d51e-402b-a43d-e380a37ba88ad7e25">[[link]]<undefined id="98365fc6-3d75-4120-95b1-3a3c9b4817ccd7e27" href="undefined"/>TreeVision[[fn:https://www.gds.eu/de/redaktionssysteme/weitere-loesungen*Webseite zum Tool TreeVision von der Ovidius GmbH]] von der Ovidius GmbH in Berlin.[[xe1:Tools;xe2:TreeVision]]</p>
         </li>
         <li id="7eade155-e8d3-43ee-9491-7d0eb800f031d7e29">
            <p id="a084fe58-b124-4c06-bb68-187ab934a045d7e30">[[link]]Visual Schema Editor[[fn:https://www.oxygenxml.com/xml_editor/rng_visual_schema_editor.html*Grafische Komponente des oXygen XML Editors für Schemas]] als Teil des oXgen XML Editors.[[xe1:Tools;xe2:Visual Schema Editor]]</p>
         </li>
      </ul>
      <p id="5600061d-93fb-4687-b2ec-baaa42419026d7e32">Im Near&amp;Far Designer[[xe1:Tools;xe2:Near&amp;Far Designer]] würde die Visualisierung einer einfachen [[link]]Docbook[[fn:https://docbook.org/*Homepage des Docbook Projekts]]-ähnlichen 
Struktur bspw. so aussehen:</p>
      <fig id="936b6304-49b3-446c-929e-e0b0523a05e4d7e34">
         <title id="985b221a-56bb-4922-82b5-babac20557bed7e38">Abbildung einer DTD Struktur im Near&amp;Far Designer</title>
         <desc id="745738da-ec40-4db6-a80d-d26834ac3e6bd7e40">Eine DTD wird im Near&amp;Far Designer als aufklappbare Baumstruktur angezeigt. So könnnen auch sehr komplexe DTDs mit 1000 Elementen effizient untersucht werden. Über einen Eingabedialog lassen sich Attribute hinzufügen oder ändern. Auch das Neuanlegen von einzelnen Zweigen (= Hinzufügen von Elementen) lässt sich grafisch erledigen. Jedoch ist es ratsam, sich zumindest das Grundgerüst der DTD mit einem Texteditor zu überlegen.</desc>
         <image href="images/near-und-far_10.png"/>
      </fig>
      <p id="6f9e4562-1131-4a3d-890f-d9d7826b7130d7e40">Ähnlich wie in Programmierumgebungen zählt aber schlussendlich, wie schnell man etwas in umfangreichen Quelltexten
wiederfindet und anpassen / erweitern kann. Hier ist nach-wie-vor Plain-Text unschlagbar.</p>
      <p id="fd1db9c5-db6c-4d7d-8ed3-df313f45ec6cd7e43">Deshalb ist es nicht verwunderlich, dass sich (wieder) leichtgewichtige Validierunsformate etablieren, die sich schön mit einem Texteditor editieren lassen, wie z.B. RelaxNG[[xe1:Schemata;xe2:RelaxNG]]. RelaxNG existiert zwar schon seit 2002, erfreut sich aber in letzter Zeit zunehmender Beliebtheit.</p>
      <p id="f04d3262-009a-47e2-b277-672933fb78f1d7e45">Die Kompaktform der Regeln von RelaxNG sieht ein bisschen aus, wie JSON - was gerade für Webentwickler interessant
sein könnte. Zudem wird die zugrunde liegende Logik der [[link]]Backus-Naur Form[[fn:https://de.wikipedia.org/wiki/Backus-Naur-Form*Wikipediaseite zur Backus-Naur Form]]
relativ klar herausgestellt, was die Regelfindung erleichtert.</p>
      <p id="b7212613-cb10-449a-9722-4c2953c3d4e0d7e47">Um einen ersten Eindruck von der Syntax zu bekommen, habe ich mal das erste Beispiel aus dem
[[link]]RelaxNG Tutorial[[fn:https://relaxng.org/tutorial-20011203.html#IDAHDYR*RelaxNG Tutorial]] 
gestolen:</p>
      <p id="55cf9b9b-1394-4725-b1b6-5cfac828bc00d7e49">Consider a simple XML representation of an email address book:</p>
      <pre id="8faaeb4d-63f0-44e1-ab90-8f3cc1639c7bd7e54" xml:space="preserve">&lt;addressBook&gt;
    &lt;card&gt;
        &lt;name&gt;John Smith&lt;/name&gt;
        &lt;email&gt;js@example.com&lt;/email&gt;
    &lt;/card&gt;
    &lt;card&gt;
        &lt;name&gt;Fred Bloggs&lt;/name&gt;
        &lt;email&gt;fb@example.net&lt;/email&gt;
    &lt;/card&gt;
&lt;/addressBook&gt;</pre>
      <p id="300bade8-a203-4e2c-a111-9dee2375e2bbd7e53">The DTD would be as follows:</p>
      <pre id="21cb7f44-1ab0-4f7a-b0c7-b482a19cc83cd7e58" xml:space="preserve">&lt;!DOCTYPE addressBook [
&lt;!ELEMENT addressBook (card*)&gt;
&lt;!ELEMENT card (name, email)&gt;
&lt;!ELEMENT name (#PCDATA)&gt;
&lt;!ELEMENT email (#PCDATA)&gt;
]&gt;</pre>
      <p id="19f8297d-c704-4141-a0dc-9140631aee9bd7e57">A RELAX NG pattern for this could be written as follows:</p>
      <pre id="73103233-319c-4a83-8dc2-a9b12b9a527ad7e62" xml:space="preserve">&lt;element name="addressBook" xmlns="http://relaxng.org/ns/structure/1.0"&gt;
    &lt;zeroOrMore&gt;
        &lt;element name="card"&gt;
            &lt;element name="name"&gt;
                &lt;text/&gt;
            &lt;/element&gt;
            &lt;element name="email"&gt;
                &lt;text/&gt;
            &lt;/element&gt;
        &lt;/element&gt;
    &lt;/zeroOrMore&gt;
&lt;/element&gt;</pre>
      <p id="f1d7e973-e67e-43b4-be51-4442c4a646bdd7e61">In der Kurzform würde dieses Beispiel so aussehen:</p>
      <pre id="a667b2c2-5c86-4d17-9c01-556ef9941726d7e66" xml:space="preserve">element addressBook {
    element card {
        element name { text },
        element email { text }
    }*
}</pre>
      <p id="214be47f-b3ae-42d5-af56-8a126f509de0d7e66">Es gibt auch ein [[link]]Tutorial zur Kurzform[[fn:https://relaxng.org/compact-tutorial-20030326.html*Tutorial zur RelaxNG Kurzform]].</p>
      <note id="ebde2ea0-3f0e-4f6c-af4b-36483c096669d7e71">
         <p id="07907c66-28cb-4ef7-ab0c-5530bf7d7176d7e72">Schemadateien, die in der Kurzform verfasst sind, tragen gewöhnlicherweise die Dateiendung [[code:.rnc]]. Dateien in der Langform haben die Endung [[code:.rng]].</p>
      </note>
      <section id="07480279-b20d-4b21-9d0e-f789225d1a6ad7e74">
         <title id="051f4919-4d45-4676-83cc-cdd093b5dbe8d7e75">Exklusion mit RNC</title>
         <p id="53e811b0-c650-4df8-8fb7-b1e8f679c9a1d7e77">Das schöne an RelaxNG ist die Tatsache, dass man damit Sachen machen kann, die mit
anderen Schemasprachen nicht so leicht gehen. Z.b. kann man ein unvollständiges
Schema erzeugen, das nur ganz bestimmte Teile der XML Instanz prüft.</p>
         <p id="9771995f-802e-4481-b3db-460e332e5a1ed7e79">Betrachten wir dazu das folgendes Beispiel:[[xe1:Konzepte;xe2:Exklusion mit RelaxNG]]</p>
         <pre id="3046418e-5c74-459d-941d-545123a4639bd7e81" xml:space="preserve">unbehandeltesElement =
    element * - (aussteller | 
                 empfaenger |
                 datum) {
        (attribute * { text } | 
         text | 
         unbehandelteElemente)*
    }

start =
    element abrechung {
        element id { xsd:NMTOKEN },
        element datum  { xsd:date },
        [...]
        element zahlungen {
            element zahlung {
                element id { xsd:NMTOKEN },
                element datum  { xsd:date },
                element plan { xsd:NMTOKEN },
                [...]
            },
            element beleg-daten {
                element beleg {
                    attribute nummer { xsd:integer }?,
                    element datum  { xsd:date },
                    unbehandeltesElement+,
                    element aussteller { text },
                    unbehandeltesElement+,
                    element empfaenger { text },
                    unbehandeltesElement+
                }
            }
        }+
    }
}</pre>
         <p id="71de980e-d1ef-43c6-aef2-e75d4c68bd83d7e83">Von den Elementen [[code:abrechnung]] und [[code:zahlung]] wissen wir, wie sie
aufgebaut sind und können sie vollständig modellieren. Die unbekannte
Größe ist allerdings das Element [[code:beleg]]. Dieses stammt von einer externen
Quelle, und wir wissen nur, das darin zwingend die Felder [[code:datum]], [[code:empfaenger]] und [[code:aussteller]] vorhanden sein müssen.</p>
         <p id="549df872-56ee-461b-bf50-82c0d3b23834d7e85">Zwischen diesen Elementen gibt es mindestens ein, aber auch mehrere unbekannte
Elemente. Damit wir nun XML Instanzen, die nach diesem Schema aufgebaut sind,
validieren können, wird ein Element [[code:unbehandeltesElement]] modelliert,
das sozusagen einen Platzhalter darstellt. Dieses schliesst explizit die 
zwingenden Felder [[code:datum]], [[code:empfaenger]] und [[code:aussteller]]
aus, um deren Validierung durch das Schema nicht zu verfälschen.</p>
      </section>
      <section id="554f7c81-ad86-4629-9721-a5454c364522d7e87">
         <title id="e77393e9-e29c-4618-82fb-513e20026d4bd7e69">Angabe des Schemas in der XML Instanz</title>
         <p id="17d20720-8cc6-45be-afcd-6770d3dd1787d7e71">Wie auch schon im Kapitel <xref href="792c9845-7c63-4a18-8aee-1878763200b5"
                  id="6e6e8415-8e29-47dc-be99-b31b5f612aad"
                  type="topic">Anwendungsgebiete </xref> beschrieben, werden alle zusätzlichen - für den XML Prozessor wichtigen - Instruktionen, 
die nicht Teil der Daten sind, über eine Processing Instruction[[xe1:XML Konstrukte;xe2:Processing Instruction]] in das XML eingebunden.</p>
         <p id="2661b349-8143-40f2-92c6-2a0239da3ec3d7e73">Es können mehrere Schemata mittels einer Processing Instruction eingebunden werden, so dass eine Validierung über mehrere Engines möglich ist. 
</p>
         <p id="6b285656-5590-42d0-98ee-1b059f3c477dd7e81">Übernimmt man bspw. einen Legacy Datenbestand, für den nur eine DTD vorhanden ist, so kann im Nachhinhein auch noch
ein XML Schema hinzugefügt werden, welches komplexere semantische Beziehungen überprüft.</p>
         <p id="2bbf59e0-1a80-4f77-9837-93bf12ee2a9ed7e75">Für eine weitere Überprüfung steht schliesslich Schematron, vgl. Kapitel <xref href="6fd7b270-9d1f-4f8e-996f-13b5862956a9"
                  id="4dbcfa84-2e68-4ef4-b7c0-45c13bae6ec8"
                  type="topic">Validierung mit Schematron </xref> zur Verfügung. Ein Beispiel, wie man mehrere Schemas angibt, findet sich auf der [[link]]Seite des W3 Konsortiums zum Thema[[fn:https://www.w3.org/TR/xml-model/*Associating Schemas with XML documents 1.0 (Third Edition)]]</p>
         <pre id="675f0660-6a78-4bff-8c9b-3a38351c1014d7e104" xml:space="preserve">&lt;?xml version="1.0"?&gt;
&lt;?xml-model href="http://www.docbook.org/xml/5.0/rng/docbook.rng"?&gt;
&lt;?xml-model href="http://www.docbook.org/xml/5.0/xsd/docbook.xsd"?&gt;
&lt;book xmlns="http://docbook.org/ns/docbook"&gt;
  [...]
&lt;/book&gt;</pre>
         <p id="4a5ff65f-07eb-4d10-9565-a651b834be62d7e82">Zum Einbinden einer RelaxNG Kompaktform genügt es bspw. diese PI (Processing Instruction) anzugeben</p>
         <pre id="35eda119-4ce9-41d1-8617-5c4fef243cb4d7e108" xml:space="preserve">&lt;?xml-model href="whatever.rnc" type="application/relax-ng-compact-syntax"?&gt;</pre>
         <p id="e712d9cd-18b3-4bae-b103-ab8f631b35b9d7e86">oXygen und auch alle anderen Editoren unterstützen die Angabe des Schemas mittels PI, so dass man auch im Editor auf explizite Anfrage
validieren kann.</p>
      </section>
      <section id="036c8012-7a5f-4db1-8860-38fa7260305cd7e112">
         <title id="75768059-e701-43a1-8690-25dd614d9294d7e89">oXygen Validierung</title>
         <p id="35f4cc9f-fcea-4eb0-b0ab-36ea5e7c4d93d7e91">Die Validierungswerkzeuge finden sich im oXygen Editor unter  [[code:Document]] &gt; [[code:Validate]] &gt; [[code:Validate With]]</p>
         <fig id="2773dabf-d1e0-42ce-87fe-9de28191d336d7e93">
            <title id="5ad9ac21-d08b-4bc5-a19c-376ac1fd90f9d7e118">Validierungsdialog in oXygen</title>
            <desc id="fddba325-7824-4307-ae04-e91c4ed28c3bd7e120">Über das [[code:Document]] Tab findet man in oXygen die Validierungsoptionen.</desc>
            <image href="images/validate-dialog_11.png"/>
         </fig>
         <p id="c7c17029-a53e-4151-86f4-b6f84f04fe17d7e99">Es lassen sich mit oXygen auch Schemas konvertieren, [[code:Document]] &gt; [[code:Schema]] &gt; [[code:Generate/Convert Schema]]</p>
         <fig id="c0d1158e-db16-4dd6-a034-a4d0b20f34acd7e101">
            <title id="4273ed24-37f8-45dc-a7f2-335ac74870e1d7e126">Schema-Konvertierung mit oXygen</title>
            <desc id="1ff62ea2-921e-4de6-b1ae-dfc20852b67ad7e128">Tools zur Konvertierung sind ebenfalls im [[code:Document]] Tab untergebracht</desc>
            <image href="images/covert-schema_12.png"/>
         </fig>
      </section>
      <section id="279f35a2-5bcf-42e7-91fd-afd509c0b5c8d7e131">
         <title id="8df4c58a-1bd5-42f6-8f9c-06cb98ede2d1d7e108">Jing und Trang</title>
         <p id="1ece1cf8-fdec-423f-be6a-ad9f48a0d308d7e110">Für RelaxNG gibt es den [[link]]Jing Validator[[fn:https://relaxng.org/jclark/jing.html*Homepage des Jing RelaxNG Schema Validators]]. Bemerkenswert ist hier, dass das Tool von 
[[link]]James Clark[[fn:http://www.jclark.com/bio.htm*Homepage con James Clark]] entwickelt wird (ein Urgestein in der XML Datenwelt).</p>
         <hazardstatement id="4a30b1ab-e0f8-4988-aea2-01e1fb5076c1d7e112" type="caution" status="changed">
            <messagepanel id="efe3c601-1853-454d-a2e0-41f604ecb378d7e137">
               <typeofhazard id="14672d21-8d90-4bfb-85b0-e23ab4890ea7d7e114">Passt zwar nicht ganz zum Thema: Ein Tool von James Clark[[xe1:XML Gurus;xe2:James Clark]], mit dem ich schon öfters gearbeitet habe, ist [[link]]SP[[fn:http://www.jclark.com/sp/*Homepage zum SP SGML Parser]] ein SGML System[[xe1:Tools;xe2:SP]],
mit dem man SGML nach XML konvertieren kann. Diese Funktionalität ist wohl sonst eher selten zu finden ...</typeofhazard>
               <howtoavoid id="a0db184c-df78-4de3-bf7f-5bb791d3571ad7e116"/>
            </messagepanel>
         </hazardstatement>
         <p id="f07a8cc0-586e-4b6b-b695-ae91d43611b8d7e117">Um eine XML Instanz mit Jing zu validieren genügt folgender Kommandozeilenaufruf:</p>
         <pre id="4a36876c-1357-4672-83ca-ccc397b89f4dd7e143" xml:space="preserve">jing resources/schemas/person.rng resources/examples/person.xml</pre>
         <hazardstatement id="f38263dc-7763-4a20-a820-03a51d021290d7e121" type="danger" status="changed">
            <messagepanel id="66d8e2e5-f8cc-4827-85bb-d67e014268a4d7e146">
               <typeofhazard id="7e6f0c1e-d4d8-479b-ba91-cbc125564795d7e123">Jing unterstützt nicht die RelaxNG Kompaktform!</typeofhazard>
               <howtoavoid id="e7821935-33c5-4f0f-a5fd-519e90872b61d7e125">Die Kompaktform muss zuerst in die Normalform mit [[link]]Trang[[fn:https://relaxng.org/jclark/trang.html*Multi-Schema Konverter Trang]] konvertiert werden.</howtoavoid>
            </messagepanel>
         </hazardstatement>
         <p id="a4efd44d-0987-44eb-8746-a0a0c5a95f32d7e127">Um die Kompaktform von RelaxNG in die Normalform zu konvertieren setzt man diesen Befehl auf der Kommandozeile ab:</p>
         <pre id="c3d7c0a7-b463-4a9e-a327-9e2e60bd4e22d7e153" xml:space="preserve">trang -I rnc -O rng resources/schemas/person.rnc resources/schemas/person.rng</pre>
      </section>
   </body>
</topic>