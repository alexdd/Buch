<?xml version="1.0" encoding="UTF-8"?><topic id="17f5bbad-c12b-4da2-a847-29aba6fa0b48"><title id="c16fd330-a145-443c-bf0a-2ca245527453">Push vs. Pull Stylesheets </title><body id="ffeddc65-c468-48a2-bfd0-b3864c5f06cf"><p id="e2adb8e3-a080-41a2-a76f-c4a29dacd4d2"><b id="a3550616-6596-4f31-8b00-5e7da6099b34d7e5">XSLT</b> ist eine ereignisgesteuerte,[[xe1:Konzepte;xe2:Push vs. Pull]] regelbasierte Umgebung zur Konvertierung von <b id="0d3fd53c-aac8-4548-a505-a1cff67eb4c5d7e8">XML</b> Daten. Gerade der Vorteil des regelbasierten Ansatzes ist vielen Entwicklern nicht bewusst, und es entsteht Quellcode der aussieht, wie mit <b id="1c8c5471-5515-4570-af13-3305846f943bd7e11">XPath</b> angereicherter <b id="5a73706b-7dda-4078-9cdd-cb03caf38e9dd7e14">PHP</b> Code.</p><p id="75d35ff2-13b7-4c17-9aef-8c028ca9a0a7d6e6">Wieso nimmt man dann überhaupt <b id="6ca745fb-fba7-48a8-9864-ddc758770759d7e19">XSLT</b>, wenn man keine Template-Match Regeln verwendet, oder nur spärlich verwendet?</p><p id="adf97e75-c632-445e-aa9f-914096737fdcd6e8">Um diesen Umstand aufzuklären ist ein bisschen Theorie notwendig:</p><fig id="0d502088-17cc-4df6-910c-2f7039fdf1c0d6e10"><title id="319281dd-c456-4de5-8f55-134098679625d7e25">Pull Stylesheet</title><desc id="1567db28-cde4-44df-9d16-57d3d3159f93d7e27">Beim "Pull" werden Elemente in der Quellinstanz selektiert und an einer passenden Stelle in der Zielinstanz eingefügt. Diese Vorgehensweise ist vergleichbar mit derer von Template-Engines, wie <b id="0a86d34e-281d-4bb3-a363-34738d6db0a4d7e29">JSP</b> oder <b id="b291c3a3-16dc-483d-a959-745e574325bcd7e32">ASP</b>. Das kann in mehreren Stufen erfolgen, bis schrittweise die Quellinstanz in die finale Zielinstanz überführt wurde.</desc><image id="4419c8aa-5427-4380-ad94-790018770efdd7e35" href="pull.svg"/></fig><fig id="f5ce4667-1b4c-4f90-8a87-9ee7690f4882d6e16"><title id="9ac138fd-7c8a-4637-adb2-9315b50ff2fbd7e37">Push Stylesheet</title><desc id="3006986c-31c2-4a9a-833e-717482801b71d7e39">Beim "Push" werden die Quelldaten schrittweise in die Zieldaten konvertiert. Diese Vorgehensweise kann explorativ erfolgen und beim Transformieren in einen Zwischenschritt entstehen Erkenntnisse, die bei der Weiterverarbeitung nützlich sind. <b id="34f6af13-abba-4279-8517-0860b03441edd6e21">Merke:</b><b id="8491c62a-25c8-43b3-86ce-c145ea060d3bd7e43">XSLT </b>steht für <b id="f23d31e7-5a2c-49e7-a966-c88d3fbbf640d7e46">eXtensible Stylesheet Transformation</b>.</desc><image id="67dfe68c-35b3-4e71-a2b5-05c78914f17bd7e49" href="pusch.svg"/></fig><p id="43976824-218f-4b76-9c34-24b9e47ccbfcd6e22">Das bisher Gesagte verdeutlicht zwar den "Pull" Ansatz, was genau aber ge"pusht" wird, ist vermutlich noch unklar. Betrachten wir <b id="19136886-135d-4bbc-a56b-a45d994d9bc1d7e52">XML</b> in der Baumdarstellung.</p><fig id="f93dee36-035e-41dc-b3c3-c5ae3ee0a23ed6e36"><title id="63b9a10f-9743-45bf-bbf3-c1f3451be442d7e56">Transformation des Quellbaums in den Zielbaum</title><desc id="a1240377-a9b9-4af5-a6a2-85762a0cd58fd7e58">Der <b id="a66b666c-7b52-4567-b459-5be2b5af5fb3d7e60">XSLT</b> Prozessor unternimmt einen Tiefensuchlauf[[xe1:Tiefensuchlauf]] und überprüft bei jedem Knoten den er betritt, ob in seiner Regelbasis eine Regel existiert, die auf diesen Knoten "matched". Dabei gibt es drei grundsätzliche Möglichkeiten, wie die Knoten des Quellbaums in den Zielbaum kopiert - oder eben nicht kopiert - werden können.</desc><image id="30be30df-9f80-478d-8569-23544b83fdf2d7e63" href="push.svg"/><legend id="c86cd897-414e-4c52-8ee9-d3c002bc862ad6e42"><leg-entry id="f9455559-67ce-4901-9444-ccdd01d21c56d6e43"><leg-pos id="f9dde8a7-4ed4-4b7d-b14b-11c5e5819743d7e66"><p id="84d2229a-ea25-4543-8c97-0ba238add5b8d6e45">Remove</p></leg-pos><leg-name id="0ce5d227-cd38-4bd7-bce9-a433ebacc8c2d7e69"><p id="55bc5ab5-3a61-4a2d-931a-869b2a1271abd6e48">Beim Betreten einer leeren Match-Regel wird ein Teilbaum nicht kopiert</p></leg-name></leg-entry><leg-entry id="4f2540c3-a78f-49dc-a2b3-3e3d5c7d1c16d6e50"><leg-pos id="53d262cf-098f-4039-afc8-0bf183ba31a9d7e73"><p id="1d2fa28e-b42a-4d7e-8251-9021a2d5c910d6e52">Bypass</p></leg-pos><leg-name id="47ed5f03-1755-4536-b975-ed3283d3df31d7e76"><p id="f3efa098-bd76-4f6b-98e9-9407409a1ccfd6e55">Beim Betreten einer Match-Regel ohne Kopieranweisung wird der Knoten übersprungen</p></leg-name></leg-entry><leg-entry id="f38f09a2-6878-42f6-bcfe-621ca2fc7fa5d6e57"><leg-pos id="ebf16092-4ae5-4fe7-82cc-1e896b749e31d7e80"><p id="5642055c-b103-4032-83ea-fbcacc830f0cd6e59">Push</p></leg-pos><leg-name id="afb3e436-0980-4761-8462-0ff6004cf57ad7e83"><p id="6cbf3169-aec8-4162-bcde-7fbc915a27c2d6e62">Durch gezielte Auswahl einer Knotenmenge auf der Descendant-Achse wird der XSLT Prozessor in eine bestimmte Richtung ge"pusht".</p></leg-name></leg-entry></legend></fig><p id="299d3e98-3089-4974-a46a-bf457340a701d6e52">Pull-Stylesheets werden gewöhlich mit <b id="42bd9a63-aa58-4808-8650-2595796cc68cd6e54">for-each</b> Loops programmiert. Dieser Ansatz ist meiner Ansicht nach gebräuchlich, wenn keine großen <b id="ceb946a0-86da-4f10-8883-8c06674fe26dd7e91">DTD</b> Änderungen zu erwarten sind, der <b id="aeaedc34-595b-4a71-8925-faf1d2d6f9c8d7e94">XML</b> Baum flach strukturiert ist und die Anforderungen an die  Knvertierung relativ einfach sind, bspw. beim Auswerten / Konvertieren von Konfigurationsdateien. In alles anderen Fällen sind Push-Stylesheets vorzuziehen, d.h. möglichst wenige <b id="949dd5f4-9e4d-4b66-a9be-4fc920e95a22d6e57">for-each</b> loops und möglichst viele <b id="88b6204b-066e-45fa-8838-73478fb57a03d6e60">Template-Match</b> Regeln.</p></body></topic>