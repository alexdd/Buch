<?xml version="1.0" encoding="UTF-8"?><topic id="51a4584a-9a43-4f8f-ad89-d1c2d88ab6e6"><title id="9c13d213-40d3-4e74-b343-23cc42779c6d">Funktionen und Module  </title><body id="55287d31-0b28-41fc-a844-f9f51bdf389d"><section id="084fffc2-d5c5-495f-a03d-2ac4aa75c67ed7e4"><title id="2b09a4f1-af09-482e-b220-bbaa5e4f0897d6e5">Funktionen</title><p id="5de561e1-87c3-4f46-b36e-c5db56d9ae27d6e7">Um bestimmte Abschnitte des XQuery Programm wiederverwendbar zu machen, stehen Funktionsdeklarationen[[xe1:Programmierkonstrukte;xe2:Funktionen]] zur Verfügung. Eine einfache Funktion wäre z.B. diese hier:</p><pre id="bb749d2c-2245-475d-bd2b-c46c049a8bacd7e9" xml:space="preserve">declare function local:wrap-header($json) {
  xdmp:add-response-header("Pragma", "no-cache"),
  xdmp:add-response-header("Cache-Control", "no-cache"),
  xdmp:add-response-header("Expires", "0"),
  xdmp:set-response-content-type('text/json; charset=utf-8'),
  $json
};</pre><p id="285caf33-98eb-4945-acad-961bc509ce0cd6e11">Sie wickelt um einen JSON String eine passende Header Information.</p><p id="df24cc6b-17ff-486d-827c-9cec00d4a33bd6e13">Damit die Funktion eingebunden werden kann, muss ein passender Namespace[[xe1:XML Konstrukte;xe2:Namespaces]] deklariert werden:</p><pre id="4da3a91a-b976-4c2e-9c17-6fe179206e06d7e15" xml:space="preserve">declare namespace local = 'local:';</pre><p id="bc7c92a6-2eae-47e2-973b-904415f3fc0ed6e17">Nicht nur bzgl. Wiederverwendbarkeit sind Funktionen praktisch, sondern auch
um ganz elementare Konstrukte, wie [[code:while...do]][[xe1:Programmierkonstrukte;xe2:Schleifen - while..do]] Schleifen, zu realisieren.</p><p id="6ec7b350-f2e7-4922-9e96-9c12fd07957ad6e19">Dazu nutzt man, wie in der funktionalen Programmierung üblich, die Rekursion:</p><pre id="5482e3aa-8ec2-4e25-befe-347591d70fd7d7e21" xml:space="preserve">declare function local:ist-letzter-wert-in-kette($glied) {
  let $wert := local:komplizierte-berechnung($glied),
    $naechstes-glied := local:komplizierte-berechnung-der-position($glied),
  return
    if ($naechstes-glied and not($wert = 'foobar')) then
      local:durchlaufe-kette($naechstes-glied)
    else
      $wert = 'foobar'
};</pre><p id="844b5256-5000-436c-bca3-c8f1c31f3ffed6e23">In diesem kleinen Schnippsel sind schon einige Besonderheiten von 
XQuery zu sehen. Variablenzuweisungen geschehen mit einem Doppelpunkt,
Vergleiche dagegen nur mit einem einfachen "=". Statements werden mit einem
Komma getrennt.</p></section><section id="b6444aac-b899-4462-a407-8a2c629bf3f0d7e25"><title id="4864a9f8-a94d-458d-b063-087f18dcd9d6d7e26">Funktionsaufrufe im XPath</title><p id="fb308435-c134-4665-86f1-1a9cd2db603bd7e28">Wenn eine Funktion auf einer Kontenmenge operiert, dann kann der Funktionsaufruf auch an einen Pfadselektor gehangen werden, bspw. so:</p><pre id="8d7cd2cb-5e90-4853-bda3-c1e459a8c2f2d7e30" xml:space="preserve">&lt;xsl:value-of select="sum($current/betrag[xs:decimal(.) gt 0]<b id="6e806b18-4de3-49ee-9de0-8a1974f62605d7e34">/xs:decimal(.)</b>)"/&gt;</pre><p id="3505f31d-614f-498c-a004-1991b63878bbd7e32">Hier werden die [[code:bertrag]]-Knoten eines zuvor selektierten Teilbaums, der in der Variablen [[code:$current]] abgespeichert ist, aufsummiert - aber nur wenn der Wert größer als 0 ist. </p><p id="7608a002-6b4b-4450-9373-957c49937bf4d7e39">Der Funktionsaufruf ist hier ein Type-Cast auf einen Dezimalwert, um eine gewisse Rechengenauigkeit zu gewährleisten.</p><p id="a8401228-9794-424f-81c6-c4dface74b24d7e34">Die Filterung auf positive Werte ist dabei noch gewöhnlich formuliert:</p><pre id="20901491-1b03-4b37-af8e-5c3cd37fe556d7e41" xml:space="preserve">[xs:decimal(.) gt 0]</pre><p id="98c3f316-0613-448e-9bce-079c54e269f8d7e38">[[code:xs:decimal]] nimmt den aktuell ausgwählten Knoten und macht einen Dezimalwert daraus, um ihn mit 0 zu vergleichen. </p><p id="c172e71d-7964-45d3-9779-43fa7b7885c9d7e47">Falls hier an den Typkonstruktor [[code:xs:decimal]] ein nicht-unterstütztes Format übergeben wird, bspw. ein String, dann wird ein <b id="1678156d-999f-4ecc-b895-c45613c239e0d7e49"> fatalen Fehler geworfen und das Programm bricht ab</b>.</p><p id="85a7b857-617a-420b-8947-fd10409308dad7e52">Der Funktionsaufruf kann aber auch als Pfadselektion an einem XPath angebracht werden:</p><hazardstatement id="a9786601-2a42-4bb1-b54d-ab60df652299d7e52" type="notice" status="changed"><messagepanel id="7e10d812-3a6b-4946-ac9d-0d03ac08e2fbd7e53"><typeofhazard id="281135b2-0d50-47c5-870d-52b42a3eb2b4d7e54">swqws hi rob!</typeofhazard><howtoavoid id="d07f8299-05a8-43e1-ae68-e8c7f1fb8d23d7e56">bla bla</howtoavoid></messagepanel></hazardstatement><pre id="a0d817fc-399a-4a18-b8e0-3087243d79d1d7e59" xml:space="preserve">/xs:decimal(.)</pre><p id="4b0b3234-3f68-420a-a066-42e04bbaf22ed7e57">Im Fehlerfall wird <b id="9f9d6ea0-5439-4c81-8744-20c7ed92d4b5d7e59" href="undefined">der fehlerhafte Wert nicht summiert und das Programm läuft weiter</b>.</p><pre id="7732897c-fae7-4236-8706-e1d930e4c4b6d7e66" xml:space="preserve">$current/betrag[xs:decimal(.) gt 0]</pre><p id="7bfc0476-8d90-40bf-a043-413cb3175030d7e68">Auf herkömmlichen Weg würde man eine Schleife verwenden, die alle Werte auf deren Dezimalwert abbildet:</p><pre id="e3a08ef7-a6af-41f0-a409-9776e8956d7dd7e70" xml:space="preserve">sum(for $x in $current/betrag[xs:decimal(.) gt 0]
return xs:decimal($x))</pre><p id="30718f69-dae4-43c6-9979-b267dfcc2cadd7e72">Das ist ein bisschen komplizerter, gewährleistet aber eine bessere Robustheit der Programmierung.</p><hazardstatement id="9cbb16ad-d2d9-4d23-9650-8eb745bef942d7e74" type="notice" status="changed"><messagepanel id="7f00d3be-a1d9-47f7-a243-55ab1e045d99d7e75"><typeofhazard id="483ab37e-ae89-4b50-b2fe-fbb4bb1fb27ed7e76">Funktionsaufrufe als Pfadselektoren brechen bei einem Fehler in der Funktion - ohne explizite Ausnahmebehandlung - <b id="ac9ec453-ed71-437a-883a-bef994a7cb5ad7e72">nicht</b> ab.</typeofhazard><howtoavoid id="85eca9d4-2dd6-4713-a242-c0e484b6b304d7e78">Falls mehr Robustheit gefordert ist, sollte man über Ergbnisknotenmengen iterieren und Funktionsaufrufe auf herkömmlichem Weg absetzen.</howtoavoid></messagepanel></hazardstatement><p id="61f9cde3-decb-4a58-9d41-a4972de19362d7e76">Betrachten wir folgendes XQuery-Schnippsel:</p><pre id="48d74e19-c51e-4521-844f-8fd5a3f157ded7e85" xml:space="preserve">collection("/abrechnung")[vorgangsnummer[.=(3, 8,9,10)]/xdmp:node-collections(.)
                         [starts-with(., '/buchung')]/xdmp:collection-delete(.)</pre><p id="a42517bd-f933-44fd-bb56-8d495570bb2bd7e80">Hier sind alle Abrechnungen in einer Collection [[code:/abrechnung]] gespeichert. Die Abrechungen mit den Vorgangsnummern [[code:3,8,9]] und [[code:10]] sollen
herausgefischt werden. Diese Abrechungen können auch in verschiedenen Collections verwaltet werden, bspw. mittels eines Collection-Typs
"Buchung". Eine Buchung-Collection sammelt alle Abrechungen, die an einem bestimmten Buchungstag getätigt wurden. Wir gehen jetzt davon aus,
dass alle Abrechungen [[code:3,8,9,10]] an einem bestimmten Buchungstag getätigt wurden - und nur diese. Aus irgendeinem Grund wollen wir diese 
Buchung nun löschen. Das macht genau der obige Einzeiler. Der Filter:</p><pre id="e215b976-3d22-4c8e-bc33-2b9384e525a6d7e89" xml:space="preserve">collection("/abrechnung")[vorgangsnummer[.=(3, 8,9,10)]</pre><p id="cba99f3f-1cbd-48fc-8c8d-b094dc70a75ed7e85">gibt eine Knotenmenge zurück. Das gefilterte Funktionsergebnis</p><pre id="34ecd29e-cfdf-4df2-bf74-08f58a11487ad7e94" xml:space="preserve">xdmp:node-collections(.)[starts-with(., '/buchung')]</pre><p id="ed11205c-8ddb-4c5c-bc38-1c68ba2678d4d7e89">ist auch eine Knotenmenge. Normalerweise bräuchten wir also Schleifen, um über diese Mengen zu iterieren. Das würde irgendwie so aussehen</p><pre id="de23b3da-2ca1-4cf2-b895-a6c1e1f9b09fd7e98" xml:space="preserve">let 
  $filtered-collection := collection("/abrechnung")[vorgangsnummer[.=(3, 8,9,10)],
  $collections-to-be-deleted :=
  distinct-values(
    for $x in $collection
       return (
         for $y in xdmp:document-get-collections(fn:document-uri($x))[starts-with(., '/buchung')]
           return 
             $y
       )
    )
return (
      for $culprit in $collections-to-be-deleted
        return xdmp:collection-delete($culprit)
    )</pre><p id="1c69ecfc-78f0-4eeb-9998-e1b9cf680975d7e93">Der Quelltext ist zwar so wesentlich länger, aber auch weniger geübte XPath-Experten erkennen leicht, um was es geht.</p></section><section id="b981a32a-5abb-4a29-9be8-02950d5414b2d7e102"><title id="dab65cd2-0eb9-4487-99e0-07422d3c3759d6e26">Module</title><p id="2cc3effd-16fe-42c0-9fbd-bfa92cb6d10bd6e28">Um eine XQuery Anwendung zu modularisieren[[xe1:Programmierkonstrukte;xe2:Module]], können einzelne Skripte in
Module ausgelagert werden. Ein Modul, z.B. [[code:common.xqy]], wird dabei über einen eigenen
Namespace deklariert:</p><pre id="fafe89c0-61f3-4187-9910-dd21f09f14b9d7e107" xml:space="preserve">module namespace common = "https://www.tekturcms.de/common";</pre><p id="86f1276d-3550-4da6-887d-58012231ea7cd6e32">Dieses Modul kann dann in anderen Skripten eingebunden werden:</p><pre id="67d350c9-1716-4756-b46d-4816f1777581d7e111" xml:space="preserve">import module namespace common = "https://www.tekturcms.de/common" at "common.xqy";</pre><p id="d3d6ab20-364a-45c0-b0fa-e2e4578331bcd6e36">Funktionen und Variablen werden dann mir dem Namespace[[xe1:XML Konstrukte;xe2:Namespaces]] geprefixt aufgerufen:</p><pre id="e61ee9d8-7a88-4e02-b34c-1c5f20f8b178d7e115" xml:space="preserve">Funktionsaufruf: common:wrap-response-header(...)
Variablenauswertung: $common:collection-books</pre></section></body></topic>