<?xml version="1.0" encoding="UTF-8"?><topic id="151ff813-79c6-45da-8a7c-b4270a0db0de"><title id="056fbbaa-9560-4b9b-bcfd-3a33cb7ec819">Webapps mit MarkLogic</title><body id="6034ed85-b291-4f7d-bd26-4ab712d1c14d"><p id="537345c2-d9dc-4397-86d7-ad84f862ab16d7e4">[[xe1:MarkLogic Konfiguration per cURL]] </p><section id="77def12c-7f2b-4b5f-a0d2-bbdf1266ee76d7e6"><title id="8b655804-9b09-4142-856b-aa841c3c158bd7e5">Konfiguration mit cURL</title><p id="98c12714-a8f6-423a-8090-c5625e3f0a5ed7e7">cURL[[fn:https://de.wikipedia.org/wiki/CURL*Wikipedia-Seite zu Curl URL Request Library - cURL]] ist ein gebräuchliches 
Kommandozeilentool[[xe1:Tools;xe2:cURL]], mit dem man Web-Requests an einen Server schicken kann.</p><note id="44b8d721-cff1-4421-97a1-df0183c83a3ad7e11"><p id="bbe51277-3a22-4dab-a4d4-f2ccd8e63c23d7e10">Die Beispiel-Queries auf diesen Seiten wurden größtenteils von den MarkLogic Doku-Seiten übernommen, sind jedoch
für Windows Rechner angepasst. Statt Shell Skripten und diversen Besonderheiten, kann man die Code-Schnippsel
auch in Batch-Dateien packen und ausführen.</p></note><p id="b43369fb-2207-4fe7-a228-8c03fcb00de5d7e12">MarkLogic horcht auf Port [[code:8002]]  mit seiner Configuration Manager Applikation. Über diesen Port können auch cURL Requests
zur Remote-Konfiguration abgesetzt werden.</p><p id="5bd894cb-c5e4-4eed-8aea-4602eb11bdb2d7e14">Zum Anlegen einer Datenbank setzt man den folgenden cURL Befehl ab:</p><pre id="da91adf1-1dd0-4fcf-8430-10aa47aa640cd7e18" xml:space="preserve">curl -X POST  --anyauth -u admin:admin --header "Content-Type:application/json" 
              -d '{\"database-name\":\"xml-scrapper-content\"}' 
              http://localhost:8002/manage/v2/databases</pre><hazardstatement id="5d6a6c0e-8149-4bec-bbd8-5f390b8b7b28d7e18" type="caution" status="changed"><messagepanel id="a8ea816d-3960-48cc-9708-5c3750fb0ba9d7e21"><typeofhazard id="bad7f46c-daf7-4d9e-a0e5-0b1afb6ce976d7e20">Auf meiner Windows Maschine konnte ich den Befehl, wie in der MarkLogic Doku[[fn:https://docs.marklogic.com/REST/POST/manage/v2/databases*Doku-Seite zum Anlegen einer MarkLogic Datenbank mit cURL]] 
beschrieben, nicht ausführen, da ers das JSON mittels Backslashes maskiert werden musste. Ausserdem ist in der Powershell der [[code:curl]] Befehl per alias
auf ein Windows Programm gemappt[[fn:https://daniel.haxx.se/blog/2016/08/19/removing-the-powershell-curl-alias/*Anleitung zur Entfernung des curl Alias auf Windows]]</typeofhazard><howtoavoid id="54be3542-1379-4ffc-a56b-30cb1b99ba0dd7e22">Maskieren des JSON Strings und Entfernen des cURL Aliases auf Windows.</howtoavoid></messagepanel></hazardstatement><p id="b0575087-0411-413d-adf6-da48b30e5149d7e24">Analog legt man einen "Forrest" an, den die oben definierte Datenbank braucht:</p><pre id="40d67d79-0e58-4602-9499-1e5b3dea6546d7e28" xml:space="preserve">curl --anyauth --user alex:anoma66 -X POST -d '{\"forest-name\": \"xml-scrapper-forrest\", 
                                                \"database\": \"xml-scrapper-content\"}' 
               -i -H "Content-type: application/json" http://localhost:8002/manage/v2/forests</pre><p id="eff10af9-427d-4a06-be13-9cc6415e98b1d7e28">Die Konsole quittiert das erfolgreiche Ereigis mit diesen Meldungen:</p><pre id="eaf9cdcb-a112-499d-87f8-8869fce61700d7e32" xml:space="preserve">HTTP/1.1 201 Created
Location: /manage/v2/forests/12099403305847426321
Content-type: application/xml; charset=UTF-8
Cache-Control: no-cache
Expires: -1
Server: MarkLogic
Content-Length: 0
Connection: Keep-Alive
Keep-Alive: timeout=5</pre><p id="95acde5f-25b2-4409-94ce-a7fbb1f5457bd7e33">Die Erfolgsmeldung kann man auch leicht in der Übersicht des Configuration Managers auf Port 8003 nachprüfen. 
Nun können wir die neue Datenbank mit der MarkLogic Content Pumpo befüllen.</p><p id="fd55bce8-e177-44b1-b581-bb574c20d11cd7e35">Dazu laden wir das kleine Beispiel aus Kapitel hier, das sich in einem Ordner [[code:input-files]] befindet, in die Datenbank:</p><pre id="d7422fc1-48d4-40a8-9886-2d101804983bd7e39" xml:space="preserve">&lt;test&gt;
    &lt;title&gt;Test Datei&lt;/title&gt;
    &lt;chapter&gt;
        &lt;title&gt;Test Kapitel 1&lt;/title&gt;
        &lt;content&gt;Kapitel Inhalt 1&lt;/content&gt;
    &lt;/chapter&gt;
    &lt;chapter&gt;
        &lt;title&gt;Test Kapitel 2&lt;/title&gt;
        &lt;content&gt;Kapitel Inhalt 2&lt;/content&gt;
    &lt;/chapter&gt;
    &lt;chapter&gt;
        &lt;title&gt;Test Kapitel 2&lt;/title&gt;
        &lt;content&gt;Kapitel Inhalt 2&lt;/content&gt;
    &lt;/chapter&gt;
&lt;/test&gt;</pre><note id="6d1f6a29-99f8-453f-aff1-84ed75687d03d7e41"><p id="9776c424-bed2-4b7a-b457-f550779b6f20d7e40">Den Tippfehler im obigen XML werden wir im folgenden Kapitel korrigieren.</p></note><p id="75aa2f46-2a2b-43f4-8299-8dce89b2c5ced7e42">Das geschieht mit dem Befehl:</p><pre id="b3467f6b-7804-450c-99ed-1ec6bdba1635d7e46" xml:space="preserve">mlcp import -database xml-scrapper -host localhost -username admin -password admin 
            -input_file_path input-files -input_file_type aggregates 
            -aggregate_record_element chapter 
            -output_collections /chapter 
            -output_uri_prefix /chapter/ 
            -output_uri_suffix .xml</pre><p id="c5ab4c0e-2a57-4ff5-b44c-df1d8f2a38d1d7e46">Nun brauchne wir nun noch einen Application Server in MarkLogic anlegen um eigene XQuery Skripte laufen lassen zu können.
In einer Datei [[code:server-setup.json]] definieren wir unsere Server Einstellungen:</p><pre id="f4c8940e-924b-4e67-87e2-f6154dbee89ad7e50" xml:space="preserve">{ "server-name":"xml-scrapper",
  "root":"c:\\xquery",
  "port":"8088",
  "content-database":"xml-scrapper-content",
  "server-type":"http",
  "group-name":"Default"
}</pre><p id="a1d2fc71-7fa8-4345-8752-23a9fff03373d7e50">Diese schicken wir mit dem folgenden cURL Befehl an den Server:</p><pre id="38c66c7e-085f-45ed-80b9-e72f56297cb5d7e54" xml:space="preserve">curl -X POST --digest -u alex:anoma66 -H "Content-type: application/json" 
     -d @server-setup.json http://localhost:8002/manage/v2/servers</pre><p id="0541c331-0242-4746-8020-557ebfb3c13bd7e54">Im Web-Interface können wir uns überzeugen, dass alles geklappt hat:</p><fig id="a27fb114-402d-4a01-8265-10f0fbc28a55d7e57"><title id="a8220d99-1629-4be9-8d9a-bcabe801fdcfd7e60">Konfiguration eine App Servers auf MarkLogic</title><desc id="83bc0741-1236-4943-9d75-375b7e50ea01d7e62">Im Reiter [[code:Configure]] können wir den App Server auf MarkLogic konfigurieren.</desc><image id="2fbd62c2-59ac-4dfd-872a-ec36c96b3bddd7e64" href="create-app-server-1.png"/></fig><p id="d883ae4c-cdcc-4cf5-b28b-893080f87cb5d7e63">Die Konfiguration kann natürlich auch mittels des Webinterfaces auf Port 8001 gemacht werden, oder aber auch per
XQuery Skripte über die Konsole auf Port 8000. Einige Skripte für diesen Zweck befinden sich auf den 
Developer Seiten von MarkLogic[[fn:https://docs.marklogic.com/guide/admin-api/configure*XQuery Skripte zur Konfiguration von MarkLogic]]</p><p id="4d8ef625-fbac-487d-ad85-6754915bd050d7e65">Nach diesen Vorbereitungen können wir unseren App-Server nun mit Skripten bestücken, wie
im folgenden Kapitel hier beschrieben. Wir legen die Skripte in das Wurzelverzeichnis [[code:c:\xquery]],
das wir oben definiert haben und können diese über einen Webrequest aufrufen, z.B. so:</p><pre id="15da53fa-ba60-447a-80bf-3f4a39eda16cd7e69" xml:space="preserve">http://localhost:8088/test.xqy</pre></section><section id="b0d31388-a984-4e79-aef0-47298fbd60cdd7e71"><title id="7506d17e-f9c4-4bb8-9a20-451d4a5edc82d7e70">Implementierung als XQuery Skript</title><p id="2d1dd02f-2c43-4799-b8b2-9b7e46235bb3d7e72">In diesem Kapitel werden wir eine HTML Seite mit Inhaltsverzeichnis aus den
im vorherigen Kapitel geladenen Daten generieren.</p><p id="dcad5785-227f-454b-addb-29707486c73bd7e74">Beginnen wir mit einem Skript [[code:book.xqy]] im Verzeichnis [[code:C:\xml-scrapper]]</p><pre id="e3d83f5f-35e8-4af4-bc41-c1817000f6d0d7e78" xml:space="preserve">xquery version "1.0-ml";

xdmp:set-response-content-type("text/html"),
let $pages :=
&lt;html&gt;
    &lt;body&gt;
        {
            for $chapter in collection("/chapter")/descendant::chapter
                return (
                    &lt;h3&gt;{ $chapter/title/text() }&lt;/h3&gt;,
                    &lt;p&gt;{ $chapter/content/text() }&lt;/p&gt; 
                )
        }
    &lt;/body&gt;
&lt;/html&gt;
return $pages</pre><p id="8c014f47-48d3-47c8-8c3e-e2cf37b9f103d7e78">Als Ergebnis erhalten wir:</p><fig id="ce051091-c427-4bac-82b4-c475241f8503d7e80" expanse="column" frame="all" scale="50" status="changed"><title id="56f76ac5-e0b6-4778-9261-0373d6e5d3a3d7e83">Erste Ausgabe unseres kleinen XQuery Skripts für eine Website</title><desc id="f4dc46e9-ef58-4346-992b-1a8c0f27d661d7e85">Die Kapitel der Webseite werden hintereinander weggeschrieben. Das ist natürlich noch nicht optimal</desc><image id="47fa3fdc-809b-42c5-9114-1e26ddf2312fd7e87" href="book.png"/></fig><hazardstatement id="40182548-0388-4b49-8a46-0852fb1a3177d7e86" type="caution" status="changed"><messagepanel id="030da4c6-c9bb-44d1-9706-b1296a68091ed7e89"><typeofhazard id="56a8df95-ec54-409e-960e-75561e30c1bed7e88">Hier fällt auf, dass wir 2x ein Kapitel 2 eingebunden haben. Im einem Fall handelt es sich um einen Tippfehler,
vgl. XML in der Testdatei oben. Im anderen Fall ist nicht gewährleistet, dass die Kapitel in der Reihefolge, in der
sie im XML Baum auftreten auch nach MarkLogic importiert werden bzw. in einer Collection abgespeichert werden.</typeofhazard><howtoavoid id="85029caf-172f-479d-b39b-dab5c62c0185d7e90">Wir kümmern uns um diesen Fehler später.</howtoavoid></messagepanel></hazardstatement><p id="5afe0ab2-398c-4397-a0d3-7ae7e00e9d07d7e92">Nun wollen wir die einzelnen Seiten auf verschiedene Webseiten aufsplitten und auf einer Cover-Page ein Inhaltsverzeichnis
darstellen.</p><pre id="4bf11e81-5ead-4b8c-b018-8d90c1b3c96bd7e96" xml:space="preserve">xquery version "1.0-ml";

declare variable $page:= xdmp:get-request-field('page');

xdmp:set-response-content-type("text/html"),
let $page-id := if ($page) then $page else ('cover'),
$pages :=
&lt;html&gt;
    &lt;body&gt;
        {
            &lt;h3&gt;Welcome to The Book&lt;/h3&gt;,
            for $chapter at $position in collection("/chapter")/descendant::chapter
                return (
                    if ($page-id = 'cover') then (
                        &lt;p&gt;&lt;a href="?page={$position}"&gt;{ $chapter/title/text() }&lt;/a&gt;&lt;/p&gt;
                    ) else (
                        (: TODO :)
                    )
                )
        }
    &lt;/body&gt;
&lt;/html&gt;
return $pages</pre><p id="312c4ed7-6b20-4a7d-b625-51c1c996c0a3d7e96">Im Vergleich zu einer XSLT Lösung stellt man fest, dass man vergeblich versucht die XPath Funktion
[[code:fn:position()]] anzuwenden. Stattdessen verwendet man das Schlüsselwort [[code:at]] in der [[code:for}} Loop.</p><p id="d3620702-ee81-44bf-8954-9117732565cbd7e98">Auf der initialen Cover-Seite wird nun ein verlinktes Inhaltsverzeichnis angezeigt:</p><fig id="1745142d-7469-48f6-9607-d78ecd0ebef3d7e101" expanse="column" frame="all" scale="50" status="changed"><title id="1a62e72d-bbf3-4d6d-8787-36c6177d21add7e104">Zweite Ausgabe unseres kleinen XQuery Skripts für eine Website</title><desc id="badb483c-c09f-46e8-b3c6-95873360146bd7e106">Der zweite Schritt unserer Webapplikation ist ein Inhaltsverzeichnis mit verlinkten Kapiteln</desc><image id="0a10519f-1114-48a1-b852-4997a11107ded7e108" href="toc.png"/></fig><p id="29837759-ad68-46ad-aa90-25af3685081ed7e107">Der im Skript deklarierte Request-Parameter [[code:$page]] wird nun ausgewertet, um die Kapitelseiten zu erzeugen.</p><pre id="8e81c2a1-f4af-469e-8d7c-5d5b87e8e337d7e111" xml:space="preserve">xquery version "1.0-ml";

declare variable $page:= xdmp:get-request-field('page');

xdmp:set-response-content-type("text/html"),
let $page-id := xs:decimal(if ($page) then $page else '0'),
$pages := collection("/chapter"),
$website :=
&lt;html&gt;
    &lt;body&gt;
        {
            &lt;h3&gt;Welcome to The Book&lt;/h3&gt;,
            for $chapter at $position in $pages/descendant::chapter
                return (
                    if ($page-id lt 1 or  $page-id gt count($pages)) then (
                        &lt;p&gt;&lt;a href="?page={$position}"&gt;{ $chapter/title/text() }&lt;/a&gt;&lt;/p&gt;
                    ) else  if ($page-id = $position) then (
                        &lt;h2&gt;{ $chapter/title/text() }&lt;/h2&gt;,
                        &lt;p&gt;{ $chapter/content/text() }&lt;/p&gt;,
                        &lt;p&gt;&lt;a href="{ xdmp:get-request-path() }"&gt;Back To Cover&lt;/a&gt;&lt;/p&gt;
                    ) else ()
                )
         }
    &lt;/body&gt;
&lt;/html&gt;
return $website</pre><p id="043dd0e6-a11c-4d60-b693-5abe235626cbd7e111">Hier ist das [[code:at]] Schlüsselwort interessant mit dem man die Position in der Schleife abgreifen kann.
[[code:fn:position()]] wie bei XSLT gebräuchlich würde hier nicht funtktionieren. Dass wir bedingte
Anweisungen in funktionalen Sprachen als Ausdruck auswerten können, haben wir in hier schon gelernt,
vgl. die [[code:sx:decimal]] Cast Anweisung zur Typ-Konvertierung.</p><p id="56f7156b-b880-41ef-bbd8-59e7979a856fd7e113">Unsere Website wäre eigentlich schon perfekt, wenn da der fehlerhafte Datenimport nicht wäre, und wir das Kapitel 2 nicht
doppelt importiert hätten. Um die Daten zu bereinigen ist eine Daten-Migration notwendig.</p></section><section id="7160729f-23a6-43dd-a615-46c198383701d7e117"><title id="564c57b0-2bb2-4d97-abe6-92266bf56a8ed7e116">Datenkorrektur mit der Konsole</title><p id="0165be87-2ac9-4ee8-a576-55623c8cfcabd7e117">Um die fehlerhaften Daten aus dem vorherigen Kapitel zu korrigieren, öffnen wir eine Konsolensitzung auf Port [[code:8000]]:</p><note id="b619ce4f-5bd4-4bf5-8317-a735c2327fd9d7e122"><p id="44542243-50f1-4e89-a600-9a529810d1f3d7e126">Wir bemerken in der folgenden Abbildung, dass das [[code:mlcp]] Kommando den [[code:document-name]] mit dem absoluten Pfad der Datei im 
Dateisystem des importierenden Rechners geprefixt hat.</p></note><fig id="f35eb81e-b0d5-42da-8e36-2ef4476ebd61d7e119"><title id="c2a9c31f-c1ac-4022-b9e1-431bd1be473ed7e126">MarkLogic Konsolensitzung mit einer Collection Iteration</title><desc id="3155d3bb-61d1-4de6-9805-e89061ee279dd7e128">Auf der Konsole können wir uns die in der Collection abgespeicherten Dokumente auflisten lassen.</desc><image id="48f763d2-abe8-43f6-9d2d-d36c8c2e2c61d7e130" href="console.png"/></fig><p id="1348d857-8a86-4a82-ae03-b917901dcfcad7e128">Wir sehen, dass wir zweimal ein Kapitel 2 in der Collection angelegt haben. Wir müssen also das 3. Element in der 
Collection korrigieren:</p><pre id="9ff0e4a4-701c-4be3-bd00-661fff481008d7e133" xml:space="preserve">xdmp:node-replace(doc("/chapter//C:/input-files/data.xml-0-3.xml")/chapter/title, 
    &lt;title&gt;Test Kapitel 3&lt;/title&gt;);
xdmp:node-replace(doc("/chapter//C:/input-files/data.xml-0-3.xml")/chapter/content, 
    &lt;title&gt;Kapitel Inhalt 3&lt;/title&gt;);</pre><hazardstatement id="263b8198-5cd0-42a8-8331-99ad396ae2e8d7e132" type="caution" status="changed"><messagepanel id="47eaee76-7f74-4745-80e5-c7a27f7316dad7e136"><typeofhazard id="8c42b7e9-6555-41f4-930a-3357c3bba091d7e134">Das Semikolon zum Abschluss des Statements ist eine Besonderheit von MarkLogic und gibt an, dass
dieses Statement in einer Transaktion ausgeführt werden soll.</typeofhazard><howtoavoid id="6dc1b0e1-8202-4662-9294-53e5e832d89cd7e136">In anderen XQuery Implementierungen gibt es diese Funktion möglicherweise nicht.</howtoavoid></messagepanel></hazardstatement><p id="012659dc-8550-4f59-ac3a-ebcbd4bf6ac1d7e138">Nach dieser Korrektur sollten die Daten wieder stimmen und unsere Webapp ist fertig...</p></section></body></topic>